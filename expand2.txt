#![feature(prelude_import)]
//! # ocpp
//!
//! This library is intended to provide a framework for serialising and deserialising OCPP packets as rust types.
//! The original OCPP protocol is an [Open Charge Alliance ](https://www.openchargealliance.org/) project
//!
//! # Example
//!
//! Decoding a heartbeat request and then encoding a heartbeat response
//!
//! ```
//! # fn ocpp_message_example() -> Result<(), serde_json::Error> {
//! use ocpp::*;
//!
//! // Example of storage for known/open calls
//! let mut known_calls = std::collections::HashMap::<String, OCPPCallAction>::new();
//!
//! // Build a reusable response builder
//! struct MyResultBuilder {}
//! impl OCPPCallResultBuilder for MyResultBuilder {
//!     fn authorize(&mut self, req: AuthorizeRequest) -> Result<AuthorizeResponse, OCPPCallErrorCode> {
//!         let status = if req.id_tag == "valid_tag" {
//!             AuthorizationStatus::Accepted
//!         } else {
//!             AuthorizationStatus::Blocked
//!         };
//!
//!         Ok(AuthorizeResponse {
//!             id_tag_info: IdTagInfo {
//!                 expiry_date: None,
//!                 parent_id_tag: None,
//!                 status,
//!             }
//!         })
//!     }
//!
//!     fn heartbeat(&mut self, _req: HeartbeatRequest) -> Result<HeartbeatResponse, OCPPCallErrorCode> {
//!         Ok(
//!             HeartbeatResponse {
//!                 current_time: chrono::Utc::now()
//!             }
//!         )
//!     }
//!
//!     fn boot_notification(&mut self, _req: BootNotificationRequest) -> Result<BootNotificationResponse, OCPPCallErrorCode> {
//!         Ok(
//!             BootNotificationResponse {
//!                 status: BootNotificationStatus::Accepted,
//!                 current_time: chrono::Utc::now(),
//!                 interval: 5,
//!             }
//!         )
//!     }
//! }
//!
//! let mut call_result_builder = MyResultBuilder {};
//!
//! // A simple request message, for demonstration
//! let json = r#"["2", "123", "Heartbeat", {}]"#;
//!
//! // Decode generic OCPP message
//! let message: OCPPMessage = serde_json::from_str(json)?;
//!
//! // Match message type
//! match message {
//!     OCPPMessage::Call(call) => {
//!         // Invoke builder to get response
//!         match call_result_builder.build_response(call) {
//!             Ok(res) => {
//!                 // A result was returned, encode and print it
//!                 println!("Response: {:#?}", serde_json::to_string(&res));
//!             },
//!             Err(e) => {
//!                 // Some error occured during processing
//!                 println!("Error processing request: {:#?}", e);
//!             }
//!         }
//!     },
//!     OCPPMessage::CallResult(result) => {
//!         println!("Call Result: {:#?}", result);
//!     },
//!     OCPPMessage::CallResultUnknown(unknown) => {
//!         // Lookup the call ID in known_calls
//!         if let Some(action) = known_calls.get(&unknown.unique_id) {
//!             // Convert and print known call result
//!             let result = OCPPCallResult::from_unknown(action, unknown)?;
//!             println!("Call Result: {:#?}", result);
//!         } else {
//!             println!("Unknown Call Result: {:#?}", &unknown.unique_id);
//!         }
//!     },
//!     OCPPMessage::CallError(err) => {
//!         println!("Call Error: {:#?}", err);
//!     }
//! }
//! # return Ok(());
//! # }
//! ```
#![warn(missing_docs)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
#[macro_use]
extern crate lazy_static;
pub mod builder_macro {
    //! QoL macros
}
pub mod common {
    //! A collection of common data structures.
    pub mod charging_profile {
        //! Definition and builder for the Charge Profile structure, used to set charging behaviour and scheduling
        //!
        //! ```text
        //! ChargePointProfile
        //!     ChargingProfileId:      u32
        //!     StackLevel:             Option<u32>
        //!     ChargingProfilePurpose  Enum
        //!     ChargingProfileKind     Enum
        //!     RecurrencyKind          Option<Enum>
        //!     ValidFrom               Option<DateTime<Utc>>
        //!     ValidTo                 Option<DateTime<Utc>>
        //!     ChargingSchedule        Obj
        //!         Duration                Option<u32>
        //!         StartSchedule           Option<DateTime<Utc>>
        //!         ChargingRateUnit        Enum
        //!         MinChargingRate         Option<f32>
        //!         ChargingSchedulePeriod  Vec<Obj>
        //!             StartPeriod             u32    
        //!             Limit                   f32
        //!             NumberPhases            Option<u32>
        //! ```
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        /// A ChargingProfile consists of a ChargingSchedule, describing the amount of power or current that can be delivered per time interval.
        #[serde(rename_all = "camelCase")]
        pub struct ChargingProfile {
            /// Required. Unique identifier for this profile.
            pub charging_profile_id: u32,
            /// Optional. Only valid if ChargingProfilePurpose is set to TxProfile, the transactionId MAY be used to match the profile to a specific transaction.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub transaction_id: Option<u32>,
            /// Required. Value determining level in hierarchy stack of profiles. Higher values have precedence over lower values. Lowest level is 0.
            pub stack_level: u32,
            /// Required. Defines the purpose of the schedule transferred by this message.
            pub charging_profile_purpose: ChargingProfilePurpose,
            /// Required. Indicates the kind of schedule.
            pub charging_profile_kind: ChargingProfileKind,
            /// Optional. Indicates the start point of a recurrence
            #[serde(skip_serializing_if = "Option::is_none")]
            pub recurrency_kind: Option<RecurrencyKind>,
            /// Optional. Point in time at which the profile starts to be valid. If absent, the profile is valid as soon as it is received by the Charge Point.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub valid_from: Option<DateTime<Utc>>,
            /// Optional. Point in time at which the profile stops to be valid. If absent, the profile is valid until it is replaced by another profile.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub valid_to: Option<DateTime<Utc>>,
            /// Required. Contains limits for the available power or current over time
            pub charging_schedule: ChargingSchedule,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingProfile {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChargingProfile",
                        false as usize
                            + 1
                            + if Option::is_none(&self.transaction_id) {
                                0
                            } else {
                                1
                            }
                            + 1
                            + 1
                            + 1
                            + if Option::is_none(&self.recurrency_kind) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.valid_from) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.valid_to) {
                                0
                            } else {
                                1
                            }
                            + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargingProfileId",
                        &self.charging_profile_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.transaction_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "transactionId",
                            &self.transaction_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "transactionId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "stackLevel",
                        &self.stack_level,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargingProfilePurpose",
                        &self.charging_profile_purpose,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargingProfileKind",
                        &self.charging_profile_kind,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.recurrency_kind) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "recurrencyKind",
                            &self.recurrency_kind,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "recurrencyKind",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.valid_from) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "validFrom",
                            &self.valid_from,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "validFrom",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.valid_to) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "validTo",
                            &self.valid_to,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "validTo",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargingSchedule",
                        &self.charging_schedule,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingProfile {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "chargingProfileId" => _serde::__private::Ok(__Field::__field0),
                                "transactionId" => _serde::__private::Ok(__Field::__field1),
                                "stackLevel" => _serde::__private::Ok(__Field::__field2),
                                "chargingProfilePurpose" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "chargingProfileKind" => _serde::__private::Ok(__Field::__field4),
                                "recurrencyKind" => _serde::__private::Ok(__Field::__field5),
                                "validFrom" => _serde::__private::Ok(__Field::__field6),
                                "validTo" => _serde::__private::Ok(__Field::__field7),
                                "chargingSchedule" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"chargingProfileId" => _serde::__private::Ok(__Field::__field0),
                                b"transactionId" => _serde::__private::Ok(__Field::__field1),
                                b"stackLevel" => _serde::__private::Ok(__Field::__field2),
                                b"chargingProfilePurpose" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"chargingProfileKind" => _serde::__private::Ok(__Field::__field4),
                                b"recurrencyKind" => _serde::__private::Ok(__Field::__field5),
                                b"validFrom" => _serde::__private::Ok(__Field::__field6),
                                b"validTo" => _serde::__private::Ok(__Field::__field7),
                                b"chargingSchedule" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingProfile>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingProfile;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChargingProfile",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                ChargingProfilePurpose,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                ChargingProfileKind,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<RecurrencyKind>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                ChargingSchedule,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct ChargingProfile with 9 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChargingProfile {
                                charging_profile_id: __field0,
                                transaction_id: __field1,
                                stack_level: __field2,
                                charging_profile_purpose: __field3,
                                charging_profile_kind: __field4,
                                recurrency_kind: __field5,
                                valid_from: __field6,
                                valid_to: __field7,
                                charging_schedule: __field8,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<ChargingProfilePurpose> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<ChargingProfileKind> =
                                _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Option<RecurrencyKind>> =
                                _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field7: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field8: _serde::__private::Option<ChargingSchedule> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingProfileId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transactionId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stackLevel",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingProfilePurpose",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChargingProfilePurpose,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingProfileKind",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChargingProfileKind,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "recurrencyKind",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<RecurrencyKind>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "validFrom",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "validTo",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingSchedule",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChargingSchedule,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargingProfileId")
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("transactionId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("stackLevel") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "chargingProfilePurpose",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "chargingProfileKind",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("recurrencyKind") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("validFrom") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("validTo") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargingSchedule") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChargingProfile {
                                charging_profile_id: __field0,
                                transaction_id: __field1,
                                stack_level: __field2,
                                charging_profile_purpose: __field3,
                                charging_profile_kind: __field4,
                                recurrency_kind: __field5,
                                valid_from: __field6,
                                valid_to: __field7,
                                charging_schedule: __field8,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "chargingProfileId",
                        "transactionId",
                        "stackLevel",
                        "chargingProfilePurpose",
                        "chargingProfileKind",
                        "recurrencyKind",
                        "validFrom",
                        "validTo",
                        "chargingSchedule",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChargingProfile",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingProfile>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingProfile {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                {
                    let names: &'static _ = &[
                        "charging_profile_id",
                        "transaction_id",
                        "stack_level",
                        "charging_profile_purpose",
                        "charging_profile_kind",
                        "recurrency_kind",
                        "valid_from",
                        "valid_to",
                        "charging_schedule",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.charging_profile_id,
                        &&self.transaction_id,
                        &&self.stack_level,
                        &&self.charging_profile_purpose,
                        &&self.charging_profile_kind,
                        &&self.recurrency_kind,
                        &&self.valid_from,
                        &&self.valid_to,
                        &&self.charging_schedule,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ChargingProfile",
                        names,
                        values,
                    )
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingProfile {
            #[inline]
            fn clone(&self) -> ChargingProfile {
                ChargingProfile {
                    charging_profile_id: ::core::clone::Clone::clone(&self.charging_profile_id),
                    transaction_id: ::core::clone::Clone::clone(&self.transaction_id),
                    stack_level: ::core::clone::Clone::clone(&self.stack_level),
                    charging_profile_purpose: ::core::clone::Clone::clone(
                        &self.charging_profile_purpose,
                    ),
                    charging_profile_kind: ::core::clone::Clone::clone(&self.charging_profile_kind),
                    recurrency_kind: ::core::clone::Clone::clone(&self.recurrency_kind),
                    valid_from: ::core::clone::Clone::clone(&self.valid_from),
                    valid_to: ::core::clone::Clone::clone(&self.valid_to),
                    charging_schedule: ::core::clone::Clone::clone(&self.charging_schedule),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingProfile {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingProfile {
            #[inline]
            fn eq(&self, other: &ChargingProfile) -> bool {
                self.charging_profile_id == other.charging_profile_id
                    && self.transaction_id == other.transaction_id
                    && self.stack_level == other.stack_level
                    && self.charging_profile_purpose == other.charging_profile_purpose
                    && self.charging_profile_kind == other.charging_profile_kind
                    && self.recurrency_kind == other.recurrency_kind
                    && self.valid_from == other.valid_from
                    && self.valid_to == other.valid_to
                    && self.charging_schedule == other.charging_schedule
            }
            #[inline]
            fn ne(&self, other: &ChargingProfile) -> bool {
                self.charging_profile_id != other.charging_profile_id
                    || self.transaction_id != other.transaction_id
                    || self.stack_level != other.stack_level
                    || self.charging_profile_purpose != other.charging_profile_purpose
                    || self.charging_profile_kind != other.charging_profile_kind
                    || self.recurrency_kind != other.recurrency_kind
                    || self.valid_from != other.valid_from
                    || self.valid_to != other.valid_to
                    || self.charging_schedule != other.charging_schedule
            }
        }
        /// Charging schedule structure defines a list of charging periods, as used in: [GetCompositeSchedule.conf](crate::server_init::get_composite_schedule) and [ChargingProfile]).
        #[serde(rename_all = "camelCase")]
        pub struct ChargingSchedule {
            /// Optional. Duration of the charging schedule in seconds. If the duration is left empty, the last period will continue indefinitely or until end of the transaction in case startSchedule is absent.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub duration: Option<u32>,
            /// Optional. Starting point of an absolute schedule. If absent the schedule will be relative to start of charging.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub start_schedule: Option<DateTime<Utc>>,
            /// Required. The unit of measure Limit is expressed in.
            pub charging_rate_unit: ChargingRateUnit,
            /// Required. List of ChargingSchedulePeriod elements defining maximum power or current usage over time. The startSchedule of the first ChargingSchedulePeriod SHALL always be 0.
            pub charging_schedule_period: Vec<ChargingSchedulePeriod>,
            /// Optional. Minimum charging rate supported by the electric vehicle. The unit of measure is defined by the chargingRateUnit.
            /// This parameter is intended to be used by a local smart charging algorithm to optimize the power allocation for in the case a charging process is inefficient at lower charging rates. Accepts at most one digit fraction (e.g. 8.1)
            #[serde(skip_serializing_if = "Option::is_none")]
            pub min_charging_rate: Option<f32>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingSchedule {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChargingSchedule",
                        false as usize
                            + if Option::is_none(&self.duration) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.start_schedule) {
                                0
                            } else {
                                1
                            }
                            + 1
                            + 1
                            + if Option::is_none(&self.min_charging_rate) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.duration) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "duration",
                            &self.duration,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "duration",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.start_schedule) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "startSchedule",
                            &self.start_schedule,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "startSchedule",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargingRateUnit",
                        &self.charging_rate_unit,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargingSchedulePeriod",
                        &self.charging_schedule_period,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.min_charging_rate) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "minChargingRate",
                            &self.min_charging_rate,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "minChargingRate",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingSchedule {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "duration" => _serde::__private::Ok(__Field::__field0),
                                "startSchedule" => _serde::__private::Ok(__Field::__field1),
                                "chargingRateUnit" => _serde::__private::Ok(__Field::__field2),
                                "chargingSchedulePeriod" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "minChargingRate" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"duration" => _serde::__private::Ok(__Field::__field0),
                                b"startSchedule" => _serde::__private::Ok(__Field::__field1),
                                b"chargingRateUnit" => _serde::__private::Ok(__Field::__field2),
                                b"chargingSchedulePeriod" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"minChargingRate" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingSchedule>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingSchedule;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChargingSchedule",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChargingSchedule with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ChargingSchedule with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                ChargingRateUnit,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ChargingSchedule with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Vec<ChargingSchedulePeriod>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ChargingSchedule with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<f32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct ChargingSchedule with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChargingSchedule {
                                duration: __field0,
                                start_schedule: __field1,
                                charging_rate_unit: __field2,
                                charging_schedule_period: __field3,
                                min_charging_rate: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<ChargingRateUnit> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Vec<ChargingSchedulePeriod>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<f32>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "duration",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "startSchedule",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingRateUnit",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChargingRateUnit,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingSchedulePeriod",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Vec<ChargingSchedulePeriod>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "minChargingRate",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<f32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("duration") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("startSchedule") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargingRateUnit") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "chargingSchedulePeriod",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("minChargingRate") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChargingSchedule {
                                duration: __field0,
                                start_schedule: __field1,
                                charging_rate_unit: __field2,
                                charging_schedule_period: __field3,
                                min_charging_rate: __field4,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "duration",
                        "startSchedule",
                        "chargingRateUnit",
                        "chargingSchedulePeriod",
                        "minChargingRate",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChargingSchedule",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingSchedule>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingSchedule {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "ChargingSchedule",
                    "duration",
                    &&self.duration,
                    "start_schedule",
                    &&self.start_schedule,
                    "charging_rate_unit",
                    &&self.charging_rate_unit,
                    "charging_schedule_period",
                    &&self.charging_schedule_period,
                    "min_charging_rate",
                    &&self.min_charging_rate,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingSchedule {
            #[inline]
            fn clone(&self) -> ChargingSchedule {
                ChargingSchedule {
                    duration: ::core::clone::Clone::clone(&self.duration),
                    start_schedule: ::core::clone::Clone::clone(&self.start_schedule),
                    charging_rate_unit: ::core::clone::Clone::clone(&self.charging_rate_unit),
                    charging_schedule_period: ::core::clone::Clone::clone(
                        &self.charging_schedule_period,
                    ),
                    min_charging_rate: ::core::clone::Clone::clone(&self.min_charging_rate),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingSchedule {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingSchedule {
            #[inline]
            fn eq(&self, other: &ChargingSchedule) -> bool {
                self.duration == other.duration
                    && self.start_schedule == other.start_schedule
                    && self.charging_rate_unit == other.charging_rate_unit
                    && self.charging_schedule_period == other.charging_schedule_period
                    && self.min_charging_rate == other.min_charging_rate
            }
            #[inline]
            fn ne(&self, other: &ChargingSchedule) -> bool {
                self.duration != other.duration
                    || self.start_schedule != other.start_schedule
                    || self.charging_rate_unit != other.charging_rate_unit
                    || self.charging_schedule_period != other.charging_schedule_period
                    || self.min_charging_rate != other.min_charging_rate
            }
        }
        /// Charging schedule period structure defines a time period in a charging schedule, as used in: [ChargingSchedule].
        #[serde(rename_all = "camelCase")]
        pub struct ChargingSchedulePeriod {
            /// Required. Start of the period, in seconds from the start of schedule. The value of StartPeriod also defines the stop time of the previous period.
            pub start_period: u32,
            /// 1 Required. Charging rate limit during the schedule period, in the applicable chargingRateUnit, for example in Amperes or Watts. Accepts at most one digit fraction (e.g. 8.1).
            pub limit: f32,
            /// Optional. The number of phases that can be used for charging. If a number of phases is needed, numberPhases=3 will be assumed unless another number is given.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub number_phases: Option<u32>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingSchedulePeriod {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChargingSchedulePeriod",
                        false as usize
                            + 1
                            + 1
                            + if Option::is_none(&self.number_phases) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "startPeriod",
                        &self.start_period,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "limit",
                        &self.limit,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.number_phases) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "numberPhases",
                            &self.number_phases,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "numberPhases",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingSchedulePeriod {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "startPeriod" => _serde::__private::Ok(__Field::__field0),
                                "limit" => _serde::__private::Ok(__Field::__field1),
                                "numberPhases" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"startPeriod" => _serde::__private::Ok(__Field::__field0),
                                b"limit" => _serde::__private::Ok(__Field::__field1),
                                b"numberPhases" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingSchedulePeriod>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingSchedulePeriod;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChargingSchedulePeriod",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChargingSchedulePeriod with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<f32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ChargingSchedulePeriod with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ChargingSchedulePeriod with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChargingSchedulePeriod {
                                start_period: __field0,
                                limit: __field1,
                                number_phases: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<f32> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "startPeriod",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "limit",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<f32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "numberPhases",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("startPeriod") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("limit") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("numberPhases") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChargingSchedulePeriod {
                                start_period: __field0,
                                limit: __field1,
                                number_phases: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["startPeriod", "limit", "numberPhases"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChargingSchedulePeriod",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingSchedulePeriod>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingSchedulePeriod {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ChargingSchedulePeriod",
                    "start_period",
                    &&self.start_period,
                    "limit",
                    &&self.limit,
                    "number_phases",
                    &&self.number_phases,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingSchedulePeriod {
            #[inline]
            fn clone(&self) -> ChargingSchedulePeriod {
                ChargingSchedulePeriod {
                    start_period: ::core::clone::Clone::clone(&self.start_period),
                    limit: ::core::clone::Clone::clone(&self.limit),
                    number_phases: ::core::clone::Clone::clone(&self.number_phases),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingSchedulePeriod {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingSchedulePeriod {
            #[inline]
            fn eq(&self, other: &ChargingSchedulePeriod) -> bool {
                self.start_period == other.start_period
                    && self.limit == other.limit
                    && self.number_phases == other.number_phases
            }
            #[inline]
            fn ne(&self, other: &ChargingSchedulePeriod) -> bool {
                self.start_period != other.start_period
                    || self.limit != other.limit
                    || self.number_phases != other.number_phases
            }
        }
        /// Purpose of the charging profile, as used in: ChargingProfile.
        pub enum ChargingProfilePurpose {
            /// Configuration for the maximum power or current available for an entire Charge Point.
            ChargePointMaxProfile,
            /// Default profile *that can be configured in the Charge Point. When a new transaction is started, this profile SHALL be used,
            /// unless it was a transaction that was started by a RemoteStartTransaction.req with a ChargeProfile that is accepted by the Charge Point.
            TxDefaultProfile,
            /// Profile with constraints to be imposed by the Charge Point on the current transaction, or on a new transaction when this is started via a RemoteStartTransaction.req with a ChargeProfile.
            /// A profile with this purpose SHALL cease to be valid when the transaction terminates.
            TxProfile,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingProfilePurpose {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChargingProfilePurpose::ChargePointMaxProfile => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfilePurpose",
                                0u32,
                                "ChargePointMaxProfile",
                            )
                        }
                        ChargingProfilePurpose::TxDefaultProfile => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfilePurpose",
                                1u32,
                                "TxDefaultProfile",
                            )
                        }
                        ChargingProfilePurpose::TxProfile => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfilePurpose",
                                2u32,
                                "TxProfile",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingProfilePurpose {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "ChargePointMaxProfile" => _serde::__private::Ok(__Field::__field0),
                                "TxDefaultProfile" => _serde::__private::Ok(__Field::__field1),
                                "TxProfile" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"ChargePointMaxProfile" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"TxDefaultProfile" => _serde::__private::Ok(__Field::__field1),
                                b"TxProfile" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingProfilePurpose>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingProfilePurpose;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChargingProfilePurpose",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        ChargingProfilePurpose::ChargePointMaxProfile,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfilePurpose::TxDefaultProfile)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfilePurpose::TxProfile)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["ChargePointMaxProfile", "TxDefaultProfile", "TxProfile"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChargingProfilePurpose",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingProfilePurpose>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingProfilePurpose {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChargingProfilePurpose::ChargePointMaxProfile,) => {
                        ::core::fmt::Formatter::write_str(f, "ChargePointMaxProfile")
                    }
                    (&ChargingProfilePurpose::TxDefaultProfile,) => {
                        ::core::fmt::Formatter::write_str(f, "TxDefaultProfile")
                    }
                    (&ChargingProfilePurpose::TxProfile,) => {
                        ::core::fmt::Formatter::write_str(f, "TxProfile")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingProfilePurpose {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingProfilePurpose {
            #[inline]
            fn eq(&self, other: &ChargingProfilePurpose) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChargingProfilePurpose {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChargingProfilePurpose {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChargingProfilePurpose {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChargingProfilePurpose::ChargePointMaxProfile => f.pad("ChargePointMaxProfile"),
                    ChargingProfilePurpose::TxDefaultProfile => f.pad("TxDefaultProfile"),
                    ChargingProfilePurpose::TxProfile => f.pad("TxProfile"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingProfilePurpose {
            #[inline]
            fn clone(&self) -> ChargingProfilePurpose {
                match (&*self,) {
                    (&ChargingProfilePurpose::ChargePointMaxProfile,) => {
                        ChargingProfilePurpose::ChargePointMaxProfile
                    }
                    (&ChargingProfilePurpose::TxDefaultProfile,) => {
                        ChargingProfilePurpose::TxDefaultProfile
                    }
                    (&ChargingProfilePurpose::TxProfile,) => ChargingProfilePurpose::TxProfile,
                }
            }
        }
        /// Kind of charging profile, as used in: ChargingProfile.
        pub enum ChargingProfileKind {
            /// Schedule periods are relative to a fixed point in time defined in the schedule
            Absolute,
            /// The schedule restarts periodically at the first schedule period.
            Recurring,
            /// Schedule periods are relative to a situation-specific start point (such as the start of a Transaction) that is determined by the charge point.
            Relative,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingProfileKind {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChargingProfileKind::Absolute => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfileKind",
                                0u32,
                                "Absolute",
                            )
                        }
                        ChargingProfileKind::Recurring => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfileKind",
                                1u32,
                                "Recurring",
                            )
                        }
                        ChargingProfileKind::Relative => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfileKind",
                                2u32,
                                "Relative",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingProfileKind {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Absolute" => _serde::__private::Ok(__Field::__field0),
                                "Recurring" => _serde::__private::Ok(__Field::__field1),
                                "Relative" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Absolute" => _serde::__private::Ok(__Field::__field0),
                                b"Recurring" => _serde::__private::Ok(__Field::__field1),
                                b"Relative" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingProfileKind>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingProfileKind;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChargingProfileKind",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfileKind::Absolute)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfileKind::Recurring)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfileKind::Relative)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Absolute", "Recurring", "Relative"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChargingProfileKind",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingProfileKind>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingProfileKind {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChargingProfileKind::Absolute,) => {
                        ::core::fmt::Formatter::write_str(f, "Absolute")
                    }
                    (&ChargingProfileKind::Recurring,) => {
                        ::core::fmt::Formatter::write_str(f, "Recurring")
                    }
                    (&ChargingProfileKind::Relative,) => {
                        ::core::fmt::Formatter::write_str(f, "Relative")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingProfileKind {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingProfileKind {
            #[inline]
            fn eq(&self, other: &ChargingProfileKind) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChargingProfileKind {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChargingProfileKind {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChargingProfileKind {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChargingProfileKind::Absolute => f.pad("Absolute"),
                    ChargingProfileKind::Recurring => f.pad("Recurring"),
                    ChargingProfileKind::Relative => f.pad("Relative"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingProfileKind {
            #[inline]
            fn clone(&self) -> ChargingProfileKind {
                match (&*self,) {
                    (&ChargingProfileKind::Absolute,) => ChargingProfileKind::Absolute,
                    (&ChargingProfileKind::Recurring,) => ChargingProfileKind::Recurring,
                    (&ChargingProfileKind::Relative,) => ChargingProfileKind::Relative,
                }
            }
        }
        ///Denotes whether a charge schedule recurs weekly or daily
        pub enum RecurrencyKind {
            /// The schedule restarts every 24 hours, at the same time as in the startSchedule.
            Daily,
            /// The schedule restarts every 7 days, at the same time and day-of-the-week as in the startSchedule.
            Weekly,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RecurrencyKind {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        RecurrencyKind::Daily => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "RecurrencyKind",
                            0u32,
                            "Daily",
                        ),
                        RecurrencyKind::Weekly => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "RecurrencyKind",
                            1u32,
                            "Weekly",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RecurrencyKind {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Daily" => _serde::__private::Ok(__Field::__field0),
                                "Weekly" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Daily" => _serde::__private::Ok(__Field::__field0),
                                b"Weekly" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RecurrencyKind>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RecurrencyKind;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum RecurrencyKind",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(RecurrencyKind::Daily)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(RecurrencyKind::Weekly)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Daily", "Weekly"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "RecurrencyKind",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RecurrencyKind>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RecurrencyKind {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&RecurrencyKind::Daily,) => ::core::fmt::Formatter::write_str(f, "Daily"),
                    (&RecurrencyKind::Weekly,) => ::core::fmt::Formatter::write_str(f, "Weekly"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for RecurrencyKind {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for RecurrencyKind {
            #[inline]
            fn eq(&self, other: &RecurrencyKind) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for RecurrencyKind {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for RecurrencyKind {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for RecurrencyKind {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    RecurrencyKind::Daily => f.pad("Daily"),
                    RecurrencyKind::Weekly => f.pad("Weekly"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RecurrencyKind {
            #[inline]
            fn clone(&self) -> RecurrencyKind {
                match (&*self,) {
                    (&RecurrencyKind::Daily,) => RecurrencyKind::Daily,
                    (&RecurrencyKind::Weekly,) => RecurrencyKind::Weekly,
                }
            }
        }
        ///Unit of power consumption in which a charging schedule is defined
        pub enum ChargingRateUnit {
            ///Amperes per phase
            A,
            ///Total power in Watts
            W,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingRateUnit {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChargingRateUnit::A => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ChargingRateUnit",
                            0u32,
                            "A",
                        ),
                        ChargingRateUnit::W => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ChargingRateUnit",
                            1u32,
                            "W",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingRateUnit {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "A" => _serde::__private::Ok(__Field::__field0),
                                "W" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"A" => _serde::__private::Ok(__Field::__field0),
                                b"W" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingRateUnit>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingRateUnit;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChargingRateUnit",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingRateUnit::A)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingRateUnit::W)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["A", "W"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChargingRateUnit",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingRateUnit>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingRateUnit {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChargingRateUnit::A,) => ::core::fmt::Formatter::write_str(f, "A"),
                    (&ChargingRateUnit::W,) => ::core::fmt::Formatter::write_str(f, "W"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingRateUnit {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingRateUnit {
            #[inline]
            fn eq(&self, other: &ChargingRateUnit) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChargingRateUnit {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChargingRateUnit {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChargingRateUnit {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChargingRateUnit::A => f.pad("A"),
                    ChargingRateUnit::W => f.pad("W"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingRateUnit {
            #[inline]
            fn clone(&self) -> ChargingRateUnit {
                match (&*self,) {
                    (&ChargingRateUnit::A,) => ChargingRateUnit::A,
                    (&ChargingRateUnit::W,) => ChargingRateUnit::W,
                }
            }
        }
        /// Typestate value for Id
        pub struct Id(u32);
        /// Typestate value for missing Id
        pub struct NoId;
        /// Typestate value for Level
        pub struct Level(u32);
        /// Typestate value for missing Level
        pub struct NoLevel;
        /// Charging Profile Builder containing placeholder values to build into a charging profile
        pub struct ChargingProfileBuilder<I, L> {
            /// Required. Unique identifier for this profile.
            pub charging_profile_id: I,
            /// Optional. Only valid if ChargingProfilePurpose is set to TxProfile, the transactionId MAY be used to match the profile to a specific transaction.
            pub transaction_id: Option<u32>,
            /// Required. Value determining level in hierarchy stack of profiles. Higher values have precedence over lower values. Lowest level is 0.
            pub stack_level: L,
            /// Required. Defines the purpose of the schedule transferred by this message.
            pub charging_profile_purpose: ChargingProfilePurpose,
            /// Required. Indicates the kind of schedule.
            pub charging_profile_kind: ChargingProfileKind,
            /// Optional. Indicates the start point of a recurrence
            pub recurrency_kind: Option<RecurrencyKind>,
            /// Optional. Point in time at which the profile starts to be valid. If absent, the profile is valid as soon as it is received by the Charge Point.
            pub valid_from: Option<DateTime<Utc>>,
            /// Optional. Point in time at which the profile stops to be valid. If absent, the profile is valid until it is replaced by another profile.
            pub valid_to: Option<DateTime<Utc>>,
            /// Required. Contains limits for the available power or current over time
            pub charging_schedule: ChargingSchedule,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<I: ::core::fmt::Debug, L: ::core::fmt::Debug> ::core::fmt::Debug
            for ChargingProfileBuilder<I, L>
        {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                {
                    let names: &'static _ = &[
                        "charging_profile_id",
                        "transaction_id",
                        "stack_level",
                        "charging_profile_purpose",
                        "charging_profile_kind",
                        "recurrency_kind",
                        "valid_from",
                        "valid_to",
                        "charging_schedule",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.charging_profile_id,
                        &&self.transaction_id,
                        &&self.stack_level,
                        &&self.charging_profile_purpose,
                        &&self.charging_profile_kind,
                        &&self.recurrency_kind,
                        &&self.valid_from,
                        &&self.valid_to,
                        &&self.charging_schedule,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ChargingProfileBuilder",
                        names,
                        values,
                    )
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<I: ::core::clone::Clone, L: ::core::clone::Clone> ::core::clone::Clone
            for ChargingProfileBuilder<I, L>
        {
            #[inline]
            fn clone(&self) -> ChargingProfileBuilder<I, L> {
                ChargingProfileBuilder {
                    charging_profile_id: ::core::clone::Clone::clone(&self.charging_profile_id),
                    transaction_id: ::core::clone::Clone::clone(&self.transaction_id),
                    stack_level: ::core::clone::Clone::clone(&self.stack_level),
                    charging_profile_purpose: ::core::clone::Clone::clone(
                        &self.charging_profile_purpose,
                    ),
                    charging_profile_kind: ::core::clone::Clone::clone(&self.charging_profile_kind),
                    recurrency_kind: ::core::clone::Clone::clone(&self.recurrency_kind),
                    valid_from: ::core::clone::Clone::clone(&self.valid_from),
                    valid_to: ::core::clone::Clone::clone(&self.valid_to),
                    charging_schedule: ::core::clone::Clone::clone(&self.charging_schedule),
                }
            }
        }
        impl ChargingProfile {
            /// Create a new charging profile builder
            pub fn builder(
                charging_rate_unit: ChargingRateUnit,
            ) -> ChargingProfileBuilder<NoId, NoLevel> {
                ChargingProfileBuilder::new(charging_rate_unit)
            }
        }
        impl ChargingProfileBuilder<NoId, NoLevel> {
            /// Create new charging profile builder and return with initialized typestates
            /// Note, both profile purpose and kind are initialized for transactional purposes
            /// The builder will return a compile error if build is called when the Profile Id, Stack Level and Charging Schedule have not been set.
            ///
            /// A builder can be recycled to generate multiple variants of the same charging profile.
            pub fn new(charging_rate_unit: ChargingRateUnit) -> Self {
                let charging_schedule_period: Vec<ChargingSchedulePeriod> = Vec::new();
                let charging_schedule: ChargingSchedule = ChargingSchedule {
                    duration: None,
                    start_schedule: None,
                    charging_rate_unit,
                    charging_schedule_period,
                    min_charging_rate: None,
                };
                ChargingProfileBuilder { charging_profile_id : NoId , transaction_id : None , stack_level : NoLevel , # [doc = " Default profile purpose"] charging_profile_purpose : ChargingProfilePurpose :: TxProfile , # [doc = " Default profile kind"] charging_profile_kind : ChargingProfileKind :: Relative , recurrency_kind : None , valid_from : None , valid_to : None , # [doc = " Charging schedule with empty period vec"] charging_schedule , }
            }
        }
        impl<I, L> ChargingProfileBuilder<I, L> {
            /// Add Id field and update typestate to verify it has been added
            pub fn id(self, charging_profile_id: u32) -> ChargingProfileBuilder<Id, L> {
                let Self {
                    transaction_id,
                    stack_level,
                    charging_profile_purpose,
                    charging_profile_kind,
                    recurrency_kind,
                    valid_from,
                    valid_to,
                    charging_schedule,
                    ..
                } = self;
                ChargingProfileBuilder {
                    charging_profile_id: Id(charging_profile_id),
                    transaction_id,
                    stack_level,
                    charging_profile_purpose,
                    charging_profile_kind,
                    recurrency_kind,
                    valid_from,
                    valid_to,
                    charging_schedule,
                }
            }
            /// Add Level field and update typestate to verify it has been added
            pub fn level(self, stack_level: u32) -> ChargingProfileBuilder<I, Level> {
                let Self {
                    charging_profile_id,
                    transaction_id,
                    charging_profile_purpose,
                    charging_profile_kind,
                    recurrency_kind,
                    valid_from,
                    valid_to,
                    charging_schedule,
                    ..
                } = self;
                ChargingProfileBuilder {
                    charging_profile_id,
                    transaction_id,
                    stack_level: Level(stack_level),
                    charging_profile_purpose,
                    charging_profile_kind,
                    recurrency_kind,
                    valid_from,
                    valid_to,
                    charging_schedule,
                }
            }
            /// Add period to periods vector without any phases
            pub fn add_period(mut self, start_period: u32, limit: f32) -> Self {
                self.charging_schedule
                    .charging_schedule_period
                    .push(ChargingSchedulePeriod {
                        start_period,
                        limit,
                        number_phases: None,
                    });
                self
            }
            /// add period to schedule periods and include phase
            pub fn add_period_with_phases(
                mut self,
                start_period: u32,
                limit: f32,
                number_phases: u32,
            ) -> Self {
                self.charging_schedule
                    .charging_schedule_period
                    .push(ChargingSchedulePeriod {
                        start_period,
                        limit,
                        number_phases: Some(number_phases),
                    });
                self
            }
            /// Add transaction_id field
            pub fn schedule_duration(mut self, duration: u32) -> Self {
                self.charging_schedule.duration = Some(duration);
                self
            }
            /// Add start_schedule field
            pub fn schedule_start(mut self, start_schedule: DateTime<Utc>) -> Self {
                self.charging_schedule.start_schedule = Some(start_schedule);
                self
            }
            /// Add charging_rate_unit field
            pub fn schedule_charging_rate_unit(
                mut self,
                charging_rate_unit: ChargingRateUnit,
            ) -> Self {
                self.charging_schedule.charging_rate_unit = charging_rate_unit;
                self
            }
            /// Add min_charging_rate field
            pub fn schedule_min_charging_rate(mut self, min_charging_rate: f32) -> Self {
                self.charging_schedule.min_charging_rate = Some(min_charging_rate);
                self
            }
            /// transaction_id field
            pub fn transaction_id(mut self, transaction_id: u32) -> Self {
                self.transaction_id = Some(transaction_id);
                self
            }
            /// Add charging_profile_purpose field
            pub fn charging_profile_purpose(
                mut self,
                charging_profile_purpose: ChargingProfilePurpose,
            ) -> Self {
                self.charging_profile_purpose = charging_profile_purpose;
                self
            }
            /// Add charging_profile_kind field
            pub fn charging_profile_kind(
                mut self,
                charging_profile_kind: ChargingProfileKind,
            ) -> Self {
                self.charging_profile_kind = charging_profile_kind;
                self
            }
            /// Add recurrency_kind field
            pub fn recurrency_kind(mut self, recurrency_kind: RecurrencyKind) -> Self {
                self.recurrency_kind = Some(recurrency_kind);
                self
            }
            /// Add valid_from field
            pub fn valid_from(mut self, valid_from: DateTime<Utc>) -> Self {
                self.valid_from = Some(valid_from);
                self
            }
            /// Add valid_to field
            pub fn valid_to(mut self, valid_to: DateTime<Utc>) -> Self {
                self.valid_to = Some(valid_to);
                self
            }
        }
        impl ChargingProfileBuilder<Id, Level> {
            /// Build ChargingProfile from existing builder struct
            /// This function CANNOT be called unless the profile ID, Stack Level and Schedule have been called
            pub fn build(self) -> ChargingProfile {
                let Id(charging_profile_id) = self.charging_profile_id;
                let Level(stack_level) = self.stack_level;
                ChargingProfile {
                    charging_profile_id,
                    transaction_id: self.transaction_id,
                    stack_level,
                    charging_profile_purpose: self.charging_profile_purpose,
                    charging_profile_kind: self.charging_profile_kind,
                    recurrency_kind: self.recurrency_kind,
                    valid_from: self.valid_from,
                    valid_to: self.valid_to,
                    charging_schedule: self.charging_schedule,
                }
            }
        }
    }
    pub mod common_types {
        //! A collection of shared types used by mutiple message structures
        use chrono::TimeZone;
        use chrono::{DateTime, Utc};
        use proptest::arbitrary::any;
        use proptest::strategy::{BoxedStrategy, Strategy};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        #[serde(transparent)]
        /// Newtype over Time field to allow property testing and validation
        pub struct UtcTime(DateTime<Utc>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UtcTime {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "UtcTime", &&self.0)
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UtcTime {
            #[inline]
            fn clone(&self) -> UtcTime {
                UtcTime(::core::clone::Clone::clone(&self.0))
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UtcTime {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    _serde::Serialize::serialize(&self.0, __serializer)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UtcTime {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::__private::Result::map(
                        _serde::Deserialize::deserialize(__deserializer),
                        |__transparent| UtcTime { 0: __transparent },
                    )
                }
            }
        };
        /// Lets us operate on this newtype as if it were the inner type
        impl std::ops::Deref for UtcTime {
            type Target = DateTime<Utc>;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        /// Allows .into() syntax for DateTime<Utc>
        impl std::convert::From<DateTime<Utc>> for UtcTime {
            fn from(t: DateTime<Utc>) -> Self {
                Self(t)
            }
        }
        /// Arbitrary trait allows this value to be fuzzed by proptest
        impl proptest::arbitrary::Arbitrary for UtcTime {
            type Parameters = ();
            type Strategy = BoxedStrategy<Self>;
            fn arbitrary_with(_args: Self::Parameters) -> Self::Strategy {
                any::<i64>()
                    .prop_map(|z| UtcTime(Utc.timestamp_nanos(z)))
                    .boxed()
            }
            fn arbitrary() -> Self::Strategy {
                Self::arbitrary_with(Default::default())
            }
        }
        ///Generic status message denoting Accepted or Rejected state.
        pub enum SimpleStatus {
            /// Command will be executed.
            Accepted,
            /// Command will not be executed.
            Rejected,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SimpleStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SimpleStatus::Accepted => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SimpleStatus",
                            0u32,
                            "Accepted",
                        ),
                        SimpleStatus::Rejected => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SimpleStatus",
                            1u32,
                            "Rejected",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SimpleStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Rejected" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Rejected" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SimpleStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SimpleStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SimpleStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SimpleStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SimpleStatus::Rejected)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Accepted", "Rejected"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SimpleStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SimpleStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SimpleStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SimpleStatus::Accepted,) => ::core::fmt::Formatter::write_str(f, "Accepted"),
                    (&SimpleStatus::Rejected,) => ::core::fmt::Formatter::write_str(f, "Rejected"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SimpleStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SimpleStatus {
            #[inline]
            fn eq(&self, other: &SimpleStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for SimpleStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SimpleStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SimpleStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SimpleStatus::Accepted => f.pad("Accepted"),
                    SimpleStatus::Rejected => f.pad("Rejected"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SimpleStatus {
            #[inline]
            fn clone(&self) -> SimpleStatus {
                match (&*self,) {
                    (&SimpleStatus::Accepted,) => SimpleStatus::Accepted,
                    (&SimpleStatus::Rejected,) => SimpleStatus::Rejected,
                }
            }
        }
        /// Contains status information about an identifier. It is returned in [Authorize.req](crate::point_init::authorize), [StartTransaction.conf](crate::point_init::start_transaction) and [StopTransaction.conf](crate::point_init::stop_transaction).
        ///
        /// If expiryDate is not given, the status has no end date.
        #[serde(rename_all = "camelCase")]
        pub struct IdTagInfo {
            /// Optional. This contains the date at which idTag should be removed from the Authorization Cache.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub expiry_date: Option<DateTime<Utc>>,
            /// Optional. This contains the parent-identifier. IdToken
            #[serde(skip_serializing_if = "Option::is_none")]
            pub parent_id_tag: Option<String>,
            /// Required. This contains whether the idTag has been accepted or not by the Central System.
            pub status: AuthorizationStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for IdTagInfo {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "IdTagInfo",
                        false as usize
                            + if Option::is_none(&self.expiry_date) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.parent_id_tag) {
                                0
                            } else {
                                1
                            }
                            + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.expiry_date) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expiryDate",
                            &self.expiry_date,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "expiryDate",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.parent_id_tag) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "parentIdTag",
                            &self.parent_id_tag,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "parentIdTag",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for IdTagInfo {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "expiryDate" => _serde::__private::Ok(__Field::__field0),
                                "parentIdTag" => _serde::__private::Ok(__Field::__field1),
                                "status" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"expiryDate" => _serde::__private::Ok(__Field::__field0),
                                b"parentIdTag" => _serde::__private::Ok(__Field::__field1),
                                b"status" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<IdTagInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = IdTagInfo;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "struct IdTagInfo")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct IdTagInfo with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct IdTagInfo with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                AuthorizationStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct IdTagInfo with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(IdTagInfo {
                                expiry_date: __field0,
                                parent_id_tag: __field1,
                                status: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<AuthorizationStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expiryDate",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "parentIdTag",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                AuthorizationStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("expiryDate") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("parentIdTag") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(IdTagInfo {
                                expiry_date: __field0,
                                parent_id_tag: __field1,
                                status: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["expiryDate", "parentIdTag", "status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "IdTagInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<IdTagInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for IdTagInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "IdTagInfo",
                    "expiry_date",
                    &&self.expiry_date,
                    "parent_id_tag",
                    &&self.parent_id_tag,
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for IdTagInfo {
            #[inline]
            fn clone(&self) -> IdTagInfo {
                IdTagInfo {
                    expiry_date: ::core::clone::Clone::clone(&self.expiry_date),
                    parent_id_tag: ::core::clone::Clone::clone(&self.parent_id_tag),
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status in a response to an AuthorizeRequest
        pub enum AuthorizationStatus {
            /// Identifier is allowed for charging.
            Accepted,
            /// Identifier has been blocked. Not allowed for charging.
            Blocked,
            /// Identifier has expired. Not allowed for charging.
            Expired,
            /// Identifier is unknown. Not allowed for charging.
            Invalid,
            /// Identifier is already involved in another transaction and multiple transactions are not allowed. (Only relevant for a StartTransaction.req.)
            ConcurrentTx,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AuthorizationStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        AuthorizationStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "AuthorizationStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        AuthorizationStatus::Blocked => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AuthorizationStatus",
                            1u32,
                            "Blocked",
                        ),
                        AuthorizationStatus::Expired => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AuthorizationStatus",
                            2u32,
                            "Expired",
                        ),
                        AuthorizationStatus::Invalid => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AuthorizationStatus",
                            3u32,
                            "Invalid",
                        ),
                        AuthorizationStatus::ConcurrentTx => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "AuthorizationStatus",
                                4u32,
                                "ConcurrentTx",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AuthorizationStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 5",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Blocked" => _serde::__private::Ok(__Field::__field1),
                                "Expired" => _serde::__private::Ok(__Field::__field2),
                                "Invalid" => _serde::__private::Ok(__Field::__field3),
                                "ConcurrentTx" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Blocked" => _serde::__private::Ok(__Field::__field1),
                                b"Expired" => _serde::__private::Ok(__Field::__field2),
                                b"Invalid" => _serde::__private::Ok(__Field::__field3),
                                b"ConcurrentTx" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AuthorizationStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AuthorizationStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum AuthorizationStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(AuthorizationStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(AuthorizationStatus::Blocked)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(AuthorizationStatus::Expired)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(AuthorizationStatus::Invalid)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(AuthorizationStatus::ConcurrentTx)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Accepted", "Blocked", "Expired", "Invalid", "ConcurrentTx"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "AuthorizationStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AuthorizationStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for AuthorizationStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&AuthorizationStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&AuthorizationStatus::Blocked,) => {
                        ::core::fmt::Formatter::write_str(f, "Blocked")
                    }
                    (&AuthorizationStatus::Expired,) => {
                        ::core::fmt::Formatter::write_str(f, "Expired")
                    }
                    (&AuthorizationStatus::Invalid,) => {
                        ::core::fmt::Formatter::write_str(f, "Invalid")
                    }
                    (&AuthorizationStatus::ConcurrentTx,) => {
                        ::core::fmt::Formatter::write_str(f, "ConcurrentTx")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for AuthorizationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for AuthorizationStatus {
            #[inline]
            fn eq(&self, other: &AuthorizationStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for AuthorizationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for AuthorizationStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for AuthorizationStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    AuthorizationStatus::Accepted => f.pad("Accepted"),
                    AuthorizationStatus::Blocked => f.pad("Blocked"),
                    AuthorizationStatus::Expired => f.pad("Expired"),
                    AuthorizationStatus::Invalid => f.pad("Invalid"),
                    AuthorizationStatus::ConcurrentTx => f.pad("ConcurrentTx"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AuthorizationStatus {
            #[inline]
            fn clone(&self) -> AuthorizationStatus {
                match (&*self,) {
                    (&AuthorizationStatus::Accepted,) => AuthorizationStatus::Accepted,
                    (&AuthorizationStatus::Blocked,) => AuthorizationStatus::Blocked,
                    (&AuthorizationStatus::Expired,) => AuthorizationStatus::Expired,
                    (&AuthorizationStatus::Invalid,) => AuthorizationStatus::Invalid,
                    (&AuthorizationStatus::ConcurrentTx,) => AuthorizationStatus::ConcurrentTx,
                }
            }
        }
    }
    pub mod data_transfer {
        //! Message type for handling large data packets. Can be initiated by both ChargePoint and Central Server
        //!
        //! If a Charge Point needs to send information to the Central System for a function not supported by OCPP, it
        //! SHALL use the DataTransfer.req PDU.
        //! The vendorId in the request SHOULD be known to the Central System and uniquely identify the vendor-specific
        //! implementation. The VendorId SHOULD be a value from the reversed DNS namespace, where the top tiers of the
        //! name, when reversed, should correspond to the publicly registered primary DNS name of the Vendor
        //! organisation.
        //!
        //! Optionally, the messageId in the request PDU MAY be used to indicate a specific message or implementation.
        //! The length of data in both the request and response PDU is undefined and should be agreed upon by all parties
        //! involved.
        //!
        //! If the recipient of the request has no implementation for the specific vendorId it SHALL return a status
        //! UnknownVendor and the data element SHALL not be present. In case of a messageId mismatch (if used) the
        //! recipient SHALL return status UnknownMessageId. In all other cases the usage of status Accepted or Rejected
        //! and the data element is part of the vendor-specific agreement between the parties involved.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        const DATATRANSFERREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:DataTransferRequest\",\r\n    \"title\": \"DataTransferRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"vendorId\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 255\r\n        },\r\n        \"messageId\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50\r\n        },\r\n        \"data\": {\r\n            \"type\": \"string\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"vendorId\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DATATRANSFERREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static DATATRANSFERREQUEST_JSON: DATATRANSFERREQUEST_JSON = DATATRANSFERREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for DATATRANSFERREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(DATATRANSFERREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/DataTransfer.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DATATRANSFERREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DATATRANSFERREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static DATATRANSFERREQUEST_VALIDATOR: DATATRANSFERREQUEST_VALIDATOR =
            DATATRANSFERREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for DATATRANSFERREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&DATATRANSFERREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/DataTransfer.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DATATRANSFERREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for DataTransferRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = DATATRANSFERREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/common/data_transfer.rs:25",
                                    "ocpp::common::data_transfer",
                                    ::tracing::Level::WARN,
                                    Some("src/common/data_transfer.rs"),
                                    Some(25u32),
                                    Some("ocpp::common::data_transfer"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/common/data_transfer.rs:25",
                                    "ocpp::common::data_transfer",
                                    ::tracing::Level::TRACE,
                                    Some("src/common/data_transfer.rs"),
                                    Some(25u32),
                                    Some("ocpp::common::data_transfer"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the DataTransfer.req PDU sent either by the Central System to the Charge Point or vice versa.
        pub struct DataTransferRequest {
            /// Required. This identifies the Vendor specific implementation
            pub vendor_id: String,
            /// Optional. Additional identification field
            #[serde(skip_serializing_if = "Option::is_none")]
            pub message_id: Option<String>,
            /// Optional. Data without specified length or format.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub data: Option<String>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DataTransferRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DataTransferRequest",
                        false as usize
                            + 1
                            + if Option::is_none(&self.message_id) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.data) { 0 } else { 1 },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "vendorId",
                        &self.vendor_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.message_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "messageId",
                            &self.message_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "messageId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.data) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "data",
                            &self.data,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "data") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DataTransferRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "vendorId" => _serde::__private::Ok(__Field::__field0),
                                "messageId" => _serde::__private::Ok(__Field::__field1),
                                "data" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"vendorId" => _serde::__private::Ok(__Field::__field0),
                                b"messageId" => _serde::__private::Ok(__Field::__field1),
                                b"data" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DataTransferRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DataTransferRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DataTransferRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DataTransferRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DataTransferRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DataTransferRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DataTransferRequest {
                                vendor_id: __field0,
                                message_id: __field1,
                                data: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "vendorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "messageId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "data",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("vendorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("messageId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("data") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(DataTransferRequest {
                                vendor_id: __field0,
                                message_id: __field1,
                                data: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["vendorId", "messageId", "data"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DataTransferRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DataTransferRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DataTransferRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "DataTransferRequest",
                    "vendor_id",
                    &&self.vendor_id,
                    "message_id",
                    &&self.message_id,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DataTransferRequest {
            #[inline]
            fn clone(&self) -> DataTransferRequest {
                DataTransferRequest {
                    vendor_id: ::core::clone::Clone::clone(&self.vendor_id),
                    message_id: ::core::clone::Clone::clone(&self.message_id),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        const DATATRANSFERRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"DataTransferResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\",\n                \"UnknownMessageId\",\n                \"UnknownVendorId\"\n            ]\n        },\n        \"data\": {\n            \"type\": \"string\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DATATRANSFERRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static DATATRANSFERRESPONSE_JSON: DATATRANSFERRESPONSE_JSON = DATATRANSFERRESPONSE_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for DATATRANSFERRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(DATATRANSFERRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/DataTransferResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DATATRANSFERRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DATATRANSFERRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static DATATRANSFERRESPONSE_VALIDATOR: DATATRANSFERRESPONSE_VALIDATOR =
            DATATRANSFERRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for DATATRANSFERRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&DATATRANSFERRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/DataTransferResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DATATRANSFERRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for DataTransferResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = DATATRANSFERRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/common/data_transfer.rs:40",
                                    "ocpp::common::data_transfer",
                                    ::tracing::Level::WARN,
                                    Some("src/common/data_transfer.rs"),
                                    Some(40u32),
                                    Some("ocpp::common::data_transfer"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/common/data_transfer.rs:40",
                                    "ocpp::common::data_transfer",
                                    ::tracing::Level::TRACE,
                                    Some("src/common/data_transfer.rs"),
                                    Some(40u32),
                                    Some("ocpp::common::data_transfer"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the DataTransfer.conf PDU sent by the Charge Point to the Central System or vice versa in response to a DataTransfer.req PDU.
        pub struct DataTransferResponse {
            /// Required. This indicates the success or failure of the data transfer.
            pub status: DataTransferStatus,
            /// Optional. Data in response to request.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub data: Option<String>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DataTransferResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DataTransferResponse",
                        false as usize + 1 + if Option::is_none(&self.data) { 0 } else { 1 },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.data) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "data",
                            &self.data,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "data") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DataTransferResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                "data" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                b"data" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DataTransferResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DataTransferResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DataTransferResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                DataTransferStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DataTransferResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DataTransferResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DataTransferResponse {
                                status: __field0,
                                data: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<DataTransferStatus> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                DataTransferStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "data",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("data") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(DataTransferResponse {
                                status: __field0,
                                data: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status", "data"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DataTransferResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DataTransferResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DataTransferResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DataTransferResponse",
                    "status",
                    &&self.status,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DataTransferResponse {
            #[inline]
            fn clone(&self) -> DataTransferResponse {
                DataTransferResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        /// Status in [DataTransferResponse]
        pub enum DataTransferStatus {
            /// Message has been accepted and the contained request is accepted.
            Accepted,
            /// Message has been accepted but the contained request is rejected.
            Rejected,
            /// Message could not be interpreted due to unknown messageId string.
            UnknownMessageId,
            /// Message could not be interpreted due to unknown vendorId string.
            UnknownVendorId,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DataTransferStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        DataTransferStatus::Accepted => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DataTransferStatus",
                            0u32,
                            "Accepted",
                        ),
                        DataTransferStatus::Rejected => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DataTransferStatus",
                            1u32,
                            "Rejected",
                        ),
                        DataTransferStatus::UnknownMessageId => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DataTransferStatus",
                                2u32,
                                "UnknownMessageId",
                            )
                        }
                        DataTransferStatus::UnknownVendorId => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DataTransferStatus",
                                3u32,
                                "UnknownVendorId",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DataTransferStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Rejected" => _serde::__private::Ok(__Field::__field1),
                                "UnknownMessageId" => _serde::__private::Ok(__Field::__field2),
                                "UnknownVendorId" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Rejected" => _serde::__private::Ok(__Field::__field1),
                                b"UnknownMessageId" => _serde::__private::Ok(__Field::__field2),
                                b"UnknownVendorId" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DataTransferStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DataTransferStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DataTransferStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DataTransferStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DataTransferStatus::Rejected)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DataTransferStatus::UnknownMessageId)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DataTransferStatus::UnknownVendorId)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Accepted",
                        "Rejected",
                        "UnknownMessageId",
                        "UnknownVendorId",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DataTransferStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DataTransferStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DataTransferStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&DataTransferStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&DataTransferStatus::Rejected,) => {
                        ::core::fmt::Formatter::write_str(f, "Rejected")
                    }
                    (&DataTransferStatus::UnknownMessageId,) => {
                        ::core::fmt::Formatter::write_str(f, "UnknownMessageId")
                    }
                    (&DataTransferStatus::UnknownVendorId,) => {
                        ::core::fmt::Formatter::write_str(f, "UnknownVendorId")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for DataTransferStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for DataTransferStatus {
            #[inline]
            fn eq(&self, other: &DataTransferStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for DataTransferStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for DataTransferStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for DataTransferStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    DataTransferStatus::Accepted => f.pad("Accepted"),
                    DataTransferStatus::Rejected => f.pad("Rejected"),
                    DataTransferStatus::UnknownMessageId => f.pad("UnknownMessageId"),
                    DataTransferStatus::UnknownVendorId => f.pad("UnknownVendorId"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DataTransferStatus {
            #[inline]
            fn clone(&self) -> DataTransferStatus {
                match (&*self,) {
                    (&DataTransferStatus::Accepted,) => DataTransferStatus::Accepted,
                    (&DataTransferStatus::Rejected,) => DataTransferStatus::Rejected,
                    (&DataTransferStatus::UnknownMessageId,) => {
                        DataTransferStatus::UnknownMessageId
                    }
                    (&DataTransferStatus::UnknownVendorId,) => DataTransferStatus::UnknownVendorId,
                }
            }
        }
    }
    pub mod meter_value {
        //! Definition for the meter value type
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::{Display, EnumIter};
        /// Collection of one or more sampled values (as seen in [MeterValues.req](crate::point_init::meter_values) and [StopTransaction.req](crate::point_init::stop_transaction)), all sampled at the same time.
        #[serde(rename_all = "camelCase")]
        pub struct MeterValue {
            /// Required. Timestamp for measured value(s).
            pub timestamp: DateTime<Utc>,
            /// Required. One or more measured values
            pub sampled_value: Vec<SampledValue>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MeterValue {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "MeterValue",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "timestamp",
                        &self.timestamp,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sampledValue",
                        &self.sampled_value,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MeterValue {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "timestamp" => _serde::__private::Ok(__Field::__field0),
                                "sampledValue" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"timestamp" => _serde::__private::Ok(__Field::__field0),
                                b"sampledValue" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MeterValue>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MeterValue;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MeterValue",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                DateTime<Utc>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MeterValue with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Vec<SampledValue>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MeterValue with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MeterValue {
                                timestamp: __field0,
                                sampled_value: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<DateTime<Utc>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<SampledValue>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timestamp",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<DateTime<Utc>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sampledValue",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Vec<SampledValue>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("timestamp") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("sampledValue") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(MeterValue {
                                timestamp: __field0,
                                sampled_value: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["timestamp", "sampledValue"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MeterValue",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MeterValue>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MeterValue {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "MeterValue",
                    "timestamp",
                    &&self.timestamp,
                    "sampled_value",
                    &&self.sampled_value,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MeterValue {
            #[inline]
            fn clone(&self) -> MeterValue {
                MeterValue {
                    timestamp: ::core::clone::Clone::clone(&self.timestamp),
                    sampled_value: ::core::clone::Clone::clone(&self.sampled_value),
                }
            }
        }
        ///Single sampled value, used by [MeterValues](crate::point_init::meter_values)
        #[serde(rename_all = "camelCase")]
        pub struct SampledValue {
            /// Required. Value as a Raw (decimal) number or SignedData. Field Type is string to allow for digitally signed data readings. Decimal numeric values are also acceptable to allow fractional values for measurands such as Temperature and Current.
            pub value: String,
            /// Optional. Type of detail value: start, end or sample. Default = Sample.Periodic
            #[serde(skip_serializing_if = "Option::is_none")]
            pub context: Option<SampledContext>,
            /// Optional. Raw or signed data. Default = Raw
            #[serde(skip_serializing_if = "Option::is_none")]
            pub format: Option<SampledFormat>,
            /// Optional. Type of measurement. Default = Energy.Active.Import.Register
            #[serde(skip_serializing_if = "Option::is_none")]
            pub measurand: Option<SampledMeasurand>,
            /// Optional. indicates how the measured value is to be interpreted. For instance between L1 and neutral (L1-N) Please note that not all values of phase are applicable to all Measurands. When phase is absent, the measured value is interpreted as an overall value.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub phase: Option<SampledPhase>,
            /// Optional. Location of measurement. Default=Outlet
            #[serde(skip_serializing_if = "Option::is_none")]
            pub location: Option<SampledLocation>,
            /// Optional. Unit of the value. Default = Wh if the (default) measurand is an Energy type.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unit: Option<SampledUnit>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledValue {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SampledValue",
                        false as usize
                            + 1
                            + if Option::is_none(&self.context) { 0 } else { 1 }
                            + if Option::is_none(&self.format) { 0 } else { 1 }
                            + if Option::is_none(&self.measurand) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.phase) { 0 } else { 1 }
                            + if Option::is_none(&self.location) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.unit) { 0 } else { 1 },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        &self.value,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.context) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "context",
                            &self.context,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "context",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.format) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "format",
                            &self.format,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "format")
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.measurand) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "measurand",
                            &self.measurand,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "measurand",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.phase) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "phase",
                            &self.phase,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "phase")
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.location) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "location",
                            &self.location,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "location",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.unit) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unit",
                            &self.unit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "unit") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledValue {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "value" => _serde::__private::Ok(__Field::__field0),
                                "context" => _serde::__private::Ok(__Field::__field1),
                                "format" => _serde::__private::Ok(__Field::__field2),
                                "measurand" => _serde::__private::Ok(__Field::__field3),
                                "phase" => _serde::__private::Ok(__Field::__field4),
                                "location" => _serde::__private::Ok(__Field::__field5),
                                "unit" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"value" => _serde::__private::Ok(__Field::__field0),
                                b"context" => _serde::__private::Ok(__Field::__field1),
                                b"format" => _serde::__private::Ok(__Field::__field2),
                                b"measurand" => _serde::__private::Ok(__Field::__field3),
                                b"phase" => _serde::__private::Ok(__Field::__field4),
                                b"location" => _serde::__private::Ok(__Field::__field5),
                                b"unit" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledValue>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledValue;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SampledValue",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<SampledContext>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<SampledFormat>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<SampledMeasurand>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<SampledPhase>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<SampledLocation>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<SampledUnit>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct SampledValue with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SampledValue {
                                value: __field0,
                                context: __field1,
                                format: __field2,
                                measurand: __field3,
                                phase: __field4,
                                location: __field5,
                                unit: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<SampledContext>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<SampledFormat>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<SampledMeasurand>> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<SampledPhase>> =
                                _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Option<SampledLocation>> =
                                _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Option<SampledUnit>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "context",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SampledContext>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "format",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SampledFormat>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "measurand",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SampledMeasurand>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "phase",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SampledPhase>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "location",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SampledLocation>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unit",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SampledUnit>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("value") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("context") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("format") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("measurand") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("phase") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("location") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("unit") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(SampledValue {
                                value: __field0,
                                context: __field1,
                                format: __field2,
                                measurand: __field3,
                                phase: __field4,
                                location: __field5,
                                unit: __field6,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "value",
                        "context",
                        "format",
                        "measurand",
                        "phase",
                        "location",
                        "unit",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SampledValue",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledValue>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SampledValue {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                {
                    let names: &'static _ = &[
                        "value",
                        "context",
                        "format",
                        "measurand",
                        "phase",
                        "location",
                        "unit",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.value,
                        &&self.context,
                        &&self.format,
                        &&self.measurand,
                        &&self.phase,
                        &&self.location,
                        &&self.unit,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "SampledValue",
                        names,
                        values,
                    )
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SampledValue {
            #[inline]
            fn clone(&self) -> SampledValue {
                SampledValue {
                    value: ::core::clone::Clone::clone(&self.value),
                    context: ::core::clone::Clone::clone(&self.context),
                    format: ::core::clone::Clone::clone(&self.format),
                    measurand: ::core::clone::Clone::clone(&self.measurand),
                    phase: ::core::clone::Clone::clone(&self.phase),
                    location: ::core::clone::Clone::clone(&self.location),
                    unit: ::core::clone::Clone::clone(&self.unit),
                }
            }
        }
        /// Values of the context field of a value in SampledValue.
        pub enum SampledContext {
            /// Value taken at start of interruption.
            #[serde(rename = "Interruption.Begin")]
            /// Value taken when resuming after interruption.
            InterruptionBegin,
            #[serde(rename = "Interruption.End")]
            ///Value taken when resuming after interruption.
            InterruptionEnd,
            #[serde(rename = "Sample.Clock")]
            /// Value taken at clock aligned interval.
            SampleClock,
            #[serde(rename = "Sample.Periodic")]
            /// Value taken as periodic sample relative to start time of transaction.
            SamplePeriodic,
            #[serde(rename = "Transaction.Begin")]
            /// Value taken at start of transaction.
            TransactionBegin,
            #[serde(rename = "Transaction.End")]
            /// Value taken at end of transaction.
            TransactionEnd,
            /// Value taken in response to a TriggerMessage.req
            Trigger,
            /// Value for any other situations.
            Other,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledContext {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SampledContext::InterruptionBegin => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledContext",
                                0u32,
                                "Interruption.Begin",
                            )
                        }
                        SampledContext::InterruptionEnd => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledContext",
                                1u32,
                                "Interruption.End",
                            )
                        }
                        SampledContext::SampleClock => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledContext",
                            2u32,
                            "Sample.Clock",
                        ),
                        SampledContext::SamplePeriodic => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledContext",
                                3u32,
                                "Sample.Periodic",
                            )
                        }
                        SampledContext::TransactionBegin => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledContext",
                                4u32,
                                "Transaction.Begin",
                            )
                        }
                        SampledContext::TransactionEnd => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledContext",
                                5u32,
                                "Transaction.End",
                            )
                        }
                        SampledContext::Trigger => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledContext",
                            6u32,
                            "Trigger",
                        ),
                        SampledContext::Other => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledContext",
                            7u32,
                            "Other",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledContext {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 8",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Interruption.Begin" => _serde::__private::Ok(__Field::__field0),
                                "Interruption.End" => _serde::__private::Ok(__Field::__field1),
                                "Sample.Clock" => _serde::__private::Ok(__Field::__field2),
                                "Sample.Periodic" => _serde::__private::Ok(__Field::__field3),
                                "Transaction.Begin" => _serde::__private::Ok(__Field::__field4),
                                "Transaction.End" => _serde::__private::Ok(__Field::__field5),
                                "Trigger" => _serde::__private::Ok(__Field::__field6),
                                "Other" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Interruption.Begin" => _serde::__private::Ok(__Field::__field0),
                                b"Interruption.End" => _serde::__private::Ok(__Field::__field1),
                                b"Sample.Clock" => _serde::__private::Ok(__Field::__field2),
                                b"Sample.Periodic" => _serde::__private::Ok(__Field::__field3),
                                b"Transaction.Begin" => _serde::__private::Ok(__Field::__field4),
                                b"Transaction.End" => _serde::__private::Ok(__Field::__field5),
                                b"Trigger" => _serde::__private::Ok(__Field::__field6),
                                b"Other" => _serde::__private::Ok(__Field::__field7),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledContext>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledContext;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SampledContext",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::InterruptionBegin)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::InterruptionEnd)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::SampleClock)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::SamplePeriodic)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::TransactionBegin)
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::TransactionEnd)
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::Trigger)
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledContext::Other)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Interruption.Begin",
                        "Interruption.End",
                        "Sample.Clock",
                        "Sample.Periodic",
                        "Transaction.Begin",
                        "Transaction.End",
                        "Trigger",
                        "Other",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SampledContext",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledContext>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SampledContext {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SampledContext::InterruptionBegin,) => {
                        ::core::fmt::Formatter::write_str(f, "InterruptionBegin")
                    }
                    (&SampledContext::InterruptionEnd,) => {
                        ::core::fmt::Formatter::write_str(f, "InterruptionEnd")
                    }
                    (&SampledContext::SampleClock,) => {
                        ::core::fmt::Formatter::write_str(f, "SampleClock")
                    }
                    (&SampledContext::SamplePeriodic,) => {
                        ::core::fmt::Formatter::write_str(f, "SamplePeriodic")
                    }
                    (&SampledContext::TransactionBegin,) => {
                        ::core::fmt::Formatter::write_str(f, "TransactionBegin")
                    }
                    (&SampledContext::TransactionEnd,) => {
                        ::core::fmt::Formatter::write_str(f, "TransactionEnd")
                    }
                    (&SampledContext::Trigger,) => ::core::fmt::Formatter::write_str(f, "Trigger"),
                    (&SampledContext::Other,) => ::core::fmt::Formatter::write_str(f, "Other"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SampledContext {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SampledContext {
            #[inline]
            fn eq(&self, other: &SampledContext) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for SampledContext {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SampledContext {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SampledContext {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SampledContext::InterruptionBegin => f.pad("InterruptionBegin"),
                    SampledContext::InterruptionEnd => f.pad("InterruptionEnd"),
                    SampledContext::SampleClock => f.pad("SampleClock"),
                    SampledContext::SamplePeriodic => f.pad("SamplePeriodic"),
                    SampledContext::TransactionBegin => f.pad("TransactionBegin"),
                    SampledContext::TransactionEnd => f.pad("TransactionEnd"),
                    SampledContext::Trigger => f.pad("Trigger"),
                    SampledContext::Other => f.pad("Other"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SampledContext {
            #[inline]
            fn clone(&self) -> SampledContext {
                match (&*self,) {
                    (&SampledContext::InterruptionBegin,) => SampledContext::InterruptionBegin,
                    (&SampledContext::InterruptionEnd,) => SampledContext::InterruptionEnd,
                    (&SampledContext::SampleClock,) => SampledContext::SampleClock,
                    (&SampledContext::SamplePeriodic,) => SampledContext::SamplePeriodic,
                    (&SampledContext::TransactionBegin,) => SampledContext::TransactionBegin,
                    (&SampledContext::TransactionEnd,) => SampledContext::TransactionEnd,
                    (&SampledContext::Trigger,) => SampledContext::Trigger,
                    (&SampledContext::Other,) => SampledContext::Other,
                }
            }
        }
        /// Format that specifies how the value element in SampledValue is to be interpreted.
        pub enum SampledFormat {
            /// Data is to be interpreted as integer/decimal numeric data.
            Raw,
            /// Data is represented as a signed binary data block, encoded as hex data.
            SignedData,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledFormat {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SampledFormat::Raw => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledFormat",
                            0u32,
                            "Raw",
                        ),
                        SampledFormat::SignedData => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledFormat",
                            1u32,
                            "SignedData",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledFormat {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Raw" => _serde::__private::Ok(__Field::__field0),
                                "SignedData" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Raw" => _serde::__private::Ok(__Field::__field0),
                                b"SignedData" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledFormat>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledFormat;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SampledFormat",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledFormat::Raw)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledFormat::SignedData)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Raw", "SignedData"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SampledFormat",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledFormat>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SampledFormat {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SampledFormat::Raw,) => ::core::fmt::Formatter::write_str(f, "Raw"),
                    (&SampledFormat::SignedData,) => {
                        ::core::fmt::Formatter::write_str(f, "SignedData")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SampledFormat {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SampledFormat {
            #[inline]
            fn eq(&self, other: &SampledFormat) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for SampledFormat {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SampledFormat {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SampledFormat {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SampledFormat::Raw => f.pad("Raw"),
                    SampledFormat::SignedData => f.pad("SignedData"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SampledFormat {
            #[inline]
            fn clone(&self) -> SampledFormat {
                match (&*self,) {
                    (&SampledFormat::Raw,) => SampledFormat::Raw,
                    (&SampledFormat::SignedData,) => SampledFormat::SignedData,
                }
            }
        }
        /// Allowable values of the optional "measurand" field of a Value element, as used in MeterValuesRequest and StopTransaction.req messages. Default value of "measurand" is always "Energy.Active.Import.Register"
        pub enum SampledMeasurand {
            /// Numerical value read from the "active electrical energy" (Wh or kWh) register of the (most authoritative) electrical meter measuring energy exported (to the grid).
            #[serde(rename = "Energy.Active.Export.Register")]
            EnergyActiveExportRegister,
            /// Numerical value read from the "active electrical energy" (Wh or kWh) register of the (most authoritative) electrical meter measuring energy imported (from the grid supply).
            #[serde(rename = "Energy.Active.Import.Register")]
            EnergyActiveImportRegister,
            /// Numerical value read from the "reactive electrical energy" (VARh or kVARh) register of the (most authoritative) electrical meter measuring energy exported (to the grid).
            #[serde(rename = "Energy.Reactive.Export.Register")]
            EnergyReactiveExportRegister,
            /// Numerical value read from the "reactive electrical energy" (VARh or kVARh) register of the (most authoritative) electrical meter measuring energy imported (from the grid supply).
            #[serde(rename = "Energy.Reactive.Import.Register")]
            EnergyReactiveImportRegister,
            /// Absolute amount of "active electrical energy" (Wh or kWh) exported (to the grid) during an associated time "interval", specified by a Metervalues ReadingContext, and applicable interval duration
            /// configuration values (in seconds) for "ClockAlignedDataInterval" and "MeterValueSampleInterval".
            #[serde(rename = "Energy.Active.Export.Interval")]
            EnergyActiveExportInterval,
            /// Absolute amount of "active electrical energy" (Wh or kWh) imported (from the grid supply) during an associated time "interval", specified by a Metervalues ReadingContext, and applicable interval
            /// duration configuration values (in seconds) for "ClockAlignedDataInterval" and "MeterValueSampleInterval".
            #[serde(rename = "Energy.Active.Import.Interval")]
            EnergyActiveImportInterval,
            /// Absolute amount of "reactive electrical energy" (VARh or kVARh) exported (to the grid) during an associated time "interval", specified by a Metervalues ReadingContext, and applicable interval
            /// duration configuration values (in seconds) for "ClockAlignedDataInterval" and "MeterValueSampleInterval".
            #[serde(rename = "Energy.Reactive.Export.Interval")]
            EnergyReactiveExportInterval,
            /// Absolute amount of "reactive electrical energy" (VARh or kVARh) imported (from the grid supply) during an associated time "interval", specified by a Metervalues ReadingContext, and applicable
            /// interval duration configuration values (in seconds) for "ClockAlignedDataInterval" and "MeterValueSampleInterval".
            #[serde(rename = "Energy.Reactive.Import.Interval")]
            EnergyReactiveImportInterval,
            /// Instantaneous active power exported by EV. (W or kW)
            #[serde(rename = "Power.Active.Export")]
            PowerActiveExport,
            /// Instantaneous active power imported by EV. (W or kW)
            #[serde(rename = "Power.Active.Import")]
            PowerActiveImport,
            /// Maximum power offered to EV
            #[serde(rename = "Power.Offered")]
            PowerOffered,
            /// Instantaneous reactive power exported by EV. (var or kvar)
            #[serde(rename = "Power.Reactive.Export")]
            PowerReactiveExport,
            /// Instantaneous reactive power imported by EV. (var or kvar)
            #[serde(rename = "Power.Reactive.Import")]
            PowerReactiveImport,
            /// Instantaneous power factor of total energy flow
            #[serde(rename = "Power.Factor")]
            PowerFactor,
            /// Instantaneous current flow to EV
            #[serde(rename = "Current.Import")]
            CurrentImport,
            ///Instantaneous current flow from EV
            #[serde(rename = "Current.Export")]
            CurrentExport,
            /// Maximum current offered to EV
            #[serde(rename = "Current.Offered")]
            CurrentOffered,
            /// Instantaneous AC RMS supply voltage
            Voltage,
            /// Instantaneous reading of powerline frequency. NOTE: OCPP 1.6 does not have a UnitOfMeasure for frequency, the UnitOfMeasure for any SampledValue with measurand: Frequency is Hertz.
            Frequency,
            /// Temperature reading inside Charge Point.
            Temperature,
            /// State of charge of charging vehicle in percentage
            SoC,
            /// Fan speed in RPM
            RPM,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledMeasurand {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SampledMeasurand::EnergyActiveExportRegister => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                0u32,
                                "Energy.Active.Export.Register",
                            )
                        }
                        SampledMeasurand::EnergyActiveImportRegister => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                1u32,
                                "Energy.Active.Import.Register",
                            )
                        }
                        SampledMeasurand::EnergyReactiveExportRegister => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                2u32,
                                "Energy.Reactive.Export.Register",
                            )
                        }
                        SampledMeasurand::EnergyReactiveImportRegister => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                3u32,
                                "Energy.Reactive.Import.Register",
                            )
                        }
                        SampledMeasurand::EnergyActiveExportInterval => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                4u32,
                                "Energy.Active.Export.Interval",
                            )
                        }
                        SampledMeasurand::EnergyActiveImportInterval => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                5u32,
                                "Energy.Active.Import.Interval",
                            )
                        }
                        SampledMeasurand::EnergyReactiveExportInterval => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                6u32,
                                "Energy.Reactive.Export.Interval",
                            )
                        }
                        SampledMeasurand::EnergyReactiveImportInterval => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                7u32,
                                "Energy.Reactive.Import.Interval",
                            )
                        }
                        SampledMeasurand::PowerActiveExport => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                8u32,
                                "Power.Active.Export",
                            )
                        }
                        SampledMeasurand::PowerActiveImport => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                9u32,
                                "Power.Active.Import",
                            )
                        }
                        SampledMeasurand::PowerOffered => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                10u32,
                                "Power.Offered",
                            )
                        }
                        SampledMeasurand::PowerReactiveExport => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                11u32,
                                "Power.Reactive.Export",
                            )
                        }
                        SampledMeasurand::PowerReactiveImport => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                12u32,
                                "Power.Reactive.Import",
                            )
                        }
                        SampledMeasurand::PowerFactor => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                13u32,
                                "Power.Factor",
                            )
                        }
                        SampledMeasurand::CurrentImport => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                14u32,
                                "Current.Import",
                            )
                        }
                        SampledMeasurand::CurrentExport => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                15u32,
                                "Current.Export",
                            )
                        }
                        SampledMeasurand::CurrentOffered => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                16u32,
                                "Current.Offered",
                            )
                        }
                        SampledMeasurand::Voltage => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledMeasurand",
                            17u32,
                            "Voltage",
                        ),
                        SampledMeasurand::Frequency => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledMeasurand",
                            18u32,
                            "Frequency",
                        ),
                        SampledMeasurand::Temperature => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "SampledMeasurand",
                                19u32,
                                "Temperature",
                            )
                        }
                        SampledMeasurand::SoC => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledMeasurand",
                            20u32,
                            "SoC",
                        ),
                        SampledMeasurand::RPM => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledMeasurand",
                            21u32,
                            "RPM",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledMeasurand {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                        __field15,
                        __field16,
                        __field17,
                        __field18,
                        __field19,
                        __field20,
                        __field21,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                14u64 => _serde::__private::Ok(__Field::__field14),
                                15u64 => _serde::__private::Ok(__Field::__field15),
                                16u64 => _serde::__private::Ok(__Field::__field16),
                                17u64 => _serde::__private::Ok(__Field::__field17),
                                18u64 => _serde::__private::Ok(__Field::__field18),
                                19u64 => _serde::__private::Ok(__Field::__field19),
                                20u64 => _serde::__private::Ok(__Field::__field20),
                                21u64 => _serde::__private::Ok(__Field::__field21),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 22",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Energy.Active.Export.Register" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "Energy.Active.Import.Register" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "Energy.Reactive.Export.Register" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "Energy.Reactive.Import.Register" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "Energy.Active.Export.Interval" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "Energy.Active.Import.Interval" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "Energy.Reactive.Export.Interval" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "Energy.Reactive.Import.Interval" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                "Power.Active.Export" => _serde::__private::Ok(__Field::__field8),
                                "Power.Active.Import" => _serde::__private::Ok(__Field::__field9),
                                "Power.Offered" => _serde::__private::Ok(__Field::__field10),
                                "Power.Reactive.Export" => {
                                    _serde::__private::Ok(__Field::__field11)
                                }
                                "Power.Reactive.Import" => {
                                    _serde::__private::Ok(__Field::__field12)
                                }
                                "Power.Factor" => _serde::__private::Ok(__Field::__field13),
                                "Current.Import" => _serde::__private::Ok(__Field::__field14),
                                "Current.Export" => _serde::__private::Ok(__Field::__field15),
                                "Current.Offered" => _serde::__private::Ok(__Field::__field16),
                                "Voltage" => _serde::__private::Ok(__Field::__field17),
                                "Frequency" => _serde::__private::Ok(__Field::__field18),
                                "Temperature" => _serde::__private::Ok(__Field::__field19),
                                "SoC" => _serde::__private::Ok(__Field::__field20),
                                "RPM" => _serde::__private::Ok(__Field::__field21),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Energy.Active.Export.Register" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"Energy.Active.Import.Register" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"Energy.Reactive.Export.Register" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"Energy.Reactive.Import.Register" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"Energy.Active.Export.Interval" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"Energy.Active.Import.Interval" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"Energy.Reactive.Export.Interval" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"Energy.Reactive.Import.Interval" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"Power.Active.Export" => _serde::__private::Ok(__Field::__field8),
                                b"Power.Active.Import" => _serde::__private::Ok(__Field::__field9),
                                b"Power.Offered" => _serde::__private::Ok(__Field::__field10),
                                b"Power.Reactive.Export" => {
                                    _serde::__private::Ok(__Field::__field11)
                                }
                                b"Power.Reactive.Import" => {
                                    _serde::__private::Ok(__Field::__field12)
                                }
                                b"Power.Factor" => _serde::__private::Ok(__Field::__field13),
                                b"Current.Import" => _serde::__private::Ok(__Field::__field14),
                                b"Current.Export" => _serde::__private::Ok(__Field::__field15),
                                b"Current.Offered" => _serde::__private::Ok(__Field::__field16),
                                b"Voltage" => _serde::__private::Ok(__Field::__field17),
                                b"Frequency" => _serde::__private::Ok(__Field::__field18),
                                b"Temperature" => _serde::__private::Ok(__Field::__field19),
                                b"SoC" => _serde::__private::Ok(__Field::__field20),
                                b"RPM" => _serde::__private::Ok(__Field::__field21),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledMeasurand>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledMeasurand;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SampledMeasurand",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyActiveExportRegister,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyActiveImportRegister,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyReactiveExportRegister,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyReactiveImportRegister,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyActiveExportInterval,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyActiveImportInterval,
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyReactiveExportInterval,
                                    )
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        SampledMeasurand::EnergyReactiveImportInterval,
                                    )
                                }
                                (__Field::__field8, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::PowerActiveExport)
                                }
                                (__Field::__field9, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::PowerActiveImport)
                                }
                                (__Field::__field10, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::PowerOffered)
                                }
                                (__Field::__field11, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::PowerReactiveExport)
                                }
                                (__Field::__field12, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::PowerReactiveImport)
                                }
                                (__Field::__field13, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::PowerFactor)
                                }
                                (__Field::__field14, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::CurrentImport)
                                }
                                (__Field::__field15, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::CurrentExport)
                                }
                                (__Field::__field16, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::CurrentOffered)
                                }
                                (__Field::__field17, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::Voltage)
                                }
                                (__Field::__field18, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::Frequency)
                                }
                                (__Field::__field19, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::Temperature)
                                }
                                (__Field::__field20, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::SoC)
                                }
                                (__Field::__field21, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledMeasurand::RPM)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Energy.Active.Export.Register",
                        "Energy.Active.Import.Register",
                        "Energy.Reactive.Export.Register",
                        "Energy.Reactive.Import.Register",
                        "Energy.Active.Export.Interval",
                        "Energy.Active.Import.Interval",
                        "Energy.Reactive.Export.Interval",
                        "Energy.Reactive.Import.Interval",
                        "Power.Active.Export",
                        "Power.Active.Import",
                        "Power.Offered",
                        "Power.Reactive.Export",
                        "Power.Reactive.Import",
                        "Power.Factor",
                        "Current.Import",
                        "Current.Export",
                        "Current.Offered",
                        "Voltage",
                        "Frequency",
                        "Temperature",
                        "SoC",
                        "RPM",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SampledMeasurand",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledMeasurand>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SampledMeasurand {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SampledMeasurand::EnergyActiveExportRegister,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyActiveExportRegister")
                    }
                    (&SampledMeasurand::EnergyActiveImportRegister,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyActiveImportRegister")
                    }
                    (&SampledMeasurand::EnergyReactiveExportRegister,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyReactiveExportRegister")
                    }
                    (&SampledMeasurand::EnergyReactiveImportRegister,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyReactiveImportRegister")
                    }
                    (&SampledMeasurand::EnergyActiveExportInterval,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyActiveExportInterval")
                    }
                    (&SampledMeasurand::EnergyActiveImportInterval,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyActiveImportInterval")
                    }
                    (&SampledMeasurand::EnergyReactiveExportInterval,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyReactiveExportInterval")
                    }
                    (&SampledMeasurand::EnergyReactiveImportInterval,) => {
                        ::core::fmt::Formatter::write_str(f, "EnergyReactiveImportInterval")
                    }
                    (&SampledMeasurand::PowerActiveExport,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerActiveExport")
                    }
                    (&SampledMeasurand::PowerActiveImport,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerActiveImport")
                    }
                    (&SampledMeasurand::PowerOffered,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerOffered")
                    }
                    (&SampledMeasurand::PowerReactiveExport,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerReactiveExport")
                    }
                    (&SampledMeasurand::PowerReactiveImport,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerReactiveImport")
                    }
                    (&SampledMeasurand::PowerFactor,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerFactor")
                    }
                    (&SampledMeasurand::CurrentImport,) => {
                        ::core::fmt::Formatter::write_str(f, "CurrentImport")
                    }
                    (&SampledMeasurand::CurrentExport,) => {
                        ::core::fmt::Formatter::write_str(f, "CurrentExport")
                    }
                    (&SampledMeasurand::CurrentOffered,) => {
                        ::core::fmt::Formatter::write_str(f, "CurrentOffered")
                    }
                    (&SampledMeasurand::Voltage,) => {
                        ::core::fmt::Formatter::write_str(f, "Voltage")
                    }
                    (&SampledMeasurand::Frequency,) => {
                        ::core::fmt::Formatter::write_str(f, "Frequency")
                    }
                    (&SampledMeasurand::Temperature,) => {
                        ::core::fmt::Formatter::write_str(f, "Temperature")
                    }
                    (&SampledMeasurand::SoC,) => ::core::fmt::Formatter::write_str(f, "SoC"),
                    (&SampledMeasurand::RPM,) => ::core::fmt::Formatter::write_str(f, "RPM"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SampledMeasurand {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SampledMeasurand {
            #[inline]
            fn eq(&self, other: &SampledMeasurand) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for SampledMeasurand {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SampledMeasurand {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SampledMeasurand {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SampledMeasurand::EnergyActiveExportRegister => {
                        f.pad("EnergyActiveExportRegister")
                    }
                    SampledMeasurand::EnergyActiveImportRegister => {
                        f.pad("EnergyActiveImportRegister")
                    }
                    SampledMeasurand::EnergyReactiveExportRegister => {
                        f.pad("EnergyReactiveExportRegister")
                    }
                    SampledMeasurand::EnergyReactiveImportRegister => {
                        f.pad("EnergyReactiveImportRegister")
                    }
                    SampledMeasurand::EnergyActiveExportInterval => {
                        f.pad("EnergyActiveExportInterval")
                    }
                    SampledMeasurand::EnergyActiveImportInterval => {
                        f.pad("EnergyActiveImportInterval")
                    }
                    SampledMeasurand::EnergyReactiveExportInterval => {
                        f.pad("EnergyReactiveExportInterval")
                    }
                    SampledMeasurand::EnergyReactiveImportInterval => {
                        f.pad("EnergyReactiveImportInterval")
                    }
                    SampledMeasurand::PowerActiveExport => f.pad("PowerActiveExport"),
                    SampledMeasurand::PowerActiveImport => f.pad("PowerActiveImport"),
                    SampledMeasurand::PowerOffered => f.pad("PowerOffered"),
                    SampledMeasurand::PowerReactiveExport => f.pad("PowerReactiveExport"),
                    SampledMeasurand::PowerReactiveImport => f.pad("PowerReactiveImport"),
                    SampledMeasurand::PowerFactor => f.pad("PowerFactor"),
                    SampledMeasurand::CurrentImport => f.pad("CurrentImport"),
                    SampledMeasurand::CurrentExport => f.pad("CurrentExport"),
                    SampledMeasurand::CurrentOffered => f.pad("CurrentOffered"),
                    SampledMeasurand::Voltage => f.pad("Voltage"),
                    SampledMeasurand::Frequency => f.pad("Frequency"),
                    SampledMeasurand::Temperature => f.pad("Temperature"),
                    SampledMeasurand::SoC => f.pad("SoC"),
                    SampledMeasurand::RPM => f.pad("RPM"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SampledMeasurand {
            #[inline]
            fn clone(&self) -> SampledMeasurand {
                match (&*self,) {
                    (&SampledMeasurand::EnergyActiveExportRegister,) => {
                        SampledMeasurand::EnergyActiveExportRegister
                    }
                    (&SampledMeasurand::EnergyActiveImportRegister,) => {
                        SampledMeasurand::EnergyActiveImportRegister
                    }
                    (&SampledMeasurand::EnergyReactiveExportRegister,) => {
                        SampledMeasurand::EnergyReactiveExportRegister
                    }
                    (&SampledMeasurand::EnergyReactiveImportRegister,) => {
                        SampledMeasurand::EnergyReactiveImportRegister
                    }
                    (&SampledMeasurand::EnergyActiveExportInterval,) => {
                        SampledMeasurand::EnergyActiveExportInterval
                    }
                    (&SampledMeasurand::EnergyActiveImportInterval,) => {
                        SampledMeasurand::EnergyActiveImportInterval
                    }
                    (&SampledMeasurand::EnergyReactiveExportInterval,) => {
                        SampledMeasurand::EnergyReactiveExportInterval
                    }
                    (&SampledMeasurand::EnergyReactiveImportInterval,) => {
                        SampledMeasurand::EnergyReactiveImportInterval
                    }
                    (&SampledMeasurand::PowerActiveExport,) => SampledMeasurand::PowerActiveExport,
                    (&SampledMeasurand::PowerActiveImport,) => SampledMeasurand::PowerActiveImport,
                    (&SampledMeasurand::PowerOffered,) => SampledMeasurand::PowerOffered,
                    (&SampledMeasurand::PowerReactiveExport,) => {
                        SampledMeasurand::PowerReactiveExport
                    }
                    (&SampledMeasurand::PowerReactiveImport,) => {
                        SampledMeasurand::PowerReactiveImport
                    }
                    (&SampledMeasurand::PowerFactor,) => SampledMeasurand::PowerFactor,
                    (&SampledMeasurand::CurrentImport,) => SampledMeasurand::CurrentImport,
                    (&SampledMeasurand::CurrentExport,) => SampledMeasurand::CurrentExport,
                    (&SampledMeasurand::CurrentOffered,) => SampledMeasurand::CurrentOffered,
                    (&SampledMeasurand::Voltage,) => SampledMeasurand::Voltage,
                    (&SampledMeasurand::Frequency,) => SampledMeasurand::Frequency,
                    (&SampledMeasurand::Temperature,) => SampledMeasurand::Temperature,
                    (&SampledMeasurand::SoC,) => SampledMeasurand::SoC,
                    (&SampledMeasurand::RPM,) => SampledMeasurand::RPM,
                }
            }
        }
        ///An iterator over the variants of [Self]
        pub struct SampledMeasurandIter {
            idx: usize,
            back_idx: usize,
            marker: ::core::marker::PhantomData<()>,
        }
        impl SampledMeasurandIter {
            fn get(&self, idx: usize) -> Option<SampledMeasurand> {
                match idx {
                    0usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyActiveExportRegister)
                    }
                    1usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyActiveImportRegister)
                    }
                    2usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyReactiveExportRegister)
                    }
                    3usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyReactiveImportRegister)
                    }
                    4usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyActiveExportInterval)
                    }
                    5usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyActiveImportInterval)
                    }
                    6usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyReactiveExportInterval)
                    }
                    7usize => {
                        ::core::option::Option::Some(SampledMeasurand::EnergyReactiveImportInterval)
                    }
                    8usize => ::core::option::Option::Some(SampledMeasurand::PowerActiveExport),
                    9usize => ::core::option::Option::Some(SampledMeasurand::PowerActiveImport),
                    10usize => ::core::option::Option::Some(SampledMeasurand::PowerOffered),
                    11usize => ::core::option::Option::Some(SampledMeasurand::PowerReactiveExport),
                    12usize => ::core::option::Option::Some(SampledMeasurand::PowerReactiveImport),
                    13usize => ::core::option::Option::Some(SampledMeasurand::PowerFactor),
                    14usize => ::core::option::Option::Some(SampledMeasurand::CurrentImport),
                    15usize => ::core::option::Option::Some(SampledMeasurand::CurrentExport),
                    16usize => ::core::option::Option::Some(SampledMeasurand::CurrentOffered),
                    17usize => ::core::option::Option::Some(SampledMeasurand::Voltage),
                    18usize => ::core::option::Option::Some(SampledMeasurand::Frequency),
                    19usize => ::core::option::Option::Some(SampledMeasurand::Temperature),
                    20usize => ::core::option::Option::Some(SampledMeasurand::SoC),
                    21usize => ::core::option::Option::Some(SampledMeasurand::RPM),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::strum::IntoEnumIterator for SampledMeasurand {
            type Iterator = SampledMeasurandIter;
            fn iter() -> SampledMeasurandIter {
                SampledMeasurandIter {
                    idx: 0,
                    back_idx: 0,
                    marker: ::core::marker::PhantomData,
                }
            }
        }
        impl Iterator for SampledMeasurandIter {
            type Item = SampledMeasurand;
            fn next(&mut self) -> Option<<Self as Iterator>::Item> {
                self.nth(0)
            }
            fn size_hint(&self) -> (usize, Option<usize>) {
                let t = if self.idx + self.back_idx >= 22usize {
                    0
                } else {
                    22usize - self.idx - self.back_idx
                };
                (t, Some(t))
            }
            fn nth(&mut self, n: usize) -> Option<<Self as Iterator>::Item> {
                let idx = self.idx + n + 1;
                if idx + self.back_idx > 22usize {
                    self.idx = 22usize;
                    ::core::option::Option::None
                } else {
                    self.idx = idx;
                    self.get(idx - 1)
                }
            }
        }
        impl ExactSizeIterator for SampledMeasurandIter {
            fn len(&self) -> usize {
                self.size_hint().0
            }
        }
        impl DoubleEndedIterator for SampledMeasurandIter {
            fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {
                let back_idx = self.back_idx + 1;
                if self.idx + back_idx > 22usize {
                    self.back_idx = 22usize;
                    ::core::option::Option::None
                } else {
                    self.back_idx = back_idx;
                    self.get(22usize - self.back_idx)
                }
            }
        }
        impl Clone for SampledMeasurandIter {
            fn clone(&self) -> SampledMeasurandIter {
                SampledMeasurandIter {
                    idx: self.idx,
                    back_idx: self.back_idx,
                    marker: self.marker.clone(),
                }
            }
        }
        /// Phase as used in SampledValue. Phase specifies how a measured value is to be interpreted. Please note that not all values of Phase are applicable to all Measurands.
        pub enum SampledPhase {
            /// Measured on L1
            L1,
            /// Measured on L2
            L2,
            /// Measured on L3
            L3,
            /// Measured on Neutral
            N,
            /// Measured on L1 with respect to Neutral conductor
            #[serde(rename = "L1-N")]
            L1N,
            /// Measured on L2 with respect to Neutral conductor
            #[serde(rename = "L2-N")]
            L2N,
            /// Measured on L3 with respect to Neutral conductor
            #[serde(rename = "L3-N")]
            L3N,
            /// Measured between L1 and L2
            #[serde(rename = "L1-L2")]
            L1L2,
            /// Measured between L2 and L3
            #[serde(rename = "L2-L3")]
            L2L3,
            /// Measured between L3 and L1
            #[serde(rename = "L3-L1")]
            L3L1,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledPhase {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SampledPhase::L1 => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            0u32,
                            "L1",
                        ),
                        SampledPhase::L2 => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            1u32,
                            "L2",
                        ),
                        SampledPhase::L3 => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            2u32,
                            "L3",
                        ),
                        SampledPhase::N => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            3u32,
                            "N",
                        ),
                        SampledPhase::L1N => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            4u32,
                            "L1-N",
                        ),
                        SampledPhase::L2N => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            5u32,
                            "L2-N",
                        ),
                        SampledPhase::L3N => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            6u32,
                            "L3-N",
                        ),
                        SampledPhase::L1L2 => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            7u32,
                            "L1-L2",
                        ),
                        SampledPhase::L2L3 => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            8u32,
                            "L2-L3",
                        ),
                        SampledPhase::L3L1 => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledPhase",
                            9u32,
                            "L3-L1",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledPhase {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 10",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "L1" => _serde::__private::Ok(__Field::__field0),
                                "L2" => _serde::__private::Ok(__Field::__field1),
                                "L3" => _serde::__private::Ok(__Field::__field2),
                                "N" => _serde::__private::Ok(__Field::__field3),
                                "L1-N" => _serde::__private::Ok(__Field::__field4),
                                "L2-N" => _serde::__private::Ok(__Field::__field5),
                                "L3-N" => _serde::__private::Ok(__Field::__field6),
                                "L1-L2" => _serde::__private::Ok(__Field::__field7),
                                "L2-L3" => _serde::__private::Ok(__Field::__field8),
                                "L3-L1" => _serde::__private::Ok(__Field::__field9),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"L1" => _serde::__private::Ok(__Field::__field0),
                                b"L2" => _serde::__private::Ok(__Field::__field1),
                                b"L3" => _serde::__private::Ok(__Field::__field2),
                                b"N" => _serde::__private::Ok(__Field::__field3),
                                b"L1-N" => _serde::__private::Ok(__Field::__field4),
                                b"L2-N" => _serde::__private::Ok(__Field::__field5),
                                b"L3-N" => _serde::__private::Ok(__Field::__field6),
                                b"L1-L2" => _serde::__private::Ok(__Field::__field7),
                                b"L2-L3" => _serde::__private::Ok(__Field::__field8),
                                b"L3-L1" => _serde::__private::Ok(__Field::__field9),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledPhase>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledPhase;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SampledPhase",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L1)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L2)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L3)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::N)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L1N)
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L2N)
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L3N)
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L1L2)
                                }
                                (__Field::__field8, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L2L3)
                                }
                                (__Field::__field9, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledPhase::L3L1)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "L1", "L2", "L3", "N", "L1-N", "L2-N", "L3-N", "L1-L2", "L2-L3", "L3-L1",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SampledPhase",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledPhase>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SampledPhase {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SampledPhase::L1,) => ::core::fmt::Formatter::write_str(f, "L1"),
                    (&SampledPhase::L2,) => ::core::fmt::Formatter::write_str(f, "L2"),
                    (&SampledPhase::L3,) => ::core::fmt::Formatter::write_str(f, "L3"),
                    (&SampledPhase::N,) => ::core::fmt::Formatter::write_str(f, "N"),
                    (&SampledPhase::L1N,) => ::core::fmt::Formatter::write_str(f, "L1N"),
                    (&SampledPhase::L2N,) => ::core::fmt::Formatter::write_str(f, "L2N"),
                    (&SampledPhase::L3N,) => ::core::fmt::Formatter::write_str(f, "L3N"),
                    (&SampledPhase::L1L2,) => ::core::fmt::Formatter::write_str(f, "L1L2"),
                    (&SampledPhase::L2L3,) => ::core::fmt::Formatter::write_str(f, "L2L3"),
                    (&SampledPhase::L3L1,) => ::core::fmt::Formatter::write_str(f, "L3L1"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SampledPhase {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SampledPhase {
            #[inline]
            fn eq(&self, other: &SampledPhase) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for SampledPhase {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SampledPhase {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SampledPhase {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SampledPhase::L1 => f.pad("L1"),
                    SampledPhase::L2 => f.pad("L2"),
                    SampledPhase::L3 => f.pad("L3"),
                    SampledPhase::N => f.pad("N"),
                    SampledPhase::L1N => f.pad("L1N"),
                    SampledPhase::L2N => f.pad("L2N"),
                    SampledPhase::L3N => f.pad("L3N"),
                    SampledPhase::L1L2 => f.pad("L1L2"),
                    SampledPhase::L2L3 => f.pad("L2L3"),
                    SampledPhase::L3L1 => f.pad("L3L1"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SampledPhase {
            #[inline]
            fn clone(&self) -> SampledPhase {
                match (&*self,) {
                    (&SampledPhase::L1,) => SampledPhase::L1,
                    (&SampledPhase::L2,) => SampledPhase::L2,
                    (&SampledPhase::L3,) => SampledPhase::L3,
                    (&SampledPhase::N,) => SampledPhase::N,
                    (&SampledPhase::L1N,) => SampledPhase::L1N,
                    (&SampledPhase::L2N,) => SampledPhase::L2N,
                    (&SampledPhase::L3N,) => SampledPhase::L3N,
                    (&SampledPhase::L1L2,) => SampledPhase::L1L2,
                    (&SampledPhase::L2L3,) => SampledPhase::L2L3,
                    (&SampledPhase::L3L1,) => SampledPhase::L3L1,
                }
            }
        }
        /// Allowable values of the optional "location" field of a value element in SampledValue.
        pub enum SampledLocation {
            /// Measurement inside body of Charge Point (e.g. Temperature)
            Body,
            ///Measurement taken from cable between EV and Charge Point
            Cable,
            ///Measurement taken by EV
            EV,
            ///Measurement at network (grid) inlet connection
            Inlet,
            ///Measurement at a Connector. Default value
            Outlet,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledLocation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SampledLocation::Body => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledLocation",
                            0u32,
                            "Body",
                        ),
                        SampledLocation::Cable => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledLocation",
                            1u32,
                            "Cable",
                        ),
                        SampledLocation::EV => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledLocation",
                            2u32,
                            "EV",
                        ),
                        SampledLocation::Inlet => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledLocation",
                            3u32,
                            "Inlet",
                        ),
                        SampledLocation::Outlet => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledLocation",
                            4u32,
                            "Outlet",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledLocation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 5",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Body" => _serde::__private::Ok(__Field::__field0),
                                "Cable" => _serde::__private::Ok(__Field::__field1),
                                "EV" => _serde::__private::Ok(__Field::__field2),
                                "Inlet" => _serde::__private::Ok(__Field::__field3),
                                "Outlet" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Body" => _serde::__private::Ok(__Field::__field0),
                                b"Cable" => _serde::__private::Ok(__Field::__field1),
                                b"EV" => _serde::__private::Ok(__Field::__field2),
                                b"Inlet" => _serde::__private::Ok(__Field::__field3),
                                b"Outlet" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledLocation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledLocation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum SampledLocation",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledLocation::Body)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledLocation::Cable)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledLocation::EV)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledLocation::Inlet)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledLocation::Outlet)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Body", "Cable", "EV", "Inlet", "Outlet"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SampledLocation",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledLocation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SampledLocation {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SampledLocation::Body,) => ::core::fmt::Formatter::write_str(f, "Body"),
                    (&SampledLocation::Cable,) => ::core::fmt::Formatter::write_str(f, "Cable"),
                    (&SampledLocation::EV,) => ::core::fmt::Formatter::write_str(f, "EV"),
                    (&SampledLocation::Inlet,) => ::core::fmt::Formatter::write_str(f, "Inlet"),
                    (&SampledLocation::Outlet,) => ::core::fmt::Formatter::write_str(f, "Outlet"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SampledLocation {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SampledLocation {
            #[inline]
            fn eq(&self, other: &SampledLocation) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for SampledLocation {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SampledLocation {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SampledLocation {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SampledLocation::Body => f.pad("Body"),
                    SampledLocation::Cable => f.pad("Cable"),
                    SampledLocation::EV => f.pad("EV"),
                    SampledLocation::Inlet => f.pad("Inlet"),
                    SampledLocation::Outlet => f.pad("Outlet"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SampledLocation {
            #[inline]
            fn clone(&self) -> SampledLocation {
                match (&*self,) {
                    (&SampledLocation::Body,) => SampledLocation::Body,
                    (&SampledLocation::Cable,) => SampledLocation::Cable,
                    (&SampledLocation::EV,) => SampledLocation::EV,
                    (&SampledLocation::Inlet,) => SampledLocation::Inlet,
                    (&SampledLocation::Outlet,) => SampledLocation::Outlet,
                }
            }
        }
        /// Allowable values of the optional "unit" field of a Value element, as used in SampledValue. Default value of "unit" is always "Wh".
        #[warn(non_camel_case_types)]
        pub enum SampledUnit {
            /// Watt-hours (energy). Default.
            Wh,
            /// kiloWatt-hours (energy).
            #[serde(rename = "kWh")]
            KWh,
            /// Var-hours (reactive energy).
            #[serde(rename = "varh")]
            Varh,
            /// kilovar-hours (reactive energy).
            #[serde(rename = "kvarh")]
            Kvarh,
            /// Watts (power).
            W,
            /// kilowatts (power).
            #[serde(rename = "kW")]
            Kw,
            /// VoltAmpere (apparent power).
            #[serde(rename = "VA")]
            Va,
            /// kiloVolt Ampere (apparent power).
            #[serde(rename = "kVA")]
            Kva,
            /// Vars (reactive power).
            #[serde(rename = "var")]
            Var,
            /// kilovars (reactive power).
            #[serde(rename = "kvar")]
            Kvar,
            /// Amperes (current).
            A,
            /// Voltage (r.m.s. AC).
            V,
            /// Degrees (temperature).
            Celsius,
            /// Degrees (temperature).
            Fahrenheit,
            /// Degrees Kelvin (temperature).
            K,
            /// Percentage.
            Percent,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SampledUnit {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        SampledUnit::Wh => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            0u32,
                            "Wh",
                        ),
                        SampledUnit::KWh => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            1u32,
                            "kWh",
                        ),
                        SampledUnit::Varh => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            2u32,
                            "varh",
                        ),
                        SampledUnit::Kvarh => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            3u32,
                            "kvarh",
                        ),
                        SampledUnit::W => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            4u32,
                            "W",
                        ),
                        SampledUnit::Kw => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            5u32,
                            "kW",
                        ),
                        SampledUnit::Va => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            6u32,
                            "VA",
                        ),
                        SampledUnit::Kva => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            7u32,
                            "kVA",
                        ),
                        SampledUnit::Var => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            8u32,
                            "var",
                        ),
                        SampledUnit::Kvar => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            9u32,
                            "kvar",
                        ),
                        SampledUnit::A => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            10u32,
                            "A",
                        ),
                        SampledUnit::V => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            11u32,
                            "V",
                        ),
                        SampledUnit::Celsius => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            12u32,
                            "Celsius",
                        ),
                        SampledUnit::Fahrenheit => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            13u32,
                            "Fahrenheit",
                        ),
                        SampledUnit::K => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            14u32,
                            "K",
                        ),
                        SampledUnit::Percent => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SampledUnit",
                            15u32,
                            "Percent",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SampledUnit {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                        __field15,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                14u64 => _serde::__private::Ok(__Field::__field14),
                                15u64 => _serde::__private::Ok(__Field::__field15),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 16",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Wh" => _serde::__private::Ok(__Field::__field0),
                                "kWh" => _serde::__private::Ok(__Field::__field1),
                                "varh" => _serde::__private::Ok(__Field::__field2),
                                "kvarh" => _serde::__private::Ok(__Field::__field3),
                                "W" => _serde::__private::Ok(__Field::__field4),
                                "kW" => _serde::__private::Ok(__Field::__field5),
                                "VA" => _serde::__private::Ok(__Field::__field6),
                                "kVA" => _serde::__private::Ok(__Field::__field7),
                                "var" => _serde::__private::Ok(__Field::__field8),
                                "kvar" => _serde::__private::Ok(__Field::__field9),
                                "A" => _serde::__private::Ok(__Field::__field10),
                                "V" => _serde::__private::Ok(__Field::__field11),
                                "Celsius" => _serde::__private::Ok(__Field::__field12),
                                "Fahrenheit" => _serde::__private::Ok(__Field::__field13),
                                "K" => _serde::__private::Ok(__Field::__field14),
                                "Percent" => _serde::__private::Ok(__Field::__field15),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Wh" => _serde::__private::Ok(__Field::__field0),
                                b"kWh" => _serde::__private::Ok(__Field::__field1),
                                b"varh" => _serde::__private::Ok(__Field::__field2),
                                b"kvarh" => _serde::__private::Ok(__Field::__field3),
                                b"W" => _serde::__private::Ok(__Field::__field4),
                                b"kW" => _serde::__private::Ok(__Field::__field5),
                                b"VA" => _serde::__private::Ok(__Field::__field6),
                                b"kVA" => _serde::__private::Ok(__Field::__field7),
                                b"var" => _serde::__private::Ok(__Field::__field8),
                                b"kvar" => _serde::__private::Ok(__Field::__field9),
                                b"A" => _serde::__private::Ok(__Field::__field10),
                                b"V" => _serde::__private::Ok(__Field::__field11),
                                b"Celsius" => _serde::__private::Ok(__Field::__field12),
                                b"Fahrenheit" => _serde::__private::Ok(__Field::__field13),
                                b"K" => _serde::__private::Ok(__Field::__field14),
                                b"Percent" => _serde::__private::Ok(__Field::__field15),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SampledUnit>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SampledUnit;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum SampledUnit")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Wh)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::KWh)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Varh)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Kvarh)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::W)
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Kw)
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Va)
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Kva)
                                }
                                (__Field::__field8, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Var)
                                }
                                (__Field::__field9, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Kvar)
                                }
                                (__Field::__field10, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::A)
                                }
                                (__Field::__field11, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::V)
                                }
                                (__Field::__field12, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Celsius)
                                }
                                (__Field::__field13, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Fahrenheit)
                                }
                                (__Field::__field14, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::K)
                                }
                                (__Field::__field15, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(SampledUnit::Percent)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Wh",
                        "kWh",
                        "varh",
                        "kvarh",
                        "W",
                        "kW",
                        "VA",
                        "kVA",
                        "var",
                        "kvar",
                        "A",
                        "V",
                        "Celsius",
                        "Fahrenheit",
                        "K",
                        "Percent",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "SampledUnit",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SampledUnit>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[warn(non_camel_case_types)]
        impl ::core::fmt::Debug for SampledUnit {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&SampledUnit::Wh,) => ::core::fmt::Formatter::write_str(f, "Wh"),
                    (&SampledUnit::KWh,) => ::core::fmt::Formatter::write_str(f, "KWh"),
                    (&SampledUnit::Varh,) => ::core::fmt::Formatter::write_str(f, "Varh"),
                    (&SampledUnit::Kvarh,) => ::core::fmt::Formatter::write_str(f, "Kvarh"),
                    (&SampledUnit::W,) => ::core::fmt::Formatter::write_str(f, "W"),
                    (&SampledUnit::Kw,) => ::core::fmt::Formatter::write_str(f, "Kw"),
                    (&SampledUnit::Va,) => ::core::fmt::Formatter::write_str(f, "Va"),
                    (&SampledUnit::Kva,) => ::core::fmt::Formatter::write_str(f, "Kva"),
                    (&SampledUnit::Var,) => ::core::fmt::Formatter::write_str(f, "Var"),
                    (&SampledUnit::Kvar,) => ::core::fmt::Formatter::write_str(f, "Kvar"),
                    (&SampledUnit::A,) => ::core::fmt::Formatter::write_str(f, "A"),
                    (&SampledUnit::V,) => ::core::fmt::Formatter::write_str(f, "V"),
                    (&SampledUnit::Celsius,) => ::core::fmt::Formatter::write_str(f, "Celsius"),
                    (&SampledUnit::Fahrenheit,) => {
                        ::core::fmt::Formatter::write_str(f, "Fahrenheit")
                    }
                    (&SampledUnit::K,) => ::core::fmt::Formatter::write_str(f, "K"),
                    (&SampledUnit::Percent,) => ::core::fmt::Formatter::write_str(f, "Percent"),
                }
            }
        }
        #[warn(non_camel_case_types)]
        impl ::core::marker::StructuralPartialEq for SampledUnit {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[warn(non_camel_case_types)]
        impl ::core::cmp::PartialEq for SampledUnit {
            #[inline]
            fn eq(&self, other: &SampledUnit) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[warn(non_camel_case_types)]
        impl ::core::marker::StructuralEq for SampledUnit {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[warn(non_camel_case_types)]
        impl ::core::cmp::Eq for SampledUnit {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for SampledUnit {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    SampledUnit::Wh => f.pad("Wh"),
                    SampledUnit::KWh => f.pad("KWh"),
                    SampledUnit::Varh => f.pad("Varh"),
                    SampledUnit::Kvarh => f.pad("Kvarh"),
                    SampledUnit::W => f.pad("W"),
                    SampledUnit::Kw => f.pad("Kw"),
                    SampledUnit::Va => f.pad("Va"),
                    SampledUnit::Kva => f.pad("Kva"),
                    SampledUnit::Var => f.pad("Var"),
                    SampledUnit::Kvar => f.pad("Kvar"),
                    SampledUnit::A => f.pad("A"),
                    SampledUnit::V => f.pad("V"),
                    SampledUnit::Celsius => f.pad("Celsius"),
                    SampledUnit::Fahrenheit => f.pad("Fahrenheit"),
                    SampledUnit::K => f.pad("K"),
                    SampledUnit::Percent => f.pad("Percent"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[warn(non_camel_case_types)]
        impl ::core::clone::Clone for SampledUnit {
            #[inline]
            fn clone(&self) -> SampledUnit {
                match (&*self,) {
                    (&SampledUnit::Wh,) => SampledUnit::Wh,
                    (&SampledUnit::KWh,) => SampledUnit::KWh,
                    (&SampledUnit::Varh,) => SampledUnit::Varh,
                    (&SampledUnit::Kvarh,) => SampledUnit::Kvarh,
                    (&SampledUnit::W,) => SampledUnit::W,
                    (&SampledUnit::Kw,) => SampledUnit::Kw,
                    (&SampledUnit::Va,) => SampledUnit::Va,
                    (&SampledUnit::Kva,) => SampledUnit::Kva,
                    (&SampledUnit::Var,) => SampledUnit::Var,
                    (&SampledUnit::Kvar,) => SampledUnit::Kvar,
                    (&SampledUnit::A,) => SampledUnit::A,
                    (&SampledUnit::V,) => SampledUnit::V,
                    (&SampledUnit::Celsius,) => SampledUnit::Celsius,
                    (&SampledUnit::Fahrenheit,) => SampledUnit::Fahrenheit,
                    (&SampledUnit::K,) => SampledUnit::K,
                    (&SampledUnit::Percent,) => SampledUnit::Percent,
                }
            }
        }
    }
    pub use charging_profile::*;
    pub use common_types::*;
    pub use data_transfer::*;
    pub use meter_value::*;
}
pub mod error {
    //! Error handling
    use derive_builder::UninitializedFieldError;
    use thiserror::Error;
    use validator::ValidationErrors;
    /// Errors related to building an OCPP object
    pub enum OcppError {
        #[error("Field missing from builder")]
        /// Error resultant from a missing field when building an OCPP object
        BuilderError(#[from] UninitializedFieldError),
        #[error("Struct is invalid")]
        /// Error resultant from bad field when building an OCPP object
        OcppValidationError(#[from] ValidationErrors),
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for OcppError {
        fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
            use thiserror::private::AsDynError;
            #[allow(deprecated)]
            match self {
                OcppError::BuilderError { 0: source, .. } => {
                    std::option::Option::Some(source.as_dyn_error())
                }
                OcppError::OcppValidationError { 0: source, .. } => {
                    std::option::Option::Some(source.as_dyn_error())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::fmt::Display for OcppError {
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                OcppError::BuilderError(_0) => {
                    let result = __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Field missing from builder"],
                        &[],
                    ));
                    result
                }
                OcppError::OcppValidationError(_0) => {
                    let result = __formatter
                        .write_fmt(::core::fmt::Arguments::new_v1(&["Struct is invalid"], &[]));
                    result
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::convert::From<UninitializedFieldError> for OcppError {
        #[allow(deprecated)]
        fn from(source: UninitializedFieldError) -> Self {
            OcppError::BuilderError { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl std::convert::From<ValidationErrors> for OcppError {
        #[allow(deprecated)]
        fn from(source: ValidationErrors) -> Self {
            OcppError::OcppValidationError { 0: source }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for OcppError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&OcppError::BuilderError(ref __self_0),) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BuilderError",
                        &&*__self_0,
                    )
                }
                (&OcppError::OcppValidationError(ref __self_0),) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OcppValidationError",
                        &&*__self_0,
                    )
                }
            }
        }
    }
}
pub mod point_init {
    //! A collection of messages initiated by the charge point
    pub mod authorize {
        //! Authorization message sent before transaction start/end. *Not required in free vend mode*
        //!
        //! # Behaviour
        //! Before the owner of an electric vehicle can start or stop charging, the Charge Point has to authorize the
        //! operation. The Charge Point SHALL only supply energy after authorization. When stopping a Transaction, the
        //! Charge Point SHALL only send an Authorize.req when the identifier used for stopping the transaction is different
        //! from the identifier that started the transaction.
        //!
        //! Authorize.req SHOULD only be used for the authorization of an identifier for charging.
        //! A Charge Point MAY authorize identifier locally without involving the Central System, as described in Local
        //! Authorization List. If an idTag presented by the user is not present in the Local Authorization List or
        //! Authorization Cache, then the Charge Point SHALL send an Authorize.req PDU to the Central System to request
        //! authorization. If the idTag is present in the Local Authorization List or Authorization Cache, then the Charge Point
        //! MAY send an Authorize.req PDU to the Central System.
        //!
        //! If Charge Point has implemented an Authorization Cache, then upon receipt of an Authorize.conf PDU the
        //! Charge Point SHALL update the cache entry, if the idTag is not in the Local Authorization List, with the IdTagInfo
        //!
        //!  # Response
        //! Upon receipt of an Authorize.req PDU, the Central System SHALL respond with an Authorize.conf PDU. This
        //! response PDU SHALL indicate whether or not the idTag is accepted by the Central System. If the Central System
        //! accepts the idTag then the response PDU MAY include a parentIdTag and MUST include an authorization status
        //! value indicating acceptance or a reason for rejection.
        //!
        use crate::common::common_types::IdTagInfo;
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const AUTHORIZEREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:AuthorizeRequest\",\r\n    \"title\": \"AuthorizeRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"idTag\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"idTag\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct AUTHORIZEREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static AUTHORIZEREQUEST_JSON: AUTHORIZEREQUEST_JSON = AUTHORIZEREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for AUTHORIZEREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(AUTHORIZEREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/Authorize.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for AUTHORIZEREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct AUTHORIZEREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static AUTHORIZEREQUEST_VALIDATOR: AUTHORIZEREQUEST_VALIDATOR =
            AUTHORIZEREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for AUTHORIZEREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&AUTHORIZEREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/Authorize.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for AUTHORIZEREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for AuthorizeRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = AUTHORIZEREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/authorize.rs:32",
                                    "ocpp::point_init::authorize",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/authorize.rs"),
                                    Some(32u32),
                                    Some("ocpp::point_init::authorize"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/authorize.rs:32",
                                    "ocpp::point_init::authorize",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/authorize.rs"),
                                    Some(32u32),
                                    Some("ocpp::point_init::authorize"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the Authorize.req PDU sent by the Charge Point to the Central System.
        pub struct AuthorizeRequest {
            ///This contains the identifier that needs to be authorized.
            pub id_tag: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AuthorizeRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "AuthorizeRequest",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "idTag",
                        &self.id_tag,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AuthorizeRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "idTag" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"idTag" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AuthorizeRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AuthorizeRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct AuthorizeRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct AuthorizeRequest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(AuthorizeRequest { id_tag: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTag",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTag") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(AuthorizeRequest { id_tag: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["idTag"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "AuthorizeRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AuthorizeRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for AuthorizeRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "AuthorizeRequest",
                    "id_tag",
                    &&self.id_tag,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AuthorizeRequest {
            #[inline]
            fn clone(&self) -> AuthorizeRequest {
                AuthorizeRequest {
                    id_tag: ::core::clone::Clone::clone(&self.id_tag),
                }
            }
        }
        const AUTHORIZERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"AuthorizeResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"idTagInfo\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"expiryDate\": {\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"parentIdTag\": {\n                    \"type\": \"string\",\n                    \"maxLength\": 20\n                },\n                \"status\": {\n                    \"type\": \"string\",\n                    \"additionalProperties\": false,\n                    \"enum\": [\n                        \"Accepted\",\n                        \"Blocked\",\n                        \"Expired\",\n                        \"Invalid\",\n                        \"ConcurrentTx\"\n                    ]\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"status\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"idTagInfo\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct AUTHORIZERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static AUTHORIZERESPONSE_JSON: AUTHORIZERESPONSE_JSON = AUTHORIZERESPONSE_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for AUTHORIZERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(AUTHORIZERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/AuthorizeResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for AUTHORIZERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct AUTHORIZERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static AUTHORIZERESPONSE_VALIDATOR: AUTHORIZERESPONSE_VALIDATOR =
            AUTHORIZERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for AUTHORIZERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&AUTHORIZERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/AuthorizeResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for AUTHORIZERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for AuthorizeResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = AUTHORIZERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/authorize.rs:43",
                                    "ocpp::point_init::authorize",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/authorize.rs"),
                                    Some(43u32),
                                    Some("ocpp::point_init::authorize"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/authorize.rs:43",
                                    "ocpp::point_init::authorize",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/authorize.rs"),
                                    Some(43u32),
                                    Some("ocpp::point_init::authorize"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the Authorize.conf PDU sent by the Central System to the Charge Point in response to a Authorize.req PDU.
        pub struct AuthorizeResponse {
            ///This contains information about authorization status, expiry and parent id.
            pub id_tag_info: IdTagInfo,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AuthorizeResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "AuthorizeResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "idTagInfo",
                        &self.id_tag_info,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AuthorizeResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "idTagInfo" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"idTagInfo" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AuthorizeResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AuthorizeResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct AuthorizeResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                IdTagInfo,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct AuthorizeResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(AuthorizeResponse {
                                id_tag_info: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<IdTagInfo> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTagInfo",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<IdTagInfo>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTagInfo") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(AuthorizeResponse {
                                id_tag_info: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["idTagInfo"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "AuthorizeResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AuthorizeResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for AuthorizeResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "AuthorizeResponse",
                    "id_tag_info",
                    &&self.id_tag_info,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AuthorizeResponse {
            #[inline]
            fn clone(&self) -> AuthorizeResponse {
                AuthorizeResponse {
                    id_tag_info: ::core::clone::Clone::clone(&self.id_tag_info),
                }
            }
        }
    }
    pub mod boot_notification {
        //! Initialization message detailing general information about the charge point (e.g version, vendor etc.).
        //!
        //!  # Behaviour
        //! After start-up, a Charge Point SHALL send a request to the Central System with information about its
        //! configuration (e.g. version, vendor, etc.). The Central System SHALL respond to indicate whether it will accept the
        //! Charge Point.
        //! The Charge Point SHALL send a BootNotification.req PDU each time it boots or reboots. Between the physical
        //! power-on/reboot and the successful completion of a BootNotification, where Central System returns Accepted or
        //! Pending, the Charge Point SHALL NOT send any other request to the Central System. This includes cached
        //! messages that are still present in the Charge Point from before.
        //!
        //!  # Response
        //! When the Central System responds with a BootNotification.conf with a status Accepted, the Charge Point will
        //! adjust the heartbeat interval in accordance with the interval from the response PDU and it is RECOMMENDED to
        //! synchronize its internal clock with the supplied Central Systems current time. If the Central System returns
        //! something other than Accepted, the value of the interval field indicates the minimum wait time before sending a
        //! next BootNotification request. If that interval value is zero, the Charge Point chooses a waiting interval on its
        //! own, in a way that avoids flooding the Central System with requests. A Charge Point SHOULD NOT send a
        //! BootNotification.req earlier, unless requested to do so with a TriggerMessage.req.
        //!
        //! If the Central System returns the status Rejected, the Charge Point SHALL NOT send any OCPP message to the
        //! Central System until the aforementioned retry interval has expired. During this interval the Charge Point may no
        //! longer be reachable from the Central System. It MAY for instance close its communication channel or shut down
        //! its communication hardware. Also the Central System MAY close the communication channel, for instance to
        //! free up system resources. While Rejected, the Charge Point SHALL NOT respond to any Central System initiated
        //! message. the Central System SHOULD NOT initiate any.
        //!
        //! The Central System MAY also return a Pending registration status to indicate that it wants to retrieve or set
        //! certain information on the Charge Point before the Central System will accept the Charge Point. If the Central
        //! System returns the Pending status, the communication channel SHOULD NOT be closed by either the Charge
        //! Point or the Central System. The Central System MAY send request messages to retrieve information from the
        //! Charge Point or change its configuration. The Charge Point SHOULD respond to these messages. The Charge
        //! Point SHALL NOT send request messages to the Central System unless it has been instructed by the Central
        //! System to do so with a TriggerMessage.req request.
        //!
        //! While in pending state, the following Central System initiated messages are not allowed:
        //! RemoteStartTransaction.req and RemoteStopTransaction.req
        use crate::validation_macros::{self, *};
        use crate::{error::OcppError, generate_builders, UtcTime};
        use derive_builder::Builder;
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        use validator::Validate;
        #[cfg(test)]
        use test_strategy::Arbitrary;
        const BOOTNOTIFICATIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:BootNotificationRequest\",\r\n    \"title\": \"BootNotificationRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"chargePointVendor\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"chargePointModel\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"chargePointSerialNumber\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 25\r\n        },\r\n        \"chargeBoxSerialNumber\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 25\r\n        },\r\n        \"firmwareVersion\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50\r\n        },\r\n        \"iccid\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"imsi\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"meterType\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 25\r\n        },\r\n        \"meterSerialNumber\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 25\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"chargePointVendor\",\r\n        \"chargePointModel\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct BOOTNOTIFICATIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static BOOTNOTIFICATIONREQUEST_JSON: BOOTNOTIFICATIONREQUEST_JSON =
            BOOTNOTIFICATIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for BOOTNOTIFICATIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(BOOTNOTIFICATIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/BootNotification.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for BOOTNOTIFICATIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct BOOTNOTIFICATIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static BOOTNOTIFICATIONREQUEST_VALIDATOR: BOOTNOTIFICATIONREQUEST_VALIDATOR =
            BOOTNOTIFICATIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for BOOTNOTIFICATIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&BOOTNOTIFICATIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/BootNotification.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for BOOTNOTIFICATIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for BootNotificationRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = BOOTNOTIFICATIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/boot_notification.rs:53",
                                    "ocpp::point_init::boot_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/boot_notification.rs"),
                                    Some(53u32),
                                    Some("ocpp::point_init::boot_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/boot_notification.rs:53",
                                    "ocpp::point_init::boot_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/boot_notification.rs"),
                                    Some(53u32),
                                    Some("ocpp::point_init::boot_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        /// Field definition of the BootNotification.req PDU sent by the Charge Point to the Central System.
        #[builder(build_fn(name = "pre_build", error = "OcppError"))]
        #[serde(rename_all = "camelCase")]
        pub struct BootNotificationRequest {
            /// Optional. This contains a value that identifies the serial number of the Charge Box inside the Charge Point.
            /// Deprecated, will be removed in future versio
            #[validate(length(max = 20))]
            pub charge_point_vendor: String,
            /// Required. This contains a value that identifies the model of the ChargePoint.
            #[validate(length(max = 20))]
            pub charge_point_model: String,
            /// Optional. This contains a value that identifies the serial number of the Charge Point.
            #[validate(length(max = 25))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub charge_point_serial_number: Option<String>,
            /// Identifies the serial number of the Charge Box inside the Charge Point. Deprecated, will be removed in future version.
            #[validate(length(max = 25))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub charge_box_serial_number: Option<String>,
            /// Identifies the firmware version on the charge .
            #[validate(length(max = 50))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub firmware_version: Option<String>,
            /// Identifies the ICCID of the modem's SIM card.
            #[validate(length(max = 20))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub iccid: Option<String>,
            /// Identifies the IMSI of the modem's SIM card.
            #[validate(length(max = 20))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub imsi: Option<String>,
            /// Identifies the type of the main electrical meter of the charge point.
            #[validate(length(max = 25))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub meter_type: Option<String>,
            /// Identifies the serial numbver of the main electrical meter of the charge point.
            #[validate(length(max = 25))]
            #[builder(default)]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub meter_serial_number: Option<String>,
        }
        impl BootNotificationRequest {
            pub fn print_field_names() {
                {
                    :: std :: io :: _print (:: core :: fmt :: Arguments :: new_v1 (& ["" , "\n"] , & [:: core :: fmt :: ArgumentV1 :: new_display (& "let build_struct = BootNotificationRequestBuilder ::\ndefault().charge_point_vendor(test.charge_point_vendor).charge_point_model(test.charge_point_model).charge_point_serial_number(test.charge_point_serial_number).charge_box_serial_number(test.charge_box_serial_number).firmware_version(test.firmware_version).iccid(test.iccid).imsi(test.imsi).meter_type(test.meter_type).meter_serial_number(test.meter_serial_number).build()\n;")])) ;
                };
            }
        }
        #[automatically_derived]
        impl proptest::arbitrary::Arbitrary for BootNotificationRequest {
            type Parameters = ();
            type Strategy = proptest::strategy::BoxedStrategy<Self>;
            fn arbitrary_with(
                args: <Self as proptest::arbitrary::Arbitrary>::Parameters,
            ) -> Self::Strategy {
                #[allow(dead_code)]
                fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                    f
                }
                let args = std::rc::Rc::new(args);
                proptest::strategy::Strategy::boxed({
                    let strategy_0 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_charge_point_vendor<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<String>();
                        _s
                    },);
                    let strategy_1 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_charge_point_model<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<String>();
                        _s
                    },);
                    let strategy_2 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_charge_point_serial_number<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_3 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_charge_box_serial_number<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_4 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_firmware_version<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_5 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_iccid<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_6 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_imsi<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_7 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_meter_type<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_8 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_meter_serial_number<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<Option<String>>();
                        _s
                    },);
                    let strategy_0 = proptest::strategy::Strategy::prop_map(
                        (
                            strategy_0, strategy_1, strategy_2, strategy_3, strategy_4, strategy_5,
                            strategy_6, strategy_7, strategy_8,
                        ),
                        |_values| {
                            (
                                _values.0 .0,
                                _values.1 .0,
                                _values.2 .0,
                                _values.3 .0,
                                _values.4 .0,
                                _values.5 .0,
                                _values.6 .0,
                                _values.7 .0,
                                _values.8 .0,
                            )
                        },
                    );
                    let strategy_0 =
                        proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self {
                            charge_point_vendor: _values.0,
                            charge_point_model: _values.1,
                            charge_point_serial_number: _values.2,
                            charge_box_serial_number: _values.3,
                            firmware_version: _values.4,
                            iccid: _values.5,
                            imsi: _values.6,
                            meter_type: _values.7,
                            meter_serial_number: _values.8,
                        });
                    strategy_0
                })
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BootNotificationRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "BootNotificationRequest",
                        false as usize
                            + 1
                            + 1
                            + if Option::is_none(&self.charge_point_serial_number) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.charge_box_serial_number) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.firmware_version) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.iccid) { 0 } else { 1 }
                            + if Option::is_none(&self.imsi) { 0 } else { 1 }
                            + if Option::is_none(&self.meter_type) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.meter_serial_number) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargePointVendor",
                        &self.charge_point_vendor,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chargePointModel",
                        &self.charge_point_model,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.charge_point_serial_number) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chargePointSerialNumber",
                            &self.charge_point_serial_number,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "chargePointSerialNumber",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.charge_box_serial_number) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chargeBoxSerialNumber",
                            &self.charge_box_serial_number,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "chargeBoxSerialNumber",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.firmware_version) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "firmwareVersion",
                            &self.firmware_version,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "firmwareVersion",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.iccid) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iccid",
                            &self.iccid,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "iccid")
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.imsi) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "imsi",
                            &self.imsi,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "imsi") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.meter_type) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "meterType",
                            &self.meter_type,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "meterType",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.meter_serial_number) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "meterSerialNumber",
                            &self.meter_serial_number,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "meterSerialNumber",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ::validator::Validate for BootNotificationRequest {
            fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
                use ::validator::ValidateArgs;
                self.validate_args(())
            }
        }
        #[allow(clippy::all)]
        #[allow(single_use_lifetimes)]
        impl<'v_a> ::validator::ValidateArgs<'v_a> for BootNotificationRequest {
            type Args = ();
            #[allow(unused_mut)]
            #[allow(unused_variable)]
            fn validate_args(
                &self,
                args: Self::Args,
            ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
                let mut errors = ::validator::ValidationErrors::new();
                if !::validator::validate_length(
                    &self.charge_point_vendor,
                    ::std::option::Option::None,
                    ::std::option::Option::Some(20u64 as u64),
                    ::std::option::Option::None,
                ) {
                    let mut err = ::validator::ValidationError::new("length");
                    err.add_param(::std::borrow::Cow::from("max"), &20u64);
                    err.add_param(
                        ::std::borrow::Cow::from("value"),
                        &&self.charge_point_vendor,
                    );
                    errors.add("charge_point_vendor", err);
                }
                if !::validator::validate_length(
                    &self.charge_point_model,
                    ::std::option::Option::None,
                    ::std::option::Option::Some(20u64 as u64),
                    ::std::option::Option::None,
                ) {
                    let mut err = ::validator::ValidationError::new("length");
                    err.add_param(::std::borrow::Cow::from("max"), &20u64);
                    err.add_param(::std::borrow::Cow::from("value"), &&self.charge_point_model);
                    errors.add("charge_point_model", err);
                }
                if let Some(ref charge_point_serial_number) = self.charge_point_serial_number {
                    if !::validator::validate_length(
                        charge_point_serial_number,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(25u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &25u64);
                        err.add_param(
                            ::std::borrow::Cow::from("value"),
                            &charge_point_serial_number,
                        );
                        errors.add("charge_point_serial_number", err);
                    }
                }
                if let Some(ref charge_box_serial_number) = self.charge_box_serial_number {
                    if !::validator::validate_length(
                        charge_box_serial_number,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(25u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &25u64);
                        err.add_param(::std::borrow::Cow::from("value"), &charge_box_serial_number);
                        errors.add("charge_box_serial_number", err);
                    }
                }
                if let Some(ref firmware_version) = self.firmware_version {
                    if !::validator::validate_length(
                        firmware_version,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(50u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &50u64);
                        err.add_param(::std::borrow::Cow::from("value"), &firmware_version);
                        errors.add("firmware_version", err);
                    }
                }
                if let Some(ref iccid) = self.iccid {
                    if !::validator::validate_length(
                        iccid,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(20u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &20u64);
                        err.add_param(::std::borrow::Cow::from("value"), &iccid);
                        errors.add("iccid", err);
                    }
                }
                if let Some(ref imsi) = self.imsi {
                    if !::validator::validate_length(
                        imsi,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(20u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &20u64);
                        err.add_param(::std::borrow::Cow::from("value"), &imsi);
                        errors.add("imsi", err);
                    }
                }
                if let Some(ref meter_type) = self.meter_type {
                    if !::validator::validate_length(
                        meter_type,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(25u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &25u64);
                        err.add_param(::std::borrow::Cow::from("value"), &meter_type);
                        errors.add("meter_type", err);
                    }
                }
                if let Some(ref meter_serial_number) = self.meter_serial_number {
                    if !::validator::validate_length(
                        meter_serial_number,
                        ::std::option::Option::None,
                        ::std::option::Option::Some(25u64 as u64),
                        ::std::option::Option::None,
                    ) {
                        let mut err = ::validator::ValidationError::new("length");
                        err.add_param(::std::borrow::Cow::from("max"), &25u64);
                        err.add_param(::std::borrow::Cow::from("value"), &meter_serial_number);
                        errors.add("meter_serial_number", err);
                    }
                }
                let mut result = if errors.is_empty() {
                    ::std::result::Result::Ok(())
                } else {
                    ::std::result::Result::Err(errors)
                };
                result
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for BootNotificationRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "chargePointVendor" => _serde::__private::Ok(__Field::__field0),
                                "chargePointModel" => _serde::__private::Ok(__Field::__field1),
                                "chargePointSerialNumber" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "chargeBoxSerialNumber" => _serde::__private::Ok(__Field::__field3),
                                "firmwareVersion" => _serde::__private::Ok(__Field::__field4),
                                "iccid" => _serde::__private::Ok(__Field::__field5),
                                "imsi" => _serde::__private::Ok(__Field::__field6),
                                "meterType" => _serde::__private::Ok(__Field::__field7),
                                "meterSerialNumber" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"chargePointVendor" => _serde::__private::Ok(__Field::__field0),
                                b"chargePointModel" => _serde::__private::Ok(__Field::__field1),
                                b"chargePointSerialNumber" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"chargeBoxSerialNumber" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"firmwareVersion" => _serde::__private::Ok(__Field::__field4),
                                b"iccid" => _serde::__private::Ok(__Field::__field5),
                                b"imsi" => _serde::__private::Ok(__Field::__field6),
                                b"meterType" => _serde::__private::Ok(__Field::__field7),
                                b"meterSerialNumber" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<BootNotificationRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = BootNotificationRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct BootNotificationRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct BootNotificationRequest with 9 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(BootNotificationRequest {
                                charge_point_vendor: __field0,
                                charge_point_model: __field1,
                                charge_point_serial_number: __field2,
                                charge_box_serial_number: __field3,
                                firmware_version: __field4,
                                iccid: __field5,
                                imsi: __field6,
                                meter_type: __field7,
                                meter_serial_number: __field8,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field7: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field8: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargePointVendor",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargePointModel",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargePointSerialNumber",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargeBoxSerialNumber",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "firmwareVersion",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "iccid",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "imsi",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "meterType",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "meterSerialNumber",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargePointVendor")
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargePointModel") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "chargePointSerialNumber",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "chargeBoxSerialNumber",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("firmwareVersion") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("iccid") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("imsi") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("meterType") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("meterSerialNumber")
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(BootNotificationRequest {
                                charge_point_vendor: __field0,
                                charge_point_model: __field1,
                                charge_point_serial_number: __field2,
                                charge_box_serial_number: __field3,
                                firmware_version: __field4,
                                iccid: __field5,
                                imsi: __field6,
                                meter_type: __field7,
                                meter_serial_number: __field8,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "chargePointVendor",
                        "chargePointModel",
                        "chargePointSerialNumber",
                        "chargeBoxSerialNumber",
                        "firmwareVersion",
                        "iccid",
                        "imsi",
                        "meterType",
                        "meterSerialNumber",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "BootNotificationRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<BootNotificationRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for BootNotificationRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                {
                    let names: &'static _ = &[
                        "charge_point_vendor",
                        "charge_point_model",
                        "charge_point_serial_number",
                        "charge_box_serial_number",
                        "firmware_version",
                        "iccid",
                        "imsi",
                        "meter_type",
                        "meter_serial_number",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.charge_point_vendor,
                        &&self.charge_point_model,
                        &&self.charge_point_serial_number,
                        &&self.charge_box_serial_number,
                        &&self.firmware_version,
                        &&self.iccid,
                        &&self.imsi,
                        &&self.meter_type,
                        &&self.meter_serial_number,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "BootNotificationRequest",
                        names,
                        values,
                    )
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for BootNotificationRequest {
            #[inline]
            fn clone(&self) -> BootNotificationRequest {
                BootNotificationRequest {
                    charge_point_vendor: ::core::clone::Clone::clone(&self.charge_point_vendor),
                    charge_point_model: ::core::clone::Clone::clone(&self.charge_point_model),
                    charge_point_serial_number: ::core::clone::Clone::clone(
                        &self.charge_point_serial_number,
                    ),
                    charge_box_serial_number: ::core::clone::Clone::clone(
                        &self.charge_box_serial_number,
                    ),
                    firmware_version: ::core::clone::Clone::clone(&self.firmware_version),
                    iccid: ::core::clone::Clone::clone(&self.iccid),
                    imsi: ::core::clone::Clone::clone(&self.imsi),
                    meter_type: ::core::clone::Clone::clone(&self.meter_type),
                    meter_serial_number: ::core::clone::Clone::clone(&self.meter_serial_number),
                }
            }
        }
        #[allow(clippy::all)]
        ///Builder for [`BootNotificationRequest`](struct.BootNotificationRequest.html).
        pub struct BootNotificationRequestBuilder {
            /// Optional. This contains a value that identifies the serial number of the Charge Box inside the Charge Point.
            /// Deprecated, will be removed in future versio
            charge_point_vendor: ::derive_builder::export::core::option::Option<String>,
            /// Required. This contains a value that identifies the model of the ChargePoint.
            charge_point_model: ::derive_builder::export::core::option::Option<String>,
            /// Optional. This contains a value that identifies the serial number of the Charge Point.
            charge_point_serial_number:
                ::derive_builder::export::core::option::Option<Option<String>>,
            /// Identifies the serial number of the Charge Box inside the Charge Point. Deprecated, will be removed in future version.
            charge_box_serial_number:
                ::derive_builder::export::core::option::Option<Option<String>>,
            /// Identifies the firmware version on the charge .
            firmware_version: ::derive_builder::export::core::option::Option<Option<String>>,
            /// Identifies the ICCID of the modem's SIM card.
            iccid: ::derive_builder::export::core::option::Option<Option<String>>,
            /// Identifies the IMSI of the modem's SIM card.
            imsi: ::derive_builder::export::core::option::Option<Option<String>>,
            /// Identifies the type of the main electrical meter of the charge point.
            meter_type: ::derive_builder::export::core::option::Option<Option<String>>,
            /// Identifies the serial numbver of the main electrical meter of the charge point.
            meter_serial_number: ::derive_builder::export::core::option::Option<Option<String>>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::all)]
        impl ::core::clone::Clone for BootNotificationRequestBuilder {
            #[inline]
            fn clone(&self) -> BootNotificationRequestBuilder {
                BootNotificationRequestBuilder {
                    charge_point_vendor: ::core::clone::Clone::clone(&self.charge_point_vendor),
                    charge_point_model: ::core::clone::Clone::clone(&self.charge_point_model),
                    charge_point_serial_number: ::core::clone::Clone::clone(
                        &self.charge_point_serial_number,
                    ),
                    charge_box_serial_number: ::core::clone::Clone::clone(
                        &self.charge_box_serial_number,
                    ),
                    firmware_version: ::core::clone::Clone::clone(&self.firmware_version),
                    iccid: ::core::clone::Clone::clone(&self.iccid),
                    imsi: ::core::clone::Clone::clone(&self.imsi),
                    meter_type: ::core::clone::Clone::clone(&self.meter_type),
                    meter_serial_number: ::core::clone::Clone::clone(&self.meter_serial_number),
                }
            }
        }
        #[allow(clippy::all)]
        #[allow(dead_code)]
        impl BootNotificationRequestBuilder {
            /// Optional. This contains a value that identifies the serial number of the Charge Box inside the Charge Point.
            /// Deprecated, will be removed in future versio
            #[allow(unused_mut)]
            pub fn charge_point_vendor(&mut self, value: String) -> &mut Self {
                let mut new = self;
                new.charge_point_vendor =
                    ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Required. This contains a value that identifies the model of the ChargePoint.
            #[allow(unused_mut)]
            pub fn charge_point_model(&mut self, value: String) -> &mut Self {
                let mut new = self;
                new.charge_point_model =
                    ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Optional. This contains a value that identifies the serial number of the Charge Point.
            #[allow(unused_mut)]
            pub fn charge_point_serial_number(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.charge_point_serial_number =
                    ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Identifies the serial number of the Charge Box inside the Charge Point. Deprecated, will be removed in future version.
            #[allow(unused_mut)]
            pub fn charge_box_serial_number(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.charge_box_serial_number =
                    ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Identifies the firmware version on the charge .
            #[allow(unused_mut)]
            pub fn firmware_version(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.firmware_version = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Identifies the ICCID of the modem's SIM card.
            #[allow(unused_mut)]
            pub fn iccid(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.iccid = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Identifies the IMSI of the modem's SIM card.
            #[allow(unused_mut)]
            pub fn imsi(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.imsi = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Identifies the type of the main electrical meter of the charge point.
            #[allow(unused_mut)]
            pub fn meter_type(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.meter_type = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Identifies the serial numbver of the main electrical meter of the charge point.
            #[allow(unused_mut)]
            pub fn meter_serial_number(&mut self, value: Option<String>) -> &mut Self {
                let mut new = self;
                new.meter_serial_number =
                    ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            ///Builds a new `BootNotificationRequest`.
            ///
            ///# Errors
            ///
            ///If a required field has not been initialized.
            pub fn pre_build(
                &self,
            ) -> ::derive_builder::export::core::result::Result<BootNotificationRequest, OcppError>
            {
                Ok(BootNotificationRequest {
                    charge_point_vendor: match self.charge_point_vendor {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => {
                            return ::derive_builder::export::core::result::Result::Err(
                                ::derive_builder::export::core::convert::Into::into(
                                    ::derive_builder::UninitializedFieldError::from(
                                        "charge_point_vendor",
                                    ),
                                ),
                            )
                        }
                    },
                    charge_point_model: match self.charge_point_model {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => {
                            return ::derive_builder::export::core::result::Result::Err(
                                ::derive_builder::export::core::convert::Into::into(
                                    ::derive_builder::UninitializedFieldError::from(
                                        "charge_point_model",
                                    ),
                                ),
                            )
                        }
                    },
                    charge_point_serial_number: match self.charge_point_serial_number {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                    charge_box_serial_number: match self.charge_box_serial_number {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                    firmware_version: match self.firmware_version {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                    iccid: match self.iccid {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                    imsi: match self.imsi {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                    meter_type: match self.meter_type {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                    meter_serial_number: match self.meter_serial_number {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => ::derive_builder::export::core::default::Default::default(),
                    },
                })
            }
            /// Create an empty builder, with all fields set to `None` or `PhantomData`.
            fn create_empty() -> Self {
                Self {
                    charge_point_vendor: ::derive_builder::export::core::default::Default::default(
                    ),
                    charge_point_model: ::derive_builder::export::core::default::Default::default(),
                    charge_point_serial_number:
                        ::derive_builder::export::core::default::Default::default(),
                    charge_box_serial_number:
                        ::derive_builder::export::core::default::Default::default(),
                    firmware_version: ::derive_builder::export::core::default::Default::default(),
                    iccid: ::derive_builder::export::core::default::Default::default(),
                    imsi: ::derive_builder::export::core::default::Default::default(),
                    meter_type: ::derive_builder::export::core::default::Default::default(),
                    meter_serial_number: ::derive_builder::export::core::default::Default::default(
                    ),
                }
            }
        }
        impl ::derive_builder::export::core::default::Default for BootNotificationRequestBuilder {
            fn default() -> Self {
                Self::create_empty()
            }
        }
        const BOOTNOTIFICATIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"BootNotificationResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Pending\",\n                \"Rejected\"\n            ]\n        },\n        \"currentTime\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"interval\": {\n            \"type\": \"integer\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\",\n        \"currentTime\",\n        \"interval\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct BOOTNOTIFICATIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static BOOTNOTIFICATIONRESPONSE_JSON: BOOTNOTIFICATIONRESPONSE_JSON =
            BOOTNOTIFICATIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for BOOTNOTIFICATIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(BOOTNOTIFICATIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/BootNotificationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for BOOTNOTIFICATIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct BOOTNOTIFICATIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static BOOTNOTIFICATIONRESPONSE_VALIDATOR: BOOTNOTIFICATIONRESPONSE_VALIDATOR =
            BOOTNOTIFICATIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for BOOTNOTIFICATIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&BOOTNOTIFICATIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/BootNotificationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for BOOTNOTIFICATIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for BootNotificationResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = BOOTNOTIFICATIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/boot_notification.rs:100",
                                    "ocpp::point_init::boot_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/boot_notification.rs"),
                                    Some(100u32),
                                    Some("ocpp::point_init::boot_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/boot_notification.rs:100",
                                    "ocpp::point_init::boot_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/boot_notification.rs"),
                                    Some(100u32),
                                    Some("ocpp::point_init::boot_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        /// Field definition of the BootNotification.conf PDU sent by the Central System to the Charge Point in response to a BootNotification.req PDU.
        #[builder(build_fn(name = "pre_build", error = "OcppError"))]
        #[serde(rename_all = "camelCase")]
        pub struct BootNotificationResponse {
            /// Identifies whether the charge point has been registered with the central server.
            pub status: BootNotificationStatus,
            /// Required. This contains the current time of the Central System.
            pub current_time: UtcTime,
            /// When status is accepted, contains the heartbeat inverval in seconds. If status is not accepted, contains a timeout value before the charge point can retry bootnotifacion.
            pub interval: u32,
        }
        #[automatically_derived]
        impl proptest::arbitrary::Arbitrary for BootNotificationResponse {
            type Parameters = ();
            type Strategy = proptest::strategy::BoxedStrategy<Self>;
            fn arbitrary_with(
                args: <Self as proptest::arbitrary::Arbitrary>::Parameters,
            ) -> Self::Strategy {
                #[allow(dead_code)]
                fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                    f
                }
                let args = std::rc::Rc::new(args);
                proptest::strategy::Strategy::boxed({
                    let strategy_0 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_status<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<BootNotificationStatus>();
                        _s
                    },);
                    let strategy_1 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_current_time<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<UtcTime>();
                        _s
                    },);
                    let strategy_2 = ({
                        #[allow(dead_code)]
                        fn _strategy_of_interval<
                            T: std::fmt::Debug,
                            S: proptest::strategy::Strategy<Value = T>,
                        >(
                            s: S,
                        ) -> impl proptest::strategy::Strategy<Value = T> {
                            s
                        }
                        let _s = proptest::arbitrary::any::<u32>();
                        _s
                    },);
                    let strategy_0 = proptest::strategy::Strategy::prop_map(
                        (strategy_0, strategy_1, strategy_2),
                        |_values| (_values.0 .0, _values.1 .0, _values.2 .0),
                    );
                    let strategy_0 =
                        proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self {
                            status: _values.0,
                            current_time: _values.1,
                            interval: _values.2,
                        });
                    strategy_0
                })
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BootNotificationResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "BootNotificationResponse",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "currentTime",
                        &self.current_time,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "interval",
                        &self.interval,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ::validator::Validate for BootNotificationResponse {
            fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
                use ::validator::ValidateArgs;
                self.validate_args(())
            }
        }
        #[allow(clippy::all)]
        #[allow(single_use_lifetimes)]
        impl<'v_a> ::validator::ValidateArgs<'v_a> for BootNotificationResponse {
            type Args = ();
            #[allow(unused_mut)]
            #[allow(unused_variable)]
            fn validate_args(
                &self,
                args: Self::Args,
            ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
                let mut errors = ::validator::ValidationErrors::new();
                let mut result = if errors.is_empty() {
                    ::std::result::Result::Ok(())
                } else {
                    ::std::result::Result::Err(errors)
                };
                result
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for BootNotificationResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                "currentTime" => _serde::__private::Ok(__Field::__field1),
                                "interval" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                b"currentTime" => _serde::__private::Ok(__Field::__field1),
                                b"interval" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<BootNotificationResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = BootNotificationResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct BootNotificationResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                BootNotificationStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct BootNotificationResponse with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<UtcTime>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct BootNotificationResponse with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct BootNotificationResponse with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(BootNotificationResponse {
                                status: __field0,
                                current_time: __field1,
                                interval: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<BootNotificationStatus> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<UtcTime> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                BootNotificationStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "currentTime",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<UtcTime>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "interval",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("currentTime") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("interval") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(BootNotificationResponse {
                                status: __field0,
                                current_time: __field1,
                                interval: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status", "currentTime", "interval"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "BootNotificationResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<BootNotificationResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for BootNotificationResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "BootNotificationResponse",
                    "status",
                    &&self.status,
                    "current_time",
                    &&self.current_time,
                    "interval",
                    &&self.interval,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for BootNotificationResponse {
            #[inline]
            fn clone(&self) -> BootNotificationResponse {
                BootNotificationResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                    current_time: ::core::clone::Clone::clone(&self.current_time),
                    interval: ::core::clone::Clone::clone(&self.interval),
                }
            }
        }
        #[allow(clippy::all)]
        ///Builder for [`BootNotificationResponse`](struct.BootNotificationResponse.html).
        pub struct BootNotificationResponseBuilder {
            /// Identifies whether the charge point has been registered with the central server.
            status: ::derive_builder::export::core::option::Option<BootNotificationStatus>,
            /// Required. This contains the current time of the Central System.
            current_time: ::derive_builder::export::core::option::Option<UtcTime>,
            /// When status is accepted, contains the heartbeat inverval in seconds. If status is not accepted, contains a timeout value before the charge point can retry bootnotifacion.
            interval: ::derive_builder::export::core::option::Option<u32>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::all)]
        impl ::core::clone::Clone for BootNotificationResponseBuilder {
            #[inline]
            fn clone(&self) -> BootNotificationResponseBuilder {
                BootNotificationResponseBuilder {
                    status: ::core::clone::Clone::clone(&self.status),
                    current_time: ::core::clone::Clone::clone(&self.current_time),
                    interval: ::core::clone::Clone::clone(&self.interval),
                }
            }
        }
        #[allow(clippy::all)]
        #[allow(dead_code)]
        impl BootNotificationResponseBuilder {
            /// Identifies whether the charge point has been registered with the central server.
            #[allow(unused_mut)]
            pub fn status(&mut self, value: BootNotificationStatus) -> &mut Self {
                let mut new = self;
                new.status = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// Required. This contains the current time of the Central System.
            #[allow(unused_mut)]
            pub fn current_time(&mut self, value: UtcTime) -> &mut Self {
                let mut new = self;
                new.current_time = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            /// When status is accepted, contains the heartbeat inverval in seconds. If status is not accepted, contains a timeout value before the charge point can retry bootnotifacion.
            #[allow(unused_mut)]
            pub fn interval(&mut self, value: u32) -> &mut Self {
                let mut new = self;
                new.interval = ::derive_builder::export::core::option::Option::Some(value);
                new
            }
            ///Builds a new `BootNotificationResponse`.
            ///
            ///# Errors
            ///
            ///If a required field has not been initialized.
            pub fn pre_build(
                &self,
            ) -> ::derive_builder::export::core::result::Result<BootNotificationResponse, OcppError>
            {
                Ok(BootNotificationResponse {
                    status: match self.status {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => {
                            return ::derive_builder::export::core::result::Result::Err(
                                ::derive_builder::export::core::convert::Into::into(
                                    ::derive_builder::UninitializedFieldError::from("status"),
                                ),
                            )
                        }
                    },
                    current_time: match self.current_time {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => {
                            return ::derive_builder::export::core::result::Result::Err(
                                ::derive_builder::export::core::convert::Into::into(
                                    ::derive_builder::UninitializedFieldError::from("current_time"),
                                ),
                            )
                        }
                    },
                    interval: match self.interval {
                        Some(ref value) => {
                            ::derive_builder::export::core::clone::Clone::clone(value)
                        }
                        None => {
                            return ::derive_builder::export::core::result::Result::Err(
                                ::derive_builder::export::core::convert::Into::into(
                                    ::derive_builder::UninitializedFieldError::from("interval"),
                                ),
                            )
                        }
                    },
                })
            }
            /// Create an empty builder, with all fields set to `None` or `PhantomData`.
            fn create_empty() -> Self {
                Self {
                    status: ::derive_builder::export::core::default::Default::default(),
                    current_time: ::derive_builder::export::core::default::Default::default(),
                    interval: ::derive_builder::export::core::default::Default::default(),
                }
            }
        }
        impl ::derive_builder::export::core::default::Default for BootNotificationResponseBuilder {
            fn default() -> Self {
                Self::create_empty()
            }
        }
        ///Struct Definition
        pub enum BootNotificationStatus {
            /// Chargepoint accepted by central system
            Accepted,
            /// Acceptance pending. Central system may send messages to retrieve information or prepare the charge point.
            Pending,
            /// Charge point not accepted, i.e. chargepointID is not known
            Rejected,
        }
        #[automatically_derived]
        impl proptest::arbitrary::Arbitrary for BootNotificationStatus {
            type Parameters = ();
            type Strategy = proptest::strategy::BoxedStrategy<Self>;
            fn arbitrary_with(
                args: <Self as proptest::arbitrary::Arbitrary>::Parameters,
            ) -> Self::Strategy {
                #[allow(dead_code)]
                fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                    f
                }
                let args = std::rc::Rc::new(args);
                proptest::strategy::Strategy::boxed({
                    #[allow(dead_code)]
                    fn _to_weight(weight: u32) -> u32 {
                        weight
                    }
                    let _s = ::proptest::strategy::TupleUnion::new((
                        (
                            1,
                            ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(
                                || Self::Accepted,
                            )),
                        ),
                        (
                            1,
                            ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(
                                || Self::Pending,
                            )),
                        ),
                        (
                            1,
                            ::proptest::std_facade::Arc::new(proptest::strategy::LazyJust::new(
                                || Self::Rejected,
                            )),
                        ),
                    ));
                    _s
                })
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for BootNotificationStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        BootNotificationStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BootNotificationStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        BootNotificationStatus::Pending => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BootNotificationStatus",
                                1u32,
                                "Pending",
                            )
                        }
                        BootNotificationStatus::Rejected => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "BootNotificationStatus",
                                2u32,
                                "Rejected",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for BootNotificationStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Pending" => _serde::__private::Ok(__Field::__field1),
                                "Rejected" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Pending" => _serde::__private::Ok(__Field::__field1),
                                b"Rejected" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<BootNotificationStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = BootNotificationStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum BootNotificationStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(BootNotificationStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(BootNotificationStatus::Pending)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(BootNotificationStatus::Rejected)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Accepted", "Pending", "Rejected"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "BootNotificationStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<BootNotificationStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for BootNotificationStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&BootNotificationStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&BootNotificationStatus::Pending,) => {
                        ::core::fmt::Formatter::write_str(f, "Pending")
                    }
                    (&BootNotificationStatus::Rejected,) => {
                        ::core::fmt::Formatter::write_str(f, "Rejected")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for BootNotificationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for BootNotificationStatus {
            #[inline]
            fn eq(&self, other: &BootNotificationStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for BootNotificationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for BootNotificationStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for BootNotificationStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    BootNotificationStatus::Accepted => f.pad("Accepted"),
                    BootNotificationStatus::Pending => f.pad("Pending"),
                    BootNotificationStatus::Rejected => f.pad("Rejected"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for BootNotificationStatus {
            #[inline]
            fn clone(&self) -> BootNotificationStatus {
                match (&*self,) {
                    (&BootNotificationStatus::Accepted,) => BootNotificationStatus::Accepted,
                    (&BootNotificationStatus::Pending,) => BootNotificationStatus::Pending,
                    (&BootNotificationStatus::Rejected,) => BootNotificationStatus::Rejected,
                }
            }
        }
        impl BootNotificationRequestBuilder {
            /// Builder function for [<$i>] struct
            pub fn build(&self) -> Result<BootNotificationRequest, OcppError> {
                let req = self.pre_build()?;
                return req.validate().map(|_| req).map_err(|e| e.into());
            }
        }
        impl BootNotificationResponseBuilder {
            /// Builder function for [<$i>] struct
            pub fn build(&self) -> Result<BootNotificationResponse, OcppError> {
                let req = self.pre_build()?;
                return req.validate().map(|_| req).map_err(|e| e.into());
            }
        }
        #[cfg(test)]
        mod test {
            use super::*;
            use test_strategy::proptest;
            use validation_macros::JsonValidate;
            extern crate test;
            #[cfg(test)]
            #[rustc_test_marker]
            pub const test_macro: test::TestDescAndFn = test::TestDescAndFn {
                desc: test::TestDesc {
                    name: test::StaticTestName("point_init::boot_notification::test::test_macro"),
                    ignore: false,
                    ignore_message: ::core::option::Option::None,
                    compile_fail: false,
                    no_run: false,
                    should_panic: test::ShouldPanic::No,
                    test_type: test::TestType::UnitTest,
                },
                testfn: test::StaticTestFn(|| test::assert_test_result(test_macro())),
            };
            fn test_macro() {
                BootNotificationRequest::print_field_names();
            }
            struct _CompareRequestBuilderValidationWithSchemaValidationArgs {
                proptest_struct: super::BootNotificationRequest,
            }
            #[automatically_derived]
            impl proptest::arbitrary::Arbitrary for _CompareRequestBuilderValidationWithSchemaValidationArgs {
                type Parameters = ();
                type Strategy = proptest::strategy::BoxedStrategy<Self>;
                fn arbitrary_with(
                    args: <Self as proptest::arbitrary::Arbitrary>::Parameters,
                ) -> Self::Strategy {
                    #[allow(dead_code)]
                    fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                        f
                    }
                    let args = std::rc::Rc::new(args);
                    proptest::strategy::Strategy::boxed({
                        let strategy_0 = ({
                            #[allow(dead_code)]
                            fn _strategy_of_proptest_struct<
                                T: std::fmt::Debug,
                                S: proptest::strategy::Strategy<Value = T>,
                            >(
                                s: S,
                            ) -> impl proptest::strategy::Strategy<Value = T>
                            {
                                s
                            }
                            let _s = proptest::arbitrary::any::<super::BootNotificationRequest>();
                            _s
                        },);
                        let strategy_0 =
                            proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self {
                                proptest_struct: _values.0,
                            });
                        strategy_0
                    })
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for _CompareRequestBuilderValidationWithSchemaValidationArgs {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "_CompareRequestBuilderValidationWithSchemaValidationArgs",
                        "proptest_struct",
                        &&self.proptest_struct,
                    )
                }
            }
            extern crate test;
            #[cfg(test)]
            #[rustc_test_marker]
            pub const compare_request_builder_validation_with_schema_validation : test :: TestDescAndFn = test :: TestDescAndFn { desc : test :: TestDesc { name : test :: StaticTestName ("point_init::boot_notification::test::compare_request_builder_validation_with_schema_validation") , ignore : false , ignore_message : :: core :: option :: Option :: None , compile_fail : false , no_run : false , should_panic : test :: ShouldPanic :: No , test_type : test :: TestType :: UnitTest , } , testfn : test :: StaticTestFn (| | test :: assert_test_result (compare_request_builder_validation_with_schema_validation ())) , } ;
            /// Test validation via builder against validation via schema
            fn compare_request_builder_validation_with_schema_validation() {
                let mut config = ::proptest::test_runner::Config::default().clone();
                config . test_name = Some ("ocpp::point_init::boot_notification::test::compare_request_builder_validation_with_schema_validation") ;
                {
                    config.source_file = Some("src/point_init/boot_notification.rs");
                    let mut runner = ::proptest::test_runner::TestRunner::new(config);
                    let names = "input";
                    match runner.run(
                        &::proptest::strategy::Strategy::prop_map(
                            ::proptest::arbitrary::any::<
                                _CompareRequestBuilderValidationWithSchemaValidationArgs,
                            >(),
                            |values| ::proptest::sugar::NamedArguments(names, values),
                        ),
                        |::proptest::sugar::NamedArguments(_, input)| {
                            let _: () = {
                                let _CompareRequestBuilderValidationWithSchemaValidationArgs {
                                    proptest_struct,
                                } = input;
                                {
                                    let test = proptest_struct.clone();
                                    let built_struct = BootNotificationRequestBuilder::default()
                                        .charge_point_vendor(test.charge_point_vendor)
                                        .charge_point_model(test.charge_point_model.clone())
                                        .charge_point_serial_number(test.charge_point_serial_number)
                                        .charge_box_serial_number(test.charge_box_serial_number)
                                        .firmware_version(test.firmware_version)
                                        .iccid(test.iccid)
                                        .imsi(test.imsi)
                                        .meter_type(test.meter_type)
                                        .meter_serial_number(test.meter_serial_number)
                                        .build();
                                    let builder_validated_ok = built_struct.is_ok();
                                    let schema_validated_ok =
                                        proptest_struct.schema_validate().is_ok();
                                    match (&builder_validated_ok, &schema_validated_ok) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::None,
                                                );
                                            }
                                        }
                                    };
                                }
                            };
                            Ok(())
                        },
                    ) {
                        Ok(_) => (),
                        Err(e) => ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["", "\n"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&e),
                                ::core::fmt::ArgumentV1::new_display(&runner),
                            ],
                        )),
                    }
                };
            }
            struct _CompareResponseBuilderValidationWithSchemaValidationArgs {
                proptest_struct: super::BootNotificationResponse,
            }
            #[automatically_derived]
            impl proptest::arbitrary::Arbitrary for _CompareResponseBuilderValidationWithSchemaValidationArgs {
                type Parameters = ();
                type Strategy = proptest::strategy::BoxedStrategy<Self>;
                fn arbitrary_with(
                    args: <Self as proptest::arbitrary::Arbitrary>::Parameters,
                ) -> Self::Strategy {
                    #[allow(dead_code)]
                    fn _to_fn_ptr<T>(f: fn(&T) -> bool) -> fn(&T) -> bool {
                        f
                    }
                    let args = std::rc::Rc::new(args);
                    proptest::strategy::Strategy::boxed({
                        let strategy_0 = ({
                            #[allow(dead_code)]
                            fn _strategy_of_proptest_struct<
                                T: std::fmt::Debug,
                                S: proptest::strategy::Strategy<Value = T>,
                            >(
                                s: S,
                            ) -> impl proptest::strategy::Strategy<Value = T>
                            {
                                s
                            }
                            let _s = proptest::arbitrary::any::<super::BootNotificationResponse>();
                            _s
                        },);
                        let strategy_0 =
                            proptest::strategy::Strategy::prop_map(strategy_0, |_values| Self {
                                proptest_struct: _values.0,
                            });
                        strategy_0
                    })
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for _CompareResponseBuilderValidationWithSchemaValidationArgs {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "_CompareResponseBuilderValidationWithSchemaValidationArgs",
                        "proptest_struct",
                        &&self.proptest_struct,
                    )
                }
            }
            extern crate test;
            #[cfg(test)]
            #[rustc_test_marker]
            pub const compare_response_builder_validation_with_schema_validation : test :: TestDescAndFn = test :: TestDescAndFn { desc : test :: TestDesc { name : test :: StaticTestName ("point_init::boot_notification::test::compare_response_builder_validation_with_schema_validation") , ignore : false , ignore_message : :: core :: option :: Option :: None , compile_fail : false , no_run : false , should_panic : test :: ShouldPanic :: No , test_type : test :: TestType :: UnitTest , } , testfn : test :: StaticTestFn (| | test :: assert_test_result (compare_response_builder_validation_with_schema_validation ())) , } ;
            fn compare_response_builder_validation_with_schema_validation() {
                let mut config = ::proptest::test_runner::Config::default().clone();
                config . test_name = Some ("ocpp::point_init::boot_notification::test::compare_response_builder_validation_with_schema_validation") ;
                {
                    config.source_file = Some("src/point_init/boot_notification.rs");
                    let mut runner = ::proptest::test_runner::TestRunner::new(config);
                    let names = "input";
                    match runner.run(
                        &::proptest::strategy::Strategy::prop_map(
                            ::proptest::arbitrary::any::<
                                _CompareResponseBuilderValidationWithSchemaValidationArgs,
                            >(),
                            |values| ::proptest::sugar::NamedArguments(names, values),
                        ),
                        |::proptest::sugar::NamedArguments(_, input)| {
                            let _: () = {
                                let _CompareResponseBuilderValidationWithSchemaValidationArgs {
                                    proptest_struct,
                                } = input;
                                {
                                    let test = proptest_struct.clone();
                                    let built_struct = BootNotificationResponseBuilder::default()
                                        .status(test.status)
                                        .current_time(test.current_time)
                                        .interval(test.interval)
                                        .build();
                                    let builder_validated_ok = built_struct.is_ok();
                                    let schema_validated_ok =
                                        proptest_struct.schema_validate().is_ok();
                                    match (&builder_validated_ok, &schema_validated_ok) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::None,
                                                );
                                            }
                                        }
                                    };
                                }
                            };
                            Ok(())
                        },
                    ) {
                        Ok(_) => (),
                        Err(e) => ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["", "\n"],
                            &[
                                ::core::fmt::ArgumentV1::new_display(&e),
                                ::core::fmt::ArgumentV1::new_display(&runner),
                            ],
                        )),
                    }
                };
            }
        }
    }
    pub mod diagnostic_status_notification {
        //! Update from charge point to inform the Central System about the status of a diagnostics upload.
        //!
        //! # Behaviour
        //! The Charge Point SHALL send a DiagnosticsStatusNotification.req PDU to inform the Central System that the upload
        //! of diagnostics is busy or has finished successfully or failed. The Charge Point SHALL only send the status Idle
        //! after receipt of a TriggerMessage for a Diagnostics Status Notification, when it is not busy uploading diagnostics.
        //!
        //! # Response
        //! Upon receipt of a DiagnosticsStatusNotification.req PDU, the Central System SHALL respond with a
        //! DiagnosticsStatusNotification.conf.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:DiagnosticsStatusNotificationRequest\",\r\n    \"title\": \"DiagnosticsStatusNotificationRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"status\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"Idle\",\r\n                \"Uploaded\",\r\n                \"UploadFailed\",\r\n                \"Uploading\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"status\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON:
            DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON = DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/DiagnosticsStatusNotification.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR:
            DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR =
            DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_JSON)
                        .expect(&{
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Invalid Schema File: "],
                                &[::core::fmt::ArgumentV1::new_display(
                                    &"../json_schemas/DiagnosticsStatusNotification.json",
                                )],
                            ));
                            res
                        })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for DiagnosticsStatusNotificationRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = DIAGNOSTICSSTATUSNOTIFICATIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/diagnostic_status_notification.rs:17",
                                    "ocpp::point_init::diagnostic_status_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/diagnostic_status_notification.rs"),
                                    Some(17u32),
                                    Some("ocpp::point_init::diagnostic_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/diagnostic_status_notification.rs:17",
                                    "ocpp::point_init::diagnostic_status_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/diagnostic_status_notification.rs"),
                                    Some(17u32),
                                    Some("ocpp::point_init::diagnostic_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the DiagnosticsStatusNotification.req PDU sent by the Charge Point to the Central System
        pub struct DiagnosticsStatusNotificationRequest {
            /// Required. This contains the status of the diagnostics upload.
            pub status: DiagnosticsStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DiagnosticsStatusNotificationRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DiagnosticsStatusNotificationRequest",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DiagnosticsStatusNotificationRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker:
                            _serde::__private::PhantomData<DiagnosticsStatusNotificationRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DiagnosticsStatusNotificationRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DiagnosticsStatusNotificationRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                DiagnosticsStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct DiagnosticsStatusNotificationRequest with 1 element")) ;
                                }
                            };
                            _serde::__private::Ok(DiagnosticsStatusNotificationRequest {
                                status: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<DiagnosticsStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                DiagnosticsStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(DiagnosticsStatusNotificationRequest {
                                status: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DiagnosticsStatusNotificationRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DiagnosticsStatusNotificationRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DiagnosticsStatusNotificationRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "DiagnosticsStatusNotificationRequest",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DiagnosticsStatusNotificationRequest {
            #[inline]
            fn clone(&self) -> DiagnosticsStatusNotificationRequest {
                DiagnosticsStatusNotificationRequest {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status in DataTransfer.conf.
        pub enum DiagnosticsStatus {
            /// Charge Point is not performing diagnostics related tasks. Status Idle SHALL only be used as in a DiagnosticsStatusNotification.req that was triggered by a TriggerMessage.req
            Idle,
            /// Diagnostics information has been uploaded.
            Uploaded,
            /// Uploading of diagnostics failed.
            UploadFailed,
            /// File is being uploaded.
            Uploading,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DiagnosticsStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        DiagnosticsStatus::Idle => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DiagnosticsStatus",
                            0u32,
                            "Idle",
                        ),
                        DiagnosticsStatus::Uploaded => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DiagnosticsStatus",
                            1u32,
                            "Uploaded",
                        ),
                        DiagnosticsStatus::UploadFailed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DiagnosticsStatus",
                                2u32,
                                "UploadFailed",
                            )
                        }
                        DiagnosticsStatus::Uploading => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DiagnosticsStatus",
                            3u32,
                            "Uploading",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DiagnosticsStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Idle" => _serde::__private::Ok(__Field::__field0),
                                "Uploaded" => _serde::__private::Ok(__Field::__field1),
                                "UploadFailed" => _serde::__private::Ok(__Field::__field2),
                                "Uploading" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Idle" => _serde::__private::Ok(__Field::__field0),
                                b"Uploaded" => _serde::__private::Ok(__Field::__field1),
                                b"UploadFailed" => _serde::__private::Ok(__Field::__field2),
                                b"Uploading" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DiagnosticsStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DiagnosticsStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DiagnosticsStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DiagnosticsStatus::Idle)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DiagnosticsStatus::Uploaded)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DiagnosticsStatus::UploadFailed)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DiagnosticsStatus::Uploading)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Idle", "Uploaded", "UploadFailed", "Uploading"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DiagnosticsStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DiagnosticsStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DiagnosticsStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&DiagnosticsStatus::Idle,) => ::core::fmt::Formatter::write_str(f, "Idle"),
                    (&DiagnosticsStatus::Uploaded,) => {
                        ::core::fmt::Formatter::write_str(f, "Uploaded")
                    }
                    (&DiagnosticsStatus::UploadFailed,) => {
                        ::core::fmt::Formatter::write_str(f, "UploadFailed")
                    }
                    (&DiagnosticsStatus::Uploading,) => {
                        ::core::fmt::Formatter::write_str(f, "Uploading")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for DiagnosticsStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for DiagnosticsStatus {
            #[inline]
            fn eq(&self, other: &DiagnosticsStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for DiagnosticsStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for DiagnosticsStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for DiagnosticsStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    DiagnosticsStatus::Idle => f.pad("Idle"),
                    DiagnosticsStatus::Uploaded => f.pad("Uploaded"),
                    DiagnosticsStatus::UploadFailed => f.pad("UploadFailed"),
                    DiagnosticsStatus::Uploading => f.pad("Uploading"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DiagnosticsStatus {
            #[inline]
            fn clone(&self) -> DiagnosticsStatus {
                match (&*self,) {
                    (&DiagnosticsStatus::Idle,) => DiagnosticsStatus::Idle,
                    (&DiagnosticsStatus::Uploaded,) => DiagnosticsStatus::Uploaded,
                    (&DiagnosticsStatus::UploadFailed,) => DiagnosticsStatus::UploadFailed,
                    (&DiagnosticsStatus::Uploading,) => DiagnosticsStatus::Uploading,
                }
            }
        }
        const DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"DiagnosticsStatusNotificationResponse\",\n    \"type\": \"object\",\n    \"properties\": {},\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON:
            DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON =
            DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/DiagnosticsStatusNotificationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR:
            DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR =
            DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_JSON)
                        .expect(&{
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Invalid Schema File: "],
                                &[::core::fmt::ArgumentV1::new_display(
                                    &"../json_schemas/DiagnosticsStatusNotificationResponse.json",
                                )],
                            ));
                            res
                        })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for DiagnosticsStatusNotificationResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = DIAGNOSTICSSTATUSNOTIFICATIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/diagnostic_status_notification.rs:40",
                                    "ocpp::point_init::diagnostic_status_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/diagnostic_status_notification.rs"),
                                    Some(40u32),
                                    Some("ocpp::point_init::diagnostic_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/diagnostic_status_notification.rs:40",
                                    "ocpp::point_init::diagnostic_status_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/diagnostic_status_notification.rs"),
                                    Some(40u32),
                                    Some("ocpp::point_init::diagnostic_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the DataTransfer.conf PDU sent by the Charge Point to the Central System or vice versa in response to a DataTransfer.req PDU.
        pub struct DiagnosticsStatusNotificationResponse {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DiagnosticsStatusNotificationResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DiagnosticsStatusNotificationResponse",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DiagnosticsStatusNotificationResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker:
                            _serde::__private::PhantomData<DiagnosticsStatusNotificationResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DiagnosticsStatusNotificationResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DiagnosticsStatusNotificationResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(DiagnosticsStatusNotificationResponse {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(DiagnosticsStatusNotificationResponse {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DiagnosticsStatusNotificationResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DiagnosticsStatusNotificationResponse,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DiagnosticsStatusNotificationResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "DiagnosticsStatusNotificationResponse")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DiagnosticsStatusNotificationResponse {
            #[inline]
            fn clone(&self) -> DiagnosticsStatusNotificationResponse {
                DiagnosticsStatusNotificationResponse {}
            }
        }
    }
    pub mod firmware_status_notification {
        //! Update from charge point to inform the Central System about the status of a firmware update.
        //!
        //! # Behaviour
        //! The Charge Point SHALL send a FirmwareStatusNotification.req PDU for informing the Central System about the progress of
        //! the downloading and installation of a firmware update. The Charge Point SHALL only send the status Idle after receipt of a
        //! TriggerMessage for a Firmware Status Notification, when it is not busy downloading/installing firmware.
        //!
        //! # Response
        //! Upon receipt of a FirmwareStatusNotification.req PDU, the Central System SHALL respond with a FirmwareStatusNotification.conf. The
        //! FirmwareStatusNotification.req PDUs SHALL be sent to keep the Central System updated with the status of the update process,
        //! started by the Central System with a FirmwareUpdate.req PDU.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const FIRMWARESTATUSNOTIFICATIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:FirmwareStatusNotificationRequest\",\r\n    \"title\": \"FirmwareStatusNotificationRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"status\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"Downloaded\",\r\n                \"DownloadFailed\",\r\n                \"Downloading\",\r\n                \"Idle\",\r\n                \"InstallationFailed\",\r\n                \"Installing\",\r\n                \"Installed\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"status\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct FIRMWARESTATUSNOTIFICATIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static FIRMWARESTATUSNOTIFICATIONREQUEST_JSON: FIRMWARESTATUSNOTIFICATIONREQUEST_JSON =
            FIRMWARESTATUSNOTIFICATIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for FIRMWARESTATUSNOTIFICATIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(FIRMWARESTATUSNOTIFICATIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/FirmwareStatusNotification.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for FIRMWARESTATUSNOTIFICATIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR:
            FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR =
            FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&FIRMWARESTATUSNOTIFICATIONREQUEST_JSON).expect(
                        &{
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Invalid Schema File: "],
                                &[::core::fmt::ArgumentV1::new_display(
                                    &"../json_schemas/FirmwareStatusNotification.json",
                                )],
                            ));
                            res
                        },
                    )
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for FirmwareStatusNotificationRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = FIRMWARESTATUSNOTIFICATIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/firmware_status_notification.rs:18",
                                    "ocpp::point_init::firmware_status_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/firmware_status_notification.rs"),
                                    Some(18u32),
                                    Some("ocpp::point_init::firmware_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/firmware_status_notification.rs:18",
                                    "ocpp::point_init::firmware_status_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/firmware_status_notification.rs"),
                                    Some(18u32),
                                    Some("ocpp::point_init::firmware_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the FirmwareStatusNotifitacion.req PDU sent by the Charge Point to the Central System
        pub struct FirmwareStatusNotificationRequest {
            /// Required. This contains the progress status of the firmware installation.
            pub status: FirmwareNotificationStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FirmwareStatusNotificationRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "FirmwareStatusNotificationRequest",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FirmwareStatusNotificationRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FirmwareStatusNotificationRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FirmwareStatusNotificationRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct FirmwareStatusNotificationRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                FirmwareNotificationStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FirmwareStatusNotificationRequest with 1 element")) ;
                                }
                            };
                            _serde::__private::Ok(FirmwareStatusNotificationRequest {
                                status: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                FirmwareNotificationStatus,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                FirmwareNotificationStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(FirmwareStatusNotificationRequest {
                                status: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "FirmwareStatusNotificationRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                FirmwareStatusNotificationRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for FirmwareStatusNotificationRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "FirmwareStatusNotificationRequest",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for FirmwareStatusNotificationRequest {
            #[inline]
            fn clone(&self) -> FirmwareStatusNotificationRequest {
                FirmwareStatusNotificationRequest {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status of a firmware download as reported in FirmwareStatusNotification.req.
        pub enum FirmwareNotificationStatus {
            /// New firmware has been downloaded by Charge Point.
            Downloaded,
            /// Charge point failed to download firmware.
            DownloadFailed,
            /// Firmware is being downloaded.
            Downloading,
            /// Charge Point is not performing firmware update related tasks. Status Idle SHALL only be used as in a FirmwareStatusNotification.req that was triggered by a TriggerMessage.req
            Idle,
            /// Installation of new firmware has failed.
            InstallationFailed,
            /// Firmware is being installed.
            Installing,
            /// New firmware has successfully been installed in charge point.
            Installed,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FirmwareNotificationStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        FirmwareNotificationStatus::Downloaded => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                0u32,
                                "Downloaded",
                            )
                        }
                        FirmwareNotificationStatus::DownloadFailed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                1u32,
                                "DownloadFailed",
                            )
                        }
                        FirmwareNotificationStatus::Downloading => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                2u32,
                                "Downloading",
                            )
                        }
                        FirmwareNotificationStatus::Idle => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                3u32,
                                "Idle",
                            )
                        }
                        FirmwareNotificationStatus::InstallationFailed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                4u32,
                                "InstallationFailed",
                            )
                        }
                        FirmwareNotificationStatus::Installing => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                5u32,
                                "Installing",
                            )
                        }
                        FirmwareNotificationStatus::Installed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FirmwareNotificationStatus",
                                6u32,
                                "Installed",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FirmwareNotificationStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 7",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Downloaded" => _serde::__private::Ok(__Field::__field0),
                                "DownloadFailed" => _serde::__private::Ok(__Field::__field1),
                                "Downloading" => _serde::__private::Ok(__Field::__field2),
                                "Idle" => _serde::__private::Ok(__Field::__field3),
                                "InstallationFailed" => _serde::__private::Ok(__Field::__field4),
                                "Installing" => _serde::__private::Ok(__Field::__field5),
                                "Installed" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Downloaded" => _serde::__private::Ok(__Field::__field0),
                                b"DownloadFailed" => _serde::__private::Ok(__Field::__field1),
                                b"Downloading" => _serde::__private::Ok(__Field::__field2),
                                b"Idle" => _serde::__private::Ok(__Field::__field3),
                                b"InstallationFailed" => _serde::__private::Ok(__Field::__field4),
                                b"Installing" => _serde::__private::Ok(__Field::__field5),
                                b"Installed" => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FirmwareNotificationStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FirmwareNotificationStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum FirmwareNotificationStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(FirmwareNotificationStatus::Downloaded)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        FirmwareNotificationStatus::DownloadFailed,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(FirmwareNotificationStatus::Downloading)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(FirmwareNotificationStatus::Idle)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        FirmwareNotificationStatus::InstallationFailed,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(FirmwareNotificationStatus::Installing)
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(FirmwareNotificationStatus::Installed)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Downloaded",
                        "DownloadFailed",
                        "Downloading",
                        "Idle",
                        "InstallationFailed",
                        "Installing",
                        "Installed",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "FirmwareNotificationStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<FirmwareNotificationStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for FirmwareNotificationStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&FirmwareNotificationStatus::Downloaded,) => {
                        ::core::fmt::Formatter::write_str(f, "Downloaded")
                    }
                    (&FirmwareNotificationStatus::DownloadFailed,) => {
                        ::core::fmt::Formatter::write_str(f, "DownloadFailed")
                    }
                    (&FirmwareNotificationStatus::Downloading,) => {
                        ::core::fmt::Formatter::write_str(f, "Downloading")
                    }
                    (&FirmwareNotificationStatus::Idle,) => {
                        ::core::fmt::Formatter::write_str(f, "Idle")
                    }
                    (&FirmwareNotificationStatus::InstallationFailed,) => {
                        ::core::fmt::Formatter::write_str(f, "InstallationFailed")
                    }
                    (&FirmwareNotificationStatus::Installing,) => {
                        ::core::fmt::Formatter::write_str(f, "Installing")
                    }
                    (&FirmwareNotificationStatus::Installed,) => {
                        ::core::fmt::Formatter::write_str(f, "Installed")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for FirmwareNotificationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for FirmwareNotificationStatus {
            #[inline]
            fn eq(&self, other: &FirmwareNotificationStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for FirmwareNotificationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for FirmwareNotificationStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for FirmwareNotificationStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    FirmwareNotificationStatus::Downloaded => f.pad("Downloaded"),
                    FirmwareNotificationStatus::DownloadFailed => f.pad("DownloadFailed"),
                    FirmwareNotificationStatus::Downloading => f.pad("Downloading"),
                    FirmwareNotificationStatus::Idle => f.pad("Idle"),
                    FirmwareNotificationStatus::InstallationFailed => f.pad("InstallationFailed"),
                    FirmwareNotificationStatus::Installing => f.pad("Installing"),
                    FirmwareNotificationStatus::Installed => f.pad("Installed"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for FirmwareNotificationStatus {
            #[inline]
            fn clone(&self) -> FirmwareNotificationStatus {
                match (&*self,) {
                    (&FirmwareNotificationStatus::Downloaded,) => {
                        FirmwareNotificationStatus::Downloaded
                    }
                    (&FirmwareNotificationStatus::DownloadFailed,) => {
                        FirmwareNotificationStatus::DownloadFailed
                    }
                    (&FirmwareNotificationStatus::Downloading,) => {
                        FirmwareNotificationStatus::Downloading
                    }
                    (&FirmwareNotificationStatus::Idle,) => FirmwareNotificationStatus::Idle,
                    (&FirmwareNotificationStatus::InstallationFailed,) => {
                        FirmwareNotificationStatus::InstallationFailed
                    }
                    (&FirmwareNotificationStatus::Installing,) => {
                        FirmwareNotificationStatus::Installing
                    }
                    (&FirmwareNotificationStatus::Installed,) => {
                        FirmwareNotificationStatus::Installed
                    }
                }
            }
        }
        const FIRMWARESTATUSNOTIFICATIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"FirmwareStatusNotificationResponse\",\n    \"type\": \"object\",\n    \"properties\": {},\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON: FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON =
            FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(FIRMWARESTATUSNOTIFICATIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/FirmwareStatusNotificationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR:
            FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR =
            FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&FIRMWARESTATUSNOTIFICATIONRESPONSE_JSON)
                        .expect(&{
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["Invalid Schema File: "],
                                &[::core::fmt::ArgumentV1::new_display(
                                    &"../json_schemas/FirmwareStatusNotificationResponse.json",
                                )],
                            ));
                            res
                        })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for FirmwareStatusNotificationResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = FIRMWARESTATUSNOTIFICATIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/firmware_status_notification.rs:47",
                                    "ocpp::point_init::firmware_status_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/firmware_status_notification.rs"),
                                    Some(47u32),
                                    Some("ocpp::point_init::firmware_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/firmware_status_notification.rs:47",
                                    "ocpp::point_init::firmware_status_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/firmware_status_notification.rs"),
                                    Some(47u32),
                                    Some("ocpp::point_init::firmware_status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the FirmwareStatusNotification.conf PDU sent by the Central System to the Charge Point in response to a FirmwareStatusNotification.req PDU.
        pub struct FirmwareStatusNotificationResponse {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FirmwareStatusNotificationResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "FirmwareStatusNotificationResponse",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FirmwareStatusNotificationResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FirmwareStatusNotificationResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FirmwareStatusNotificationResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct FirmwareStatusNotificationResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(FirmwareStatusNotificationResponse {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(FirmwareStatusNotificationResponse {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "FirmwareStatusNotificationResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                FirmwareStatusNotificationResponse,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for FirmwareStatusNotificationResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "FirmwareStatusNotificationResponse")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for FirmwareStatusNotificationResponse {
            #[inline]
            fn clone(&self) -> FirmwareStatusNotificationResponse {
                FirmwareStatusNotificationResponse {}
            }
        }
    }
    pub mod heartbeat {
        //! Configurable ping to verify charge point is still connected.
        //! # Behaviour
        //! The Charge Point SHALL send a Heartbeat.req PDU for ensuring that the Central System knows that a Charge Point is still alive.
        //! Upon receipt of a Heartbeat.req PDU, the Central System SHALL respond with a Heartbeat.conf.
        //!
        //! # Response
        //! The response PDU SHALL contain the current time of the Central System, which is RECOMMENDED to be used by the Charge Point to synchronize its internal clock.
        //! The Charge Point MAY skip sending a Heartbeat.req PDU when another PDU has been sent to the Central System within the configured heartbeat interval. This implies that a Central System SHOULD assume availability
        //! of a Charge Point whenever a PDU has been received, the same way as it would have, when it received a Heartbeat.req PDU.
        //!
        //! With JSON over WebSocket, sending heartbeats is not mandatory. However, for time synchronization it is advised to at least send one heartbeat per 24 hour.
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use crate::validation_macros::{self, json_validate};
        const HEARTBEATREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:HeartbeatRequest\",\r\n    \"title\": \"HeartbeatRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {},\r\n    \"additionalProperties\": false\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct HEARTBEATREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static HEARTBEATREQUEST_JSON: HEARTBEATREQUEST_JSON = HEARTBEATREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for HEARTBEATREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(HEARTBEATREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/Heartbeat.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for HEARTBEATREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct HEARTBEATREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static HEARTBEATREQUEST_VALIDATOR: HEARTBEATREQUEST_VALIDATOR =
            HEARTBEATREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for HEARTBEATREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&HEARTBEATREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/Heartbeat.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for HEARTBEATREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for HeartbeatRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = HEARTBEATREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/heartbeat.rs:18",
                                    "ocpp::point_init::heartbeat",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/heartbeat.rs"),
                                    Some(18u32),
                                    Some("ocpp::point_init::heartbeat"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/heartbeat.rs:18",
                                    "ocpp::point_init::heartbeat",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/heartbeat.rs"),
                                    Some(18u32),
                                    Some("ocpp::point_init::heartbeat"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the Heartbeat.req PDU sent by the Charge Point to the Central System.
        pub struct HeartbeatRequest {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for HeartbeatRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "HeartbeatRequest",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HeartbeatRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<HeartbeatRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HeartbeatRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct HeartbeatRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(HeartbeatRequest {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(HeartbeatRequest {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HeartbeatRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<HeartbeatRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for HeartbeatRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "HeartbeatRequest")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for HeartbeatRequest {
            #[inline]
            fn clone(&self) -> HeartbeatRequest {
                HeartbeatRequest {}
            }
        }
        const HEARTBEATRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"HeartbeatResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"currentTime\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"currentTime\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct HEARTBEATRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static HEARTBEATRESPONSE_JSON: HEARTBEATRESPONSE_JSON = HEARTBEATRESPONSE_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for HEARTBEATRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(HEARTBEATRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/HeartbeatResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for HEARTBEATRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct HEARTBEATRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static HEARTBEATRESPONSE_VALIDATOR: HEARTBEATRESPONSE_VALIDATOR =
            HEARTBEATRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for HEARTBEATRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&HEARTBEATRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/HeartbeatResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for HEARTBEATRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for HeartbeatResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = HEARTBEATRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/heartbeat.rs:25",
                                    "ocpp::point_init::heartbeat",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/heartbeat.rs"),
                                    Some(25u32),
                                    Some("ocpp::point_init::heartbeat"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/heartbeat.rs:25",
                                    "ocpp::point_init::heartbeat",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/heartbeat.rs"),
                                    Some(25u32),
                                    Some("ocpp::point_init::heartbeat"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the Heartbeat.conf PDU sent by the Central System to the Charge Point in response to a Heartbeat.req PDU.
        pub struct HeartbeatResponse {
            /// Required. This contains the current time of the Central System.
            pub current_time: DateTime<Utc>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for HeartbeatResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "HeartbeatResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "currentTime",
                        &self.current_time,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for HeartbeatResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "currentTime" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"currentTime" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<HeartbeatResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = HeartbeatResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct HeartbeatResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                DateTime<Utc>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct HeartbeatResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(HeartbeatResponse {
                                current_time: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<DateTime<Utc>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "currentTime",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<DateTime<Utc>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("currentTime") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(HeartbeatResponse {
                                current_time: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["currentTime"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "HeartbeatResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<HeartbeatResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for HeartbeatResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "HeartbeatResponse",
                    "current_time",
                    &&self.current_time,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for HeartbeatResponse {
            #[inline]
            fn clone(&self) -> HeartbeatResponse {
                HeartbeatResponse {
                    current_time: ::core::clone::Clone::clone(&self.current_time),
                }
            }
        }
    }
    pub mod meter_values {
        //! A set of sampled data from the charge point denoting a series of measurements over a period of time.
        //!
        //! # Structure
        //! connectorId u32
        //! transactonId u32
        //! meterValue Vec<obj>
        //!     timestamp dateTime<utc>
        //!     sampledValue Vec<obj>
        //!         value Str
        //!         context enum String
        //!         format enum String
        //!         measurand enum String
        //!         phase enum String
        //!         location enum String
        //!         unit enum String
        //!
        //! # Behaviour
        //! It is up to the Charge Point to decide when it will send meter values. This can be configured using the ChangeConfiguration.req message to data
        //! acquisition intervals and specify data to be acquired & reported.The Charge Point SHALL send a MeterValues.req PDU for offloading meter values.
        //! The request PDU SHALL contain for each sample:
        //!
        //! 1. The id of the Connector from which samples were taken. If the connectorId is 0, it is associated with the entire Charge Point. If the connectorId
        //!  is 0 and the Measurand is energy related, the sample SHOULD be taken from the main energy meter.
        //! 2. The transactionId of the transaction to which these values are related, if applicable. If there is no transaction in progress or if the values are
        //!  taken from the main meter, then transaction id may be omitted.
        //! 3. One or more meterValue elements, of type MeterValue, each representing a set of one or more data values taken at a particular point in time.
        //!
        //! Each MeterValue element contains a timestamp and a set of one or more individual sampledvalue elements, all captured at the same point in time.
        //!
        //! Each sampledValue element contains a single value datum. The nature of each sampledValue is determined by the optional measurand, context, location, unit, phase, and format fields.
        //!
        //! Two measurands (Current.Offered and Power.Offered) are available that are strictly speaking no measured values. They indicate the maximum amount of current/power that is being offered to the EV and are intended for use in smart charging applications.
        //!
        //! For individual connector phase rotation information, the Central System MAY query the ConnectorPhaseRotation configuration key on the Charging Point via GetConfiguration. The Charge Point SHALL report the phase rotation in respect to the grid connection.
        //! Possible values per connector are: 36NotApplicable, Unknown, RST, RTS, SRT, STR, TRS and TSR. see section Standard Configuration Key Names & Values for more information.
        //!
        //! The EXPERIMENTAL optional format field specifies whether the data is represented in the normal (default) form as a simple numeric value ("Raw"), or as SignedData, an opaque digitally signed binary data block, represented as hex data.
        //! This experimental field may be deprecated and subsequently removed in later versions, when a more mature solution alternative is provided.
        //!
        //! To retain backward compatibility, the default values of all of the optional fields on a sampledValue element are such that a value without any additional fields will be interpreted, as a register reading of active import energy in Wh (Watt-hour) units.
        //! # Response
        //! Upon receipt of a MeterValues.req PDU, the Central System SHALL respond with a MeterValues.conf.
        //! It is likely that The Central System applies sanity checks to the data contained in a MeterValues.req it received.
        //! The outcome of such sanity checks SHOULD NOT ever cause the Central System to not respond with a MeterValues.conf. Failing to respond with a MeterValues.conf will only cause the Charge Point to try the same message again as specified in Error responses to transaction-related messages.
        use crate::validation_macros::{self, json_validate};
        pub use crate::MeterValue;
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const METERVALUESREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:MeterValuesRequest\",\r\n    \"title\": \"MeterValuesRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"transactionId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"meterValue\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": \"object\",\r\n                \"properties\": {\r\n                    \"timestamp\": {\r\n                        \"type\": \"string\",\r\n                        \"format\": \"date-time\"\r\n                    },\r\n                    \"sampledValue\": {\r\n                        \"type\": \"array\",\r\n                        \"items\": {\r\n                            \"type\": \"object\",\r\n                            \"properties\": {\r\n                                \"value\": {\r\n                                    \"type\": \"string\"\r\n                                },\r\n                                \"context\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Interruption.Begin\",\r\n                                        \"Interruption.End\",\r\n                                        \"Sample.Clock\",\r\n                                        \"Sample.Periodic\",\r\n                                        \"Transaction.Begin\",\r\n                                        \"Transaction.End\",\r\n                                        \"Trigger\",\r\n                                        \"Other\"\r\n                                    ]\r\n                                },\r\n                                \"format\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Raw\",\r\n                                        \"SignedData\"\r\n                                    ]\r\n                                },\r\n                                \"measurand\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Energy.Active.Export.Register\",\r\n                                        \"Energy.Active.Import.Register\",\r\n                                        \"Energy.Reactive.Export.Register\",\r\n                                        \"Energy.Reactive.Import.Register\",\r\n                                        \"Energy.Active.Export.Interval\",\r\n                                        \"Energy.Active.Import.Interval\",\r\n                                        \"Energy.Reactive.Export.Interval\",\r\n                                        \"Energy.Reactive.Import.Interval\",\r\n                                        \"Power.Active.Export\",\r\n                                        \"Power.Active.Import\",\r\n                                        \"Power.Offered\",\r\n                                        \"Power.Reactive.Export\",\r\n                                        \"Power.Reactive.Import\",\r\n                                        \"Power.Factor\",\r\n                                        \"Current.Import\",\r\n                                        \"Current.Export\",\r\n                                        \"Current.Offered\",\r\n                                        \"Voltage\",\r\n                                        \"Frequency\",\r\n                                        \"Temperature\",\r\n                                        \"SoC\",\r\n                                        \"RPM\"\r\n                                    ]\r\n                                },\r\n                                \"phase\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"L1\",\r\n                                        \"L2\",\r\n                                        \"L3\",\r\n                                        \"N\",\r\n                                        \"L1-N\",\r\n                                        \"L2-N\",\r\n                                        \"L3-N\",\r\n                                        \"L1-L2\",\r\n                                        \"L2-L3\",\r\n                                        \"L3-L1\"\r\n                                    ]\r\n                                },\r\n                                \"location\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Cable\",\r\n                                        \"EV\",\r\n                                        \"Inlet\",\r\n                                        \"Outlet\",\r\n                                        \"Body\"\r\n                                    ]\r\n                                },\r\n                                \"unit\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Wh\",\r\n                                        \"kWh\",\r\n                                        \"varh\",\r\n                                        \"kvarh\",\r\n                                        \"W\",\r\n                                        \"kW\",\r\n                                        \"VA\",\r\n                                        \"kVA\",\r\n                                        \"var\",\r\n                                        \"kvar\",\r\n                                        \"A\",\r\n                                        \"V\",\r\n                                        \"K\",\r\n                                        \"Celcius\",\r\n                                        \"Celsius\",\r\n                                        \"Fahrenheit\",\r\n                                        \"Percent\"\r\n                                    ]\r\n                                }\r\n                            },\r\n                            \"additionalProperties\": false,\r\n                            \"required\": [\r\n                                \"value\"\r\n                            ]\r\n                        }\r\n                    }\r\n                },\r\n                \"additionalProperties\": false,\r\n                \"required\": [\r\n                    \"timestamp\",\r\n                    \"sampledValue\"\r\n                ]       \r\n            }\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\",\r\n        \"meterValue\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct METERVALUESREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static METERVALUESREQUEST_JSON: METERVALUESREQUEST_JSON = METERVALUESREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for METERVALUESREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(METERVALUESREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/MeterValues.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for METERVALUESREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct METERVALUESREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static METERVALUESREQUEST_VALIDATOR: METERVALUESREQUEST_VALIDATOR =
            METERVALUESREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for METERVALUESREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&METERVALUESREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/MeterValues.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for METERVALUESREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for MeterValuesRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = METERVALUESREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/meter_values.rs:52",
                                    "ocpp::point_init::meter_values",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/meter_values.rs"),
                                    Some(52u32),
                                    Some("ocpp::point_init::meter_values"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/meter_values.rs:52",
                                    "ocpp::point_init::meter_values",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/meter_values.rs"),
                                    Some(52u32),
                                    Some("ocpp::point_init::meter_values"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the MeterValues.req PDU sent by the Charge Point to the Central System.
        pub struct MeterValuesRequest {
            /// Required. This contains a number (>0) designating a connector of the ChargePoint.0 (zero) is used to designate the main powermeter.
            pub connector_id: u32,
            /// Optional. The transaction to which these meter samples are related.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub transaction_id: Option<u32>,
            /// Required. The sampled meter values with timestamps.
            pub meter_value: Vec<MeterValue>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MeterValuesRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "MeterValuesRequest",
                        false as usize
                            + 1
                            + if Option::is_none(&self.transaction_id) {
                                0
                            } else {
                                1
                            }
                            + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.transaction_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "transactionId",
                            &self.transaction_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "transactionId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "meterValue",
                        &self.meter_value,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MeterValuesRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "transactionId" => _serde::__private::Ok(__Field::__field1),
                                "meterValue" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"transactionId" => _serde::__private::Ok(__Field::__field1),
                                b"meterValue" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MeterValuesRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MeterValuesRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MeterValuesRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MeterValuesRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MeterValuesRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Vec<MeterValue>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct MeterValuesRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MeterValuesRequest {
                                connector_id: __field0,
                                transaction_id: __field1,
                                meter_value: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Vec<MeterValue>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transactionId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "meterValue",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<MeterValue>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("transactionId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("meterValue") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(MeterValuesRequest {
                                connector_id: __field0,
                                transaction_id: __field1,
                                meter_value: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["connectorId", "transactionId", "meterValue"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MeterValuesRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MeterValuesRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MeterValuesRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "MeterValuesRequest",
                    "connector_id",
                    &&self.connector_id,
                    "transaction_id",
                    &&self.transaction_id,
                    "meter_value",
                    &&self.meter_value,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MeterValuesRequest {
            #[inline]
            fn clone(&self) -> MeterValuesRequest {
                MeterValuesRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    transaction_id: ::core::clone::Clone::clone(&self.transaction_id),
                    meter_value: ::core::clone::Clone::clone(&self.meter_value),
                }
            }
        }
        const METERVALUESRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"MeterValuesResponse\",\n    \"type\": \"object\",\n    \"properties\": {},\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct METERVALUESRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static METERVALUESRESPONSE_JSON: METERVALUESRESPONSE_JSON = METERVALUESRESPONSE_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for METERVALUESRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(METERVALUESRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/MeterValuesResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for METERVALUESRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct METERVALUESRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static METERVALUESRESPONSE_VALIDATOR: METERVALUESRESPONSE_VALIDATOR =
            METERVALUESRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for METERVALUESRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&METERVALUESRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/MeterValuesResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for METERVALUESRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for MeterValuesResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = METERVALUESRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/meter_values.rs:67",
                                    "ocpp::point_init::meter_values",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/meter_values.rs"),
                                    Some(67u32),
                                    Some("ocpp::point_init::meter_values"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/meter_values.rs:67",
                                    "ocpp::point_init::meter_values",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/meter_values.rs"),
                                    Some(67u32),
                                    Some("ocpp::point_init::meter_values"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the MeterValues.conf PDU sent by the Central System to the Charge Point in response to a MeterValues.req PDU.
        pub struct MeterValuesResponse {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MeterValuesResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "MeterValuesResponse",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MeterValuesResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MeterValuesResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MeterValuesResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MeterValuesResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(MeterValuesResponse {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(MeterValuesResponse {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MeterValuesResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MeterValuesResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MeterValuesResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "MeterValuesResponse")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MeterValuesResponse {
            #[inline]
            fn clone(&self) -> MeterValuesResponse {
                MeterValuesResponse {}
            }
        }
    }
    pub mod start_transaction {
        //! Request from chargepoint to begin an energy transaction. Must be sent before charging will begin.
        //!
        //! # Behaviour
        //! If this transaction ends a reservation (see Reserve Now operation), then the StartTransaction.req MUST contain the reservationId.
        //! If Charge Point has implemented an Authorization Cache, then upon receipt of a StartTransaction.conf PDU the Charge Point SHALL update the cache
        //! entry, if the idTag is not in the Local Authorization List, with the IdTagInfo value from the response as described under Authorization Cache.
        //!  
        //! # Response
        //! Upon receipt of a StartTransaction.req PDU, the Central System SHOULD respond with a StartTransaction.conf PDU. This response PDU MUST include a transaction
        //! id and an authorization status value. The Central System MUST verify validity of the identifier in the StartTransaction.req PDU, because the
        //! identifier might have been authorized locally by the Charge Point using outdated information. The identifier, for instance, may have been blocked
        //! since it was added to the Charge Points Authorization Cache.
        //!
        //! It is likely that The Central System applies sanity checks to the data contained in a StartTransaction.req it received. The outcome of such sanity
        //! checks SHOULD NOT ever cause the Central System to not respond with a StartTransaction.conf. Failing to respond with a StartTransaction.conf will
        //! only cause the Charge Point to try the same message again as specified in Error responses to transaction-related messages.
        pub use crate::common_types::IdTagInfo;
        use crate::validation_macros::{self, json_validate};
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const STARTTRANSACTIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:StartTransactionRequest\",\r\n    \"title\": \"StartTransactionRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"idTag\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"meterStart\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"reservationId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"timestamp\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\",\r\n        \"idTag\",\r\n        \"meterStart\",\r\n        \"timestamp\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STARTTRANSACTIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static STARTTRANSACTIONREQUEST_JSON: STARTTRANSACTIONREQUEST_JSON =
            STARTTRANSACTIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STARTTRANSACTIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(STARTTRANSACTIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StartTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STARTTRANSACTIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STARTTRANSACTIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static STARTTRANSACTIONREQUEST_VALIDATOR: STARTTRANSACTIONREQUEST_VALIDATOR =
            STARTTRANSACTIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STARTTRANSACTIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&STARTTRANSACTIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StartTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STARTTRANSACTIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for StartTransactionRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = STARTTRANSACTIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/start_transaction.rs:25",
                                    "ocpp::point_init::start_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/start_transaction.rs"),
                                    Some(25u32),
                                    Some("ocpp::point_init::start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/start_transaction.rs:25",
                                    "ocpp::point_init::start_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/start_transaction.rs"),
                                    Some(25u32),
                                    Some("ocpp::point_init::start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the StartTransaction.req PDU sent by the Charge Point to the Central System
        pub struct StartTransactionRequest {
            /// Required. This identifies which connector of the Charge Point is used.
            pub connector_id: u32,
            /// Required. This contains the identifier for which a transaction has to be started.
            pub id_tag: String,
            /// Required. This contains the meter value in Wh for the connector at start of the transaction
            pub meter_start: i32,
            /// Optional. This contains the id of the reservation that terminates as a result of this transaction.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub reservation_id: Option<i32>,
            /// Required. This contains the date and time on which the transaction is started.
            pub timestamp: DateTime<Utc>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StartTransactionRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "StartTransactionRequest",
                        false as usize
                            + 1
                            + 1
                            + 1
                            + if Option::is_none(&self.reservation_id) {
                                0
                            } else {
                                1
                            }
                            + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "idTag",
                        &self.id_tag,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "meterStart",
                        &self.meter_start,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.reservation_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "reservationId",
                            &self.reservation_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "reservationId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "timestamp",
                        &self.timestamp,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StartTransactionRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "idTag" => _serde::__private::Ok(__Field::__field1),
                                "meterStart" => _serde::__private::Ok(__Field::__field2),
                                "reservationId" => _serde::__private::Ok(__Field::__field3),
                                "timestamp" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"idTag" => _serde::__private::Ok(__Field::__field1),
                                b"meterStart" => _serde::__private::Ok(__Field::__field2),
                                b"reservationId" => _serde::__private::Ok(__Field::__field3),
                                b"timestamp" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StartTransactionRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StartTransactionRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StartTransactionRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StartTransactionRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct StartTransactionRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<i32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct StartTransactionRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<i32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct StartTransactionRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                DateTime<Utc>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct StartTransactionRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StartTransactionRequest {
                                connector_id: __field0,
                                id_tag: __field1,
                                meter_start: __field2,
                                reservation_id: __field3,
                                timestamp: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<i32> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<i32>> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<DateTime<Utc>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTag",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "meterStart",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<i32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reservationId",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<i32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timestamp",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<DateTime<Utc>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTag") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("meterStart") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("reservationId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("timestamp") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(StartTransactionRequest {
                                connector_id: __field0,
                                id_tag: __field1,
                                meter_start: __field2,
                                reservation_id: __field3,
                                timestamp: __field4,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "connectorId",
                        "idTag",
                        "meterStart",
                        "reservationId",
                        "timestamp",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StartTransactionRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StartTransactionRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StartTransactionRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "StartTransactionRequest",
                    "connector_id",
                    &&self.connector_id,
                    "id_tag",
                    &&self.id_tag,
                    "meter_start",
                    &&self.meter_start,
                    "reservation_id",
                    &&self.reservation_id,
                    "timestamp",
                    &&self.timestamp,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StartTransactionRequest {
            #[inline]
            fn clone(&self) -> StartTransactionRequest {
                StartTransactionRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    id_tag: ::core::clone::Clone::clone(&self.id_tag),
                    meter_start: ::core::clone::Clone::clone(&self.meter_start),
                    reservation_id: ::core::clone::Clone::clone(&self.reservation_id),
                    timestamp: ::core::clone::Clone::clone(&self.timestamp),
                }
            }
        }
        const STARTTRANSACTIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"StartTransactionResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"idTagInfo\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"expiryDate\": {\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"parentIdTag\": {\n                    \"type\": \"string\",\n                    \"maxLength\": 20\n                },\n                \"status\": {\n                    \"type\": \"string\",\n                    \"additionalProperties\": false,\n                    \"enum\": [\n                        \"Accepted\",\n                        \"Blocked\",\n                        \"Expired\",\n                        \"Invalid\",\n                        \"ConcurrentTx\"\n                    ]\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"status\"\n            ]\n        },\n        \"transactionId\": {\n            \"type\": \"integer\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"idTagInfo\",\n        \"transactionId\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STARTTRANSACTIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static STARTTRANSACTIONRESPONSE_JSON: STARTTRANSACTIONRESPONSE_JSON =
            STARTTRANSACTIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STARTTRANSACTIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(STARTTRANSACTIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StartTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STARTTRANSACTIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STARTTRANSACTIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static STARTTRANSACTIONRESPONSE_VALIDATOR: STARTTRANSACTIONRESPONSE_VALIDATOR =
            STARTTRANSACTIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STARTTRANSACTIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&STARTTRANSACTIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StartTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STARTTRANSACTIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for StartTransactionResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = STARTTRANSACTIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/start_transaction.rs:44",
                                    "ocpp::point_init::start_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/start_transaction.rs"),
                                    Some(44u32),
                                    Some("ocpp::point_init::start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/start_transaction.rs:44",
                                    "ocpp::point_init::start_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/start_transaction.rs"),
                                    Some(44u32),
                                    Some("ocpp::point_init::start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the StartTransaction.conf PDU sent by the Central System to the Charge Point in response to a StartTransaction.req PDU.
        pub struct StartTransactionResponse {
            /// Required. This contains information about authorization status, expiry and parent id
            pub id_tag_info: IdTagInfo,
            /// Required. This contains the transaction id supplied by the Central System.
            pub transaction_id: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StartTransactionResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "StartTransactionResponse",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "idTagInfo",
                        &self.id_tag_info,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "transactionId",
                        &self.transaction_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StartTransactionResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "idTagInfo" => _serde::__private::Ok(__Field::__field0),
                                "transactionId" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"idTagInfo" => _serde::__private::Ok(__Field::__field0),
                                b"transactionId" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StartTransactionResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StartTransactionResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StartTransactionResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                IdTagInfo,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StartTransactionResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct StartTransactionResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StartTransactionResponse {
                                id_tag_info: __field0,
                                transaction_id: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<IdTagInfo> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTagInfo",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<IdTagInfo>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transactionId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTagInfo") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("transactionId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(StartTransactionResponse {
                                id_tag_info: __field0,
                                transaction_id: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["idTagInfo", "transactionId"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StartTransactionResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StartTransactionResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StartTransactionResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "StartTransactionResponse",
                    "id_tag_info",
                    &&self.id_tag_info,
                    "transaction_id",
                    &&self.transaction_id,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StartTransactionResponse {
            #[inline]
            fn clone(&self) -> StartTransactionResponse {
                StartTransactionResponse {
                    id_tag_info: ::core::clone::Clone::clone(&self.id_tag_info),
                    transaction_id: ::core::clone::Clone::clone(&self.transaction_id),
                }
            }
        }
    }
    pub mod status_notification {
        //! A notification is sent when a connector changes status or the chargepoint has an error.
        //!
        //! # Behaviour
        //! When a Charge Point connects to a Central System after having been offline, it updates the Central System about its status according to the following rules:
        //! 1. The Charge Point SHOULD send a StatusNotification.req PDU with its current status if the status changed while the Charge Point was offline.
        //! 2. The Charge Point MAY send a StatusNotification.req PDU to report an error that occurred while the Charge Point was offline.
        //! 3. The Charge Point SHOULD NOT send StatusNotification.req PDUs for historical status change events that happened while the Charge Point was offline
        //! and that do not inform the Central System of Charge Point errors or the Charge Points current status.
        //! 4. The StatusNotification.req messages MUST be sent in the order in which the events that they describe occurred.
        //!
        //! To limit the number of transitions, the Charge Point MAY omit sending a StatusNotification.req if it was active for
        //! less time than defined in the optional configuration key MinimumStatusDuration. This way, a Charge Point MAY choose
        //! not to send certain StatusNotification.req PDUs.
        //!
        //! A Charge Point manufacturer MAY have implemented a minimal status duration for certain status transitions separate of the
        //! MinimumStatusDuration setting. The time set in MinimumStatusDuration will be added to this default delay. Setting MinimumStatusDuration
        //! to zero SHALL NOT override the default manufacturers minimal status duration.
        //!
        //! The Charge Point MAY send a StatusNotification.req PDU to inform the Central System of fault conditions. When the 'status' field is not
        //! Faulted, the condition should be considered a warning since charging operations are still possible.
        //!
        //! # StopTransactionOnEvSideDisconnect
        //! When a Charge Point is configured with StopTransactionOnEVSideDisconnect set to false, a transaction is running and the EV becomes disconnected on
        //! EV side, then a StatusNotification.req with the state: SuspendedEV SHOULD be send to the Central System, with the 'errorCode' field set to: 'NoError'.
        //! The Charge Point SHOULD add additional information in the 'info' field, Notifying the Central System with the reason of suspension: 'EV side disconnected'. The current transaction is not stopped.
        //!
        //! When a Charge Point is configured with StopTransactionOnEVSideDisconnect set to true, a transaction is running and the EV becomes disconnected on
        //! EV side, then a StatusNotification.req with the state: 'Finishing' SHOULD be send to the Central System, with the 'errorCode' field set to: 'NoError'.
        //! The Charge Point SHOULD add additional information in the 'info' field, Notifying the Central System with the reason of stopping: 'EV side disconnected'. The current transaction is stopped.
        //!
        //! # Response
        //! Upon receipt of a StatusNotification.req PDU, the Central System SHALL respond with a StatusNotification.conf PDU.
        use crate::validation_macros::{self, json_validate};
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        const STATUSNOTIFICATIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:StatusNotificationRequest\",\r\n    \"title\": \"StatusNotificationRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"errorCode\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"ConnectorLockFailure\",\r\n                \"EVCommunicationError\",\r\n                \"GroundFailure\",\r\n                \"HighTemperature\",\r\n                \"InternalError\",\r\n                \"LocalListConflict\",\r\n                \"NoError\",\r\n                \"OtherError\",\r\n                \"OverCurrentFailure\",\r\n                \"PowerMeterFailure\",\r\n                \"PowerSwitchFailure\",\r\n                \"ReaderFailure\",\r\n                \"ResetFailure\",\r\n                \"UnderVoltage\",\r\n                \"OverVoltage\",\r\n                \"WeakSignal\"\r\n            ]\r\n        },\r\n        \"info\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50\r\n        },\r\n        \"status\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"Available\",\r\n                \"Preparing\",\r\n                \"Charging\",\r\n                \"SuspendedEVSE\",\r\n                \"SuspendedEV\",\r\n                \"Finishing\",\r\n                \"Reserved\",\r\n                \"Unavailable\",\r\n                \"Faulted\"\r\n            ]\r\n        },\r\n        \"timestamp\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n        },\r\n        \"vendorId\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 255\r\n        },\r\n        \"vendorErrorCode\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\",\r\n        \"errorCode\",\r\n        \"status\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STATUSNOTIFICATIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static STATUSNOTIFICATIONREQUEST_JSON: STATUSNOTIFICATIONREQUEST_JSON =
            STATUSNOTIFICATIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STATUSNOTIFICATIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(STATUSNOTIFICATIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StatusNotification.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STATUSNOTIFICATIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STATUSNOTIFICATIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static STATUSNOTIFICATIONREQUEST_VALIDATOR: STATUSNOTIFICATIONREQUEST_VALIDATOR =
            STATUSNOTIFICATIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STATUSNOTIFICATIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&STATUSNOTIFICATIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StatusNotification.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STATUSNOTIFICATIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for StatusNotificationRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = STATUSNOTIFICATIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/status_notification.rs:41",
                                    "ocpp::point_init::status_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/status_notification.rs"),
                                    Some(41u32),
                                    Some("ocpp::point_init::status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/status_notification.rs:41",
                                    "ocpp::point_init::status_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/status_notification.rs"),
                                    Some(41u32),
                                    Some("ocpp::point_init::status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the StatusNotification.req PDU sent by the Charge Point to the Central System.
        pub struct StatusNotificationRequest {
            /// Required. The id of the connector for which the status is reported. Id '0' (zero) is used if the status is for the Charge Point main controller
            pub connector_id: u32,
            /// Required. This contains the error code reported by the Charge Point.
            pub error_code: StatusNotificationErrorCode,
            /// Optional. Additional free format information related to the error.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub info: Option<String>,
            /// Required. This contains the current status of the Charge Point.
            pub status: StatusNotificationStatus,
            /// Optional. The time for which the status is reported. If absent time of receipt of the message will be assumed.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub timestamp: Option<DateTime<Utc>>,
            /// Optional. This identifies the vendor-specific implementation.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub vendor_id: Option<String>,
            /// Optional. This contains the vendor-specific error code.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub vendor_error_code: Option<String>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StatusNotificationRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "StatusNotificationRequest",
                        false as usize
                            + 1
                            + 1
                            + if Option::is_none(&self.info) { 0 } else { 1 }
                            + 1
                            + if Option::is_none(&self.timestamp) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.vendor_id) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.vendor_error_code) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "errorCode",
                        &self.error_code,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.info) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "info",
                            &self.info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "info") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.timestamp) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "timestamp",
                            &self.timestamp,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "timestamp",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.vendor_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "vendorId",
                            &self.vendor_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "vendorId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.vendor_error_code) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "vendorErrorCode",
                            &self.vendor_error_code,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "vendorErrorCode",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StatusNotificationRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "errorCode" => _serde::__private::Ok(__Field::__field1),
                                "info" => _serde::__private::Ok(__Field::__field2),
                                "status" => _serde::__private::Ok(__Field::__field3),
                                "timestamp" => _serde::__private::Ok(__Field::__field4),
                                "vendorId" => _serde::__private::Ok(__Field::__field5),
                                "vendorErrorCode" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"errorCode" => _serde::__private::Ok(__Field::__field1),
                                b"info" => _serde::__private::Ok(__Field::__field2),
                                b"status" => _serde::__private::Ok(__Field::__field3),
                                b"timestamp" => _serde::__private::Ok(__Field::__field4),
                                b"vendorId" => _serde::__private::Ok(__Field::__field5),
                                b"vendorErrorCode" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StatusNotificationRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StatusNotificationRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StatusNotificationRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                StatusNotificationErrorCode,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                StatusNotificationStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct StatusNotificationRequest with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StatusNotificationRequest {
                                connector_id: __field0,
                                error_code: __field1,
                                info: __field2,
                                status: __field3,
                                timestamp: __field4,
                                vendor_id: __field5,
                                vendor_error_code: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                StatusNotificationErrorCode,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<StatusNotificationStatus> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "errorCode",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                StatusNotificationErrorCode,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "info",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                StatusNotificationStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timestamp",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "vendorId",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "vendorErrorCode",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("errorCode") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("info") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("timestamp") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("vendorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("vendorErrorCode") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(StatusNotificationRequest {
                                connector_id: __field0,
                                error_code: __field1,
                                info: __field2,
                                status: __field3,
                                timestamp: __field4,
                                vendor_id: __field5,
                                vendor_error_code: __field6,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "connectorId",
                        "errorCode",
                        "info",
                        "status",
                        "timestamp",
                        "vendorId",
                        "vendorErrorCode",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StatusNotificationRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StatusNotificationRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StatusNotificationRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                {
                    let names: &'static _ = &[
                        "connector_id",
                        "error_code",
                        "info",
                        "status",
                        "timestamp",
                        "vendor_id",
                        "vendor_error_code",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.connector_id,
                        &&self.error_code,
                        &&self.info,
                        &&self.status,
                        &&self.timestamp,
                        &&self.vendor_id,
                        &&self.vendor_error_code,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StatusNotificationRequest",
                        names,
                        values,
                    )
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StatusNotificationRequest {
            #[inline]
            fn clone(&self) -> StatusNotificationRequest {
                StatusNotificationRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    error_code: ::core::clone::Clone::clone(&self.error_code),
                    info: ::core::clone::Clone::clone(&self.info),
                    status: ::core::clone::Clone::clone(&self.status),
                    timestamp: ::core::clone::Clone::clone(&self.timestamp),
                    vendor_id: ::core::clone::Clone::clone(&self.vendor_id),
                    vendor_error_code: ::core::clone::Clone::clone(&self.vendor_error_code),
                }
            }
        }
        /// Charge Point Error Code reported in StatusNotification.req.
        pub enum StatusNotificationErrorCode {
            /// Failure to lock or unlock connector.
            ConnectorLockFailure,
            /// Communication failure with the vehicle, might be Mode 3 or other communication protocol problem. This is not a real error in the sense that
            /// the Charge Point doesnt need to go to the faulted state. Instead, it should go to the SuspendedEVSE state.
            EVCommunicationError,
            /// Ground fault circuit interrupter has been activated.
            GroundFailure,
            /// Temperature inside Charge Point is too high.
            HighTemperature,
            /// Error in internal hard- or software component.
            InternalError,
            /// The authorization information received from the Central System is in conflict with the LocalAuthorizationList.
            LocalListConflict,
            /// No error to report.
            NoError,
            /// Other type of error. More information in vendorErrorCode.
            OtherError,
            /// Over current protection device has tripped.
            OverCurrentFailure,
            /// Failure to read electrical/energy/power meter.
            PowerMeterFailure,
            /// Failure to read electrical/energy/power meter.
            PowerSwitchFailure,
            /// Failure with idTag reader.
            ReaderFailure,
            /// Unable to perform a reset.
            ResetFailure,
            /// Voltage has dropped below an acceptable level.
            UnderVoltage,
            /// Voltage has risen above an acceptable level.
            OverVoltage,
            /// Wireless communication device reports a weak signal.
            WeakSignal,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StatusNotificationErrorCode {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        StatusNotificationErrorCode::ConnectorLockFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                0u32,
                                "ConnectorLockFailure",
                            )
                        }
                        StatusNotificationErrorCode::EVCommunicationError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                1u32,
                                "EVCommunicationError",
                            )
                        }
                        StatusNotificationErrorCode::GroundFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                2u32,
                                "GroundFailure",
                            )
                        }
                        StatusNotificationErrorCode::HighTemperature => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                3u32,
                                "HighTemperature",
                            )
                        }
                        StatusNotificationErrorCode::InternalError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                4u32,
                                "InternalError",
                            )
                        }
                        StatusNotificationErrorCode::LocalListConflict => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                5u32,
                                "LocalListConflict",
                            )
                        }
                        StatusNotificationErrorCode::NoError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                6u32,
                                "NoError",
                            )
                        }
                        StatusNotificationErrorCode::OtherError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                7u32,
                                "OtherError",
                            )
                        }
                        StatusNotificationErrorCode::OverCurrentFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                8u32,
                                "OverCurrentFailure",
                            )
                        }
                        StatusNotificationErrorCode::PowerMeterFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                9u32,
                                "PowerMeterFailure",
                            )
                        }
                        StatusNotificationErrorCode::PowerSwitchFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                10u32,
                                "PowerSwitchFailure",
                            )
                        }
                        StatusNotificationErrorCode::ReaderFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                11u32,
                                "ReaderFailure",
                            )
                        }
                        StatusNotificationErrorCode::ResetFailure => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                12u32,
                                "ResetFailure",
                            )
                        }
                        StatusNotificationErrorCode::UnderVoltage => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                13u32,
                                "UnderVoltage",
                            )
                        }
                        StatusNotificationErrorCode::OverVoltage => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                14u32,
                                "OverVoltage",
                            )
                        }
                        StatusNotificationErrorCode::WeakSignal => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationErrorCode",
                                15u32,
                                "WeakSignal",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StatusNotificationErrorCode {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                        __field15,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                14u64 => _serde::__private::Ok(__Field::__field14),
                                15u64 => _serde::__private::Ok(__Field::__field15),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 16",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "ConnectorLockFailure" => _serde::__private::Ok(__Field::__field0),
                                "EVCommunicationError" => _serde::__private::Ok(__Field::__field1),
                                "GroundFailure" => _serde::__private::Ok(__Field::__field2),
                                "HighTemperature" => _serde::__private::Ok(__Field::__field3),
                                "InternalError" => _serde::__private::Ok(__Field::__field4),
                                "LocalListConflict" => _serde::__private::Ok(__Field::__field5),
                                "NoError" => _serde::__private::Ok(__Field::__field6),
                                "OtherError" => _serde::__private::Ok(__Field::__field7),
                                "OverCurrentFailure" => _serde::__private::Ok(__Field::__field8),
                                "PowerMeterFailure" => _serde::__private::Ok(__Field::__field9),
                                "PowerSwitchFailure" => _serde::__private::Ok(__Field::__field10),
                                "ReaderFailure" => _serde::__private::Ok(__Field::__field11),
                                "ResetFailure" => _serde::__private::Ok(__Field::__field12),
                                "UnderVoltage" => _serde::__private::Ok(__Field::__field13),
                                "OverVoltage" => _serde::__private::Ok(__Field::__field14),
                                "WeakSignal" => _serde::__private::Ok(__Field::__field15),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"ConnectorLockFailure" => _serde::__private::Ok(__Field::__field0),
                                b"EVCommunicationError" => _serde::__private::Ok(__Field::__field1),
                                b"GroundFailure" => _serde::__private::Ok(__Field::__field2),
                                b"HighTemperature" => _serde::__private::Ok(__Field::__field3),
                                b"InternalError" => _serde::__private::Ok(__Field::__field4),
                                b"LocalListConflict" => _serde::__private::Ok(__Field::__field5),
                                b"NoError" => _serde::__private::Ok(__Field::__field6),
                                b"OtherError" => _serde::__private::Ok(__Field::__field7),
                                b"OverCurrentFailure" => _serde::__private::Ok(__Field::__field8),
                                b"PowerMeterFailure" => _serde::__private::Ok(__Field::__field9),
                                b"PowerSwitchFailure" => _serde::__private::Ok(__Field::__field10),
                                b"ReaderFailure" => _serde::__private::Ok(__Field::__field11),
                                b"ResetFailure" => _serde::__private::Ok(__Field::__field12),
                                b"UnderVoltage" => _serde::__private::Ok(__Field::__field13),
                                b"OverVoltage" => _serde::__private::Ok(__Field::__field14),
                                b"WeakSignal" => _serde::__private::Ok(__Field::__field15),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StatusNotificationErrorCode>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StatusNotificationErrorCode;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum StatusNotificationErrorCode",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::ConnectorLockFailure,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::EVCommunicationError,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::GroundFailure,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::HighTemperature,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::InternalError,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::LocalListConflict,
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationErrorCode::NoError)
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationErrorCode::OtherError)
                                }
                                (__Field::__field8, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::OverCurrentFailure,
                                    )
                                }
                                (__Field::__field9, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::PowerMeterFailure,
                                    )
                                }
                                (__Field::__field10, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::PowerSwitchFailure,
                                    )
                                }
                                (__Field::__field11, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        StatusNotificationErrorCode::ReaderFailure,
                                    )
                                }
                                (__Field::__field12, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationErrorCode::ResetFailure)
                                }
                                (__Field::__field13, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationErrorCode::UnderVoltage)
                                }
                                (__Field::__field14, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationErrorCode::OverVoltage)
                                }
                                (__Field::__field15, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationErrorCode::WeakSignal)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "ConnectorLockFailure",
                        "EVCommunicationError",
                        "GroundFailure",
                        "HighTemperature",
                        "InternalError",
                        "LocalListConflict",
                        "NoError",
                        "OtherError",
                        "OverCurrentFailure",
                        "PowerMeterFailure",
                        "PowerSwitchFailure",
                        "ReaderFailure",
                        "ResetFailure",
                        "UnderVoltage",
                        "OverVoltage",
                        "WeakSignal",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "StatusNotificationErrorCode",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StatusNotificationErrorCode>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StatusNotificationErrorCode {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&StatusNotificationErrorCode::ConnectorLockFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "ConnectorLockFailure")
                    }
                    (&StatusNotificationErrorCode::EVCommunicationError,) => {
                        ::core::fmt::Formatter::write_str(f, "EVCommunicationError")
                    }
                    (&StatusNotificationErrorCode::GroundFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "GroundFailure")
                    }
                    (&StatusNotificationErrorCode::HighTemperature,) => {
                        ::core::fmt::Formatter::write_str(f, "HighTemperature")
                    }
                    (&StatusNotificationErrorCode::InternalError,) => {
                        ::core::fmt::Formatter::write_str(f, "InternalError")
                    }
                    (&StatusNotificationErrorCode::LocalListConflict,) => {
                        ::core::fmt::Formatter::write_str(f, "LocalListConflict")
                    }
                    (&StatusNotificationErrorCode::NoError,) => {
                        ::core::fmt::Formatter::write_str(f, "NoError")
                    }
                    (&StatusNotificationErrorCode::OtherError,) => {
                        ::core::fmt::Formatter::write_str(f, "OtherError")
                    }
                    (&StatusNotificationErrorCode::OverCurrentFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "OverCurrentFailure")
                    }
                    (&StatusNotificationErrorCode::PowerMeterFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerMeterFailure")
                    }
                    (&StatusNotificationErrorCode::PowerSwitchFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "PowerSwitchFailure")
                    }
                    (&StatusNotificationErrorCode::ReaderFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "ReaderFailure")
                    }
                    (&StatusNotificationErrorCode::ResetFailure,) => {
                        ::core::fmt::Formatter::write_str(f, "ResetFailure")
                    }
                    (&StatusNotificationErrorCode::UnderVoltage,) => {
                        ::core::fmt::Formatter::write_str(f, "UnderVoltage")
                    }
                    (&StatusNotificationErrorCode::OverVoltage,) => {
                        ::core::fmt::Formatter::write_str(f, "OverVoltage")
                    }
                    (&StatusNotificationErrorCode::WeakSignal,) => {
                        ::core::fmt::Formatter::write_str(f, "WeakSignal")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StatusNotificationErrorCode {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StatusNotificationErrorCode {
            #[inline]
            fn eq(&self, other: &StatusNotificationErrorCode) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for StatusNotificationErrorCode {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for StatusNotificationErrorCode {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for StatusNotificationErrorCode {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    StatusNotificationErrorCode::ConnectorLockFailure => {
                        f.pad("ConnectorLockFailure")
                    }
                    StatusNotificationErrorCode::EVCommunicationError => {
                        f.pad("EVCommunicationError")
                    }
                    StatusNotificationErrorCode::GroundFailure => f.pad("GroundFailure"),
                    StatusNotificationErrorCode::HighTemperature => f.pad("HighTemperature"),
                    StatusNotificationErrorCode::InternalError => f.pad("InternalError"),
                    StatusNotificationErrorCode::LocalListConflict => f.pad("LocalListConflict"),
                    StatusNotificationErrorCode::NoError => f.pad("NoError"),
                    StatusNotificationErrorCode::OtherError => f.pad("OtherError"),
                    StatusNotificationErrorCode::OverCurrentFailure => f.pad("OverCurrentFailure"),
                    StatusNotificationErrorCode::PowerMeterFailure => f.pad("PowerMeterFailure"),
                    StatusNotificationErrorCode::PowerSwitchFailure => f.pad("PowerSwitchFailure"),
                    StatusNotificationErrorCode::ReaderFailure => f.pad("ReaderFailure"),
                    StatusNotificationErrorCode::ResetFailure => f.pad("ResetFailure"),
                    StatusNotificationErrorCode::UnderVoltage => f.pad("UnderVoltage"),
                    StatusNotificationErrorCode::OverVoltage => f.pad("OverVoltage"),
                    StatusNotificationErrorCode::WeakSignal => f.pad("WeakSignal"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StatusNotificationErrorCode {
            #[inline]
            fn clone(&self) -> StatusNotificationErrorCode {
                match (&*self,) {
                    (&StatusNotificationErrorCode::ConnectorLockFailure,) => {
                        StatusNotificationErrorCode::ConnectorLockFailure
                    }
                    (&StatusNotificationErrorCode::EVCommunicationError,) => {
                        StatusNotificationErrorCode::EVCommunicationError
                    }
                    (&StatusNotificationErrorCode::GroundFailure,) => {
                        StatusNotificationErrorCode::GroundFailure
                    }
                    (&StatusNotificationErrorCode::HighTemperature,) => {
                        StatusNotificationErrorCode::HighTemperature
                    }
                    (&StatusNotificationErrorCode::InternalError,) => {
                        StatusNotificationErrorCode::InternalError
                    }
                    (&StatusNotificationErrorCode::LocalListConflict,) => {
                        StatusNotificationErrorCode::LocalListConflict
                    }
                    (&StatusNotificationErrorCode::NoError,) => {
                        StatusNotificationErrorCode::NoError
                    }
                    (&StatusNotificationErrorCode::OtherError,) => {
                        StatusNotificationErrorCode::OtherError
                    }
                    (&StatusNotificationErrorCode::OverCurrentFailure,) => {
                        StatusNotificationErrorCode::OverCurrentFailure
                    }
                    (&StatusNotificationErrorCode::PowerMeterFailure,) => {
                        StatusNotificationErrorCode::PowerMeterFailure
                    }
                    (&StatusNotificationErrorCode::PowerSwitchFailure,) => {
                        StatusNotificationErrorCode::PowerSwitchFailure
                    }
                    (&StatusNotificationErrorCode::ReaderFailure,) => {
                        StatusNotificationErrorCode::ReaderFailure
                    }
                    (&StatusNotificationErrorCode::ResetFailure,) => {
                        StatusNotificationErrorCode::ResetFailure
                    }
                    (&StatusNotificationErrorCode::UnderVoltage,) => {
                        StatusNotificationErrorCode::UnderVoltage
                    }
                    (&StatusNotificationErrorCode::OverVoltage,) => {
                        StatusNotificationErrorCode::OverVoltage
                    }
                    (&StatusNotificationErrorCode::WeakSignal,) => {
                        StatusNotificationErrorCode::WeakSignal
                    }
                }
            }
        }
        /// Status reported in StatusNotification.req.
        ///
        /// A status can be reported for the Charge Point main controller (connectorId = 0) or for a specific connector. Status for the Charge Point main controller is a subset of the enumeration: Available, Unavailable or Faulted.
        ///
        /// States considered Operative are: Available, Preparing, Charging, SuspendedEVSE, SuspendedEV, Finishing, Reserved.
        ///
        /// States considered Inoperative are: Unavailable, Faulted.
        pub enum StatusNotificationStatus {
            /// When a Connector becomes available for a new user (Operative)
            Available,
            /// When a Connector becomes no longer available for a new user but there is no ongoing Transaction (yet). Typically a Connector is in
            /// preparing state when a user presents a tag, inserts a cable or a vehicle occupies the parking bay
            Preparing,
            /// When the contactor of a Connector closes, allowing the vehicle to charge
            Charging,
            /// When the EV is connected to the EVSE but the EVSE is not offering energy to the EV, e.g. due to a smart charging restriction, local
            /// supply power constraints, or as the result of StartTransaction.conf indicating that charging is not allowed etc.
            SuspendedEVSE,
            /// When the EV is connected to the EVSE and the EVSE is offering energy but the EV is not taking any energy.
            SuspendedEV,
            /// When a Transaction has stopped at a Connector, but the Connector is not yet available for a new user, e.g. the cable has not been
            /// removed or the vehicle has not left the parking bay
            Finishing,
            /// When a Connector becomes reserved as a result of a Reserve Now command
            Reserved,
            /// When a Connector becomes unavailable as the result of a Change Availability command or an event upon which the Charge Point transitions
            /// to unavailable at its discretion. Upon receipt of a Change Availability command, the status MAY change immediately or the change MAY be
            /// scheduled. When scheduled, the Status Notification shall be send when the availability change becomes effective
            Unavailable,
            /// When a Charge Point or connector has reported an error and is not available for energy delivery . (Inoperative).
            Faulted,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StatusNotificationStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        StatusNotificationStatus::Available => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                0u32,
                                "Available",
                            )
                        }
                        StatusNotificationStatus::Preparing => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                1u32,
                                "Preparing",
                            )
                        }
                        StatusNotificationStatus::Charging => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                2u32,
                                "Charging",
                            )
                        }
                        StatusNotificationStatus::SuspendedEVSE => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                3u32,
                                "SuspendedEVSE",
                            )
                        }
                        StatusNotificationStatus::SuspendedEV => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                4u32,
                                "SuspendedEV",
                            )
                        }
                        StatusNotificationStatus::Finishing => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                5u32,
                                "Finishing",
                            )
                        }
                        StatusNotificationStatus::Reserved => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                6u32,
                                "Reserved",
                            )
                        }
                        StatusNotificationStatus::Unavailable => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                7u32,
                                "Unavailable",
                            )
                        }
                        StatusNotificationStatus::Faulted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "StatusNotificationStatus",
                                8u32,
                                "Faulted",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StatusNotificationStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 9",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Available" => _serde::__private::Ok(__Field::__field0),
                                "Preparing" => _serde::__private::Ok(__Field::__field1),
                                "Charging" => _serde::__private::Ok(__Field::__field2),
                                "SuspendedEVSE" => _serde::__private::Ok(__Field::__field3),
                                "SuspendedEV" => _serde::__private::Ok(__Field::__field4),
                                "Finishing" => _serde::__private::Ok(__Field::__field5),
                                "Reserved" => _serde::__private::Ok(__Field::__field6),
                                "Unavailable" => _serde::__private::Ok(__Field::__field7),
                                "Faulted" => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Available" => _serde::__private::Ok(__Field::__field0),
                                b"Preparing" => _serde::__private::Ok(__Field::__field1),
                                b"Charging" => _serde::__private::Ok(__Field::__field2),
                                b"SuspendedEVSE" => _serde::__private::Ok(__Field::__field3),
                                b"SuspendedEV" => _serde::__private::Ok(__Field::__field4),
                                b"Finishing" => _serde::__private::Ok(__Field::__field5),
                                b"Reserved" => _serde::__private::Ok(__Field::__field6),
                                b"Unavailable" => _serde::__private::Ok(__Field::__field7),
                                b"Faulted" => _serde::__private::Ok(__Field::__field8),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StatusNotificationStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StatusNotificationStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum StatusNotificationStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Available)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Preparing)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Charging)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::SuspendedEVSE)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::SuspendedEV)
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Finishing)
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Reserved)
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Unavailable)
                                }
                                (__Field::__field8, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StatusNotificationStatus::Faulted)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Available",
                        "Preparing",
                        "Charging",
                        "SuspendedEVSE",
                        "SuspendedEV",
                        "Finishing",
                        "Reserved",
                        "Unavailable",
                        "Faulted",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "StatusNotificationStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StatusNotificationStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StatusNotificationStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&StatusNotificationStatus::Available,) => {
                        ::core::fmt::Formatter::write_str(f, "Available")
                    }
                    (&StatusNotificationStatus::Preparing,) => {
                        ::core::fmt::Formatter::write_str(f, "Preparing")
                    }
                    (&StatusNotificationStatus::Charging,) => {
                        ::core::fmt::Formatter::write_str(f, "Charging")
                    }
                    (&StatusNotificationStatus::SuspendedEVSE,) => {
                        ::core::fmt::Formatter::write_str(f, "SuspendedEVSE")
                    }
                    (&StatusNotificationStatus::SuspendedEV,) => {
                        ::core::fmt::Formatter::write_str(f, "SuspendedEV")
                    }
                    (&StatusNotificationStatus::Finishing,) => {
                        ::core::fmt::Formatter::write_str(f, "Finishing")
                    }
                    (&StatusNotificationStatus::Reserved,) => {
                        ::core::fmt::Formatter::write_str(f, "Reserved")
                    }
                    (&StatusNotificationStatus::Unavailable,) => {
                        ::core::fmt::Formatter::write_str(f, "Unavailable")
                    }
                    (&StatusNotificationStatus::Faulted,) => {
                        ::core::fmt::Formatter::write_str(f, "Faulted")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StatusNotificationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StatusNotificationStatus {
            #[inline]
            fn eq(&self, other: &StatusNotificationStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for StatusNotificationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for StatusNotificationStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for StatusNotificationStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    StatusNotificationStatus::Available => f.pad("Available"),
                    StatusNotificationStatus::Preparing => f.pad("Preparing"),
                    StatusNotificationStatus::Charging => f.pad("Charging"),
                    StatusNotificationStatus::SuspendedEVSE => f.pad("SuspendedEVSE"),
                    StatusNotificationStatus::SuspendedEV => f.pad("SuspendedEV"),
                    StatusNotificationStatus::Finishing => f.pad("Finishing"),
                    StatusNotificationStatus::Reserved => f.pad("Reserved"),
                    StatusNotificationStatus::Unavailable => f.pad("Unavailable"),
                    StatusNotificationStatus::Faulted => f.pad("Faulted"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StatusNotificationStatus {
            #[inline]
            fn clone(&self) -> StatusNotificationStatus {
                match (&*self,) {
                    (&StatusNotificationStatus::Available,) => StatusNotificationStatus::Available,
                    (&StatusNotificationStatus::Preparing,) => StatusNotificationStatus::Preparing,
                    (&StatusNotificationStatus::Charging,) => StatusNotificationStatus::Charging,
                    (&StatusNotificationStatus::SuspendedEVSE,) => {
                        StatusNotificationStatus::SuspendedEVSE
                    }
                    (&StatusNotificationStatus::SuspendedEV,) => {
                        StatusNotificationStatus::SuspendedEV
                    }
                    (&StatusNotificationStatus::Finishing,) => StatusNotificationStatus::Finishing,
                    (&StatusNotificationStatus::Reserved,) => StatusNotificationStatus::Reserved,
                    (&StatusNotificationStatus::Unavailable,) => {
                        StatusNotificationStatus::Unavailable
                    }
                    (&StatusNotificationStatus::Faulted,) => StatusNotificationStatus::Faulted,
                }
            }
        }
        const STATUSNOTIFICATIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"StatusNotificationResponse\",\n    \"type\": \"object\",\n    \"properties\": {},\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STATUSNOTIFICATIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static STATUSNOTIFICATIONRESPONSE_JSON: STATUSNOTIFICATIONRESPONSE_JSON =
            STATUSNOTIFICATIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STATUSNOTIFICATIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(STATUSNOTIFICATIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StatusNotificationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STATUSNOTIFICATIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STATUSNOTIFICATIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static STATUSNOTIFICATIONRESPONSE_VALIDATOR: STATUSNOTIFICATIONRESPONSE_VALIDATOR =
            STATUSNOTIFICATIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STATUSNOTIFICATIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&STATUSNOTIFICATIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StatusNotificationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STATUSNOTIFICATIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for StatusNotificationResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = STATUSNOTIFICATIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/status_notification.rs:136",
                                    "ocpp::point_init::status_notification",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/status_notification.rs"),
                                    Some(136u32),
                                    Some("ocpp::point_init::status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/status_notification.rs:136",
                                    "ocpp::point_init::status_notification",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/status_notification.rs"),
                                    Some(136u32),
                                    Some("ocpp::point_init::status_notification"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the StatusNotification.conf PDU sent by the Central System to the Charge Point in response to an StatusNotification.req PDU.
        pub struct StatusNotificationResponse {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StatusNotificationResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "StatusNotificationResponse",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StatusNotificationResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StatusNotificationResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StatusNotificationResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StatusNotificationResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(StatusNotificationResponse {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(StatusNotificationResponse {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StatusNotificationResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StatusNotificationResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StatusNotificationResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "StatusNotificationResponse")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StatusNotificationResponse {
            #[inline]
            fn clone(&self) -> StatusNotificationResponse {
                StatusNotificationResponse {}
            }
        }
    }
    pub mod stop_transaction {
        //! Request from chargepoint to end an energy transaction. *Central server cannot deny this request.*
        //!
        //! # Behaviour
        //! A StopTransaction.req PDU MAY contain an optional TransactionData element to provide more details about transaction usage. The optional TransactionData element
        //! is a container for any number of MeterValues, using the same data structure as the meterValue elements of the MeterValues.req PDU (See section MeterValues)
        //!
        //! The idTag in the request PDU MAY be omitted when the Charge Point itself needs to stop the transaction. For instance, when the Charge Point is requested to reset.
        //!
        //! If a transaction is ended in a normal way (e.g. EV-driver presented his identification to stop the transaction), the Reason element MAY be omitted and the Reason
        //! SHOULD be assumed 'Local'. If the transaction is not ended normally, the Reason SHOULD be set to a correct value. As part of the normal transaction termination,
        //! the Charge Point SHALL unlock the cable (if not permanently attached).
        //!
        //! The Charge Point MAY unlock the cable (if not permanently attached) when the cable is disconnected at the EV. If supported, this functionality is reported and
        //! controlled by the configuration key UnlockConnectorOnEVSideDisconnect.
        //!
        //! The Charge Point MAY stop a running transaction when the cable is disconnected at the EV. If supported, this functionality is reported and controlled by the
        //! configuration key StopTransactionOnEVSideDisconnect.
        //!
        //! # Response
        //! Upon receipt of a StopTransaction.req PDU, the Central System SHALL respond with a StopTransaction.conf PDU. The Central System cannot prevent a transaction from
        //! stopping. It MAY only inform the Charge Point it has received the StopTransaction.req and MAY send information about the idTag used to stop the transaction. This
        //! information SHOULD be used to update the Authorization Cache, if implemented.
        //!
        //! # StopTransactionOnEVSideDisconnect
        //!
        //! If StopTransactionOnEVSideDisconnect is set to false, the transaction SHALL not be stopped when the cable is disconnected from the EV. If the EV is reconnected,
        //! energy transfer is allowed again. In this case there is no mechanism to prevent other EVs from charging and disconnecting during that same ongoing transaction.
        //! With UnlockConnectorOnEVSideDisconnect set to false, the Connector SHALL remain locked at the Charge Point until the user presents the identifier.
        //!
        //! By setting StopTransactionOnEVSideDisconnect to true, the transaction SHALL be stopped when the cable is disconnected from the EV. If the EV is reconnected, energy
        //! transfer is not allowed until the transaction is stopped and a new transaction is started. If UnlockConnectorOnEVSideDisconnect is set to true, also the Connector
        //! on the Charge Point will be unlocked. If StopTransactionOnEVSideDisconnect is set to false, this SHALL have priority over UnlockConnectorOnEVSideDisconnect. In other words: cables always remain locked
        //! when the cable is disconnected at EV side when StopTransactionOnEVSideDisconnect is false. Setting StopTransactionOnEVSideDisconnect to true will prevent sabotage acts to stop the energy flow by unplugging not locked cables on EV side.
        //!
        //! It is likely that The Central System applies sanity checks to the data contained in a StopTransaction.req it received. The outcome of such sanity checks SHOULD
        //! NOT ever cause the Central System to not respond with a StopTransaction.conf. Failing to respond with a StopTransaction.conf will only cause the Charge Point
        //! to try the same message again as specified in Error responses to transaction-related messages.
        //!
        //! If Charge Point has implemented an Authorization Cache, then upon receipt of a StopTransaction.conf PDU the Charge Point SHALL update the cache entry, if the
        //! idTag is not in the Local Authorization List, with the IdTagInfo value from the response as described under Authorization Cache.
        pub use crate::common_types::IdTagInfo;
        use crate::validation_macros::{self, json_validate};
        pub use crate::MeterValue;
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        const STOPTRANSACTIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:StopTransactionRequest\",\r\n    \"title\": \"StopTransactionRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"idTag\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"meterStop\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"timestamp\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n        },\r\n        \"transactionId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"reason\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"EmergencyStop\",\r\n                \"EVDisconnected\",\r\n                \"HardReset\",\r\n                \"Local\",\r\n                \"Other\",\r\n                \"PowerLoss\",\r\n                \"Reboot\",\r\n                \"Remote\",\r\n                \"SoftReset\",\r\n                \"UnlockCommand\",\r\n                \"DeAuthorized\"\r\n            ]\r\n        },\r\n        \"transactionData\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": \"object\",\r\n                \"properties\": {\r\n                    \"timestamp\": {\r\n                        \"type\": \"string\",\r\n                        \"format\": \"date-time\"\r\n                    },\r\n                    \"sampledValue\": {\r\n                        \"type\": \"array\",\r\n                        \"items\": {\r\n                            \"type\": \"object\",\r\n                            \"properties\": {\r\n                                \"value\": {\r\n                                    \"type\": \"string\"\r\n                                },\r\n                                \"context\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Interruption.Begin\",\r\n                                        \"Interruption.End\",\r\n                                        \"Sample.Clock\",\r\n                                        \"Sample.Periodic\",\r\n                                        \"Transaction.Begin\",\r\n                                        \"Transaction.End\",\r\n                                        \"Trigger\",\r\n                                        \"Other\"\r\n                                    ]\r\n                                },  \r\n                                \"format\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Raw\",\r\n                                        \"SignedData\"\r\n                                    ]\r\n                                },\r\n                                \"measurand\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Energy.Active.Export.Register\",\r\n                                        \"Energy.Active.Import.Register\",\r\n                                        \"Energy.Reactive.Export.Register\",\r\n                                        \"Energy.Reactive.Import.Register\",\r\n                                        \"Energy.Active.Export.Interval\",\r\n                                        \"Energy.Active.Import.Interval\",\r\n                                        \"Energy.Reactive.Export.Interval\",\r\n                                        \"Energy.Reactive.Import.Interval\",\r\n                                        \"Power.Active.Export\",\r\n                                        \"Power.Active.Import\",\r\n                                        \"Power.Offered\",\r\n                                        \"Power.Reactive.Export\",\r\n                                        \"Power.Reactive.Import\",\r\n                                        \"Power.Factor\",\r\n                                        \"Current.Import\",\r\n                                        \"Current.Export\",\r\n                                        \"Current.Offered\",\r\n                                        \"Voltage\",\r\n                                        \"Frequency\",\r\n                                        \"Temperature\",\r\n                                        \"SoC\",\r\n                                        \"RPM\"\r\n                                    ]\r\n                                },\r\n                                \"phase\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"L1\",\r\n                                        \"L2\",\r\n                                        \"L3\",\r\n                                        \"N\",\r\n                                        \"L1-N\",\r\n                                        \"L2-N\",\r\n                                        \"L3-N\",\r\n                                        \"L1-L2\",\r\n                                        \"L2-L3\",\r\n                                        \"L3-L1\"\r\n                                    ]\r\n                                },\r\n                                \"location\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Cable\",\r\n                                        \"EV\",\r\n                                        \"Inlet\",\r\n                                        \"Outlet\",\r\n                                        \"Body\"\r\n                                    ]\r\n                                },\r\n                                \"unit\": {\r\n                                    \"type\": \"string\",\r\n                                    \"additionalProperties\": false,\r\n                                    \"enum\": [\r\n                                        \"Wh\",\r\n                                        \"kWh\",\r\n                                        \"varh\",\r\n                                        \"kvarh\",\r\n                                        \"W\",\r\n                                        \"kW\",\r\n                                        \"VA\",\r\n                                        \"kVA\",\r\n                                        \"var\",\r\n                                        \"kvar\",\r\n                                        \"A\",\r\n                                        \"V\",\r\n                                        \"K\",\r\n                                        \"Celcius\",\r\n                                        \"Fahrenheit\",\r\n                                        \"Percent\"\r\n                                    ]\r\n                                }\r\n                            },\r\n                            \"additionalProperties\": false,\r\n                            \"required\": [\r\n                                \"value\"\r\n                            ]\r\n                        }\r\n                    }\r\n                },\r\n                \"additionalProperties\": false,\r\n                \"required\": [\r\n                    \"timestamp\",\r\n                    \"sampledValue\"\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"transactionId\",\r\n        \"timestamp\",\r\n        \"meterStop\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STOPTRANSACTIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static STOPTRANSACTIONREQUEST_JSON: STOPTRANSACTIONREQUEST_JSON =
            STOPTRANSACTIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STOPTRANSACTIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(STOPTRANSACTIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StopTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STOPTRANSACTIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STOPTRANSACTIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static STOPTRANSACTIONREQUEST_VALIDATOR: STOPTRANSACTIONREQUEST_VALIDATOR =
            STOPTRANSACTIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STOPTRANSACTIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&STOPTRANSACTIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StopTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STOPTRANSACTIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for StopTransactionRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = STOPTRANSACTIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/stop_transaction.rs:69",
                                    "ocpp::point_init::stop_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/stop_transaction.rs"),
                                    Some(69u32),
                                    Some("ocpp::point_init::stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/stop_transaction.rs:69",
                                    "ocpp::point_init::stop_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/stop_transaction.rs"),
                                    Some(69u32),
                                    Some("ocpp::point_init::stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the StopTransaction.req PDU sent by the Charge Point to the Central System.
        pub struct StopTransactionRequest {
            /// Optional. This contains the identifier which requested to stop the charging. It is optional because a Charge
            /// Point may terminate charging without the presence of an idTag, e.g. in case of a reset. A Charge Point SHALL send the idTag if known.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub id_tag: Option<String>,
            /// Required. This contains the meter value in Wh for the connector at end of the transaction.
            pub meter_stop: u32,
            /// Required. This contains the date and time on which the transaction is stopped.
            pub timestamp: DateTime<Utc>,
            /// Required. This contains the transaction-id as received by the StartTransaction.conf.
            pub transaction_id: u32,
            /// Optional. This contains the reason why the transaction was stopped. MAY only be omitted when the Reason is "Local".
            #[serde(skip_serializing_if = "Option::is_none")]
            pub reason: Option<StopReason>,
            /// Optional. This contains transaction usage details relevant for billing purposes.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub transaction_data: Option<Vec<MeterValue>>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StopTransactionRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "StopTransactionRequest",
                        false as usize
                            + if Option::is_none(&self.id_tag) { 0 } else { 1 }
                            + 1
                            + 1
                            + 1
                            + if Option::is_none(&self.reason) { 0 } else { 1 }
                            + if Option::is_none(&self.transaction_data) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.id_tag) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "idTag",
                            &self.id_tag,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "idTag")
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "meterStop",
                        &self.meter_stop,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "timestamp",
                        &self.timestamp,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "transactionId",
                        &self.transaction_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.reason) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "reason",
                            &self.reason,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "reason")
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.transaction_data) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "transactionData",
                            &self.transaction_data,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "transactionData",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StopTransactionRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "idTag" => _serde::__private::Ok(__Field::__field0),
                                "meterStop" => _serde::__private::Ok(__Field::__field1),
                                "timestamp" => _serde::__private::Ok(__Field::__field2),
                                "transactionId" => _serde::__private::Ok(__Field::__field3),
                                "reason" => _serde::__private::Ok(__Field::__field4),
                                "transactionData" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"idTag" => _serde::__private::Ok(__Field::__field0),
                                b"meterStop" => _serde::__private::Ok(__Field::__field1),
                                b"timestamp" => _serde::__private::Ok(__Field::__field2),
                                b"transactionId" => _serde::__private::Ok(__Field::__field3),
                                b"reason" => _serde::__private::Ok(__Field::__field4),
                                b"transactionData" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StopTransactionRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StopTransactionRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StopTransactionRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StopTransactionRequest with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct StopTransactionRequest with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                DateTime<Utc>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct StopTransactionRequest with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct StopTransactionRequest with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<StopReason>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct StopTransactionRequest with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<Vec<MeterValue>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct StopTransactionRequest with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StopTransactionRequest {
                                id_tag: __field0,
                                meter_stop: __field1,
                                timestamp: __field2,
                                transaction_id: __field3,
                                reason: __field4,
                                transaction_data: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<DateTime<Utc>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<StopReason>> =
                                _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Option<Vec<MeterValue>>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTag",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "meterStop",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timestamp",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<DateTime<Utc>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transactionId",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reason",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<StopReason>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transactionData",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Vec<MeterValue>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTag") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("meterStop") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("timestamp") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("transactionId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("reason") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("transactionData") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(StopTransactionRequest {
                                id_tag: __field0,
                                meter_stop: __field1,
                                timestamp: __field2,
                                transaction_id: __field3,
                                reason: __field4,
                                transaction_data: __field5,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "idTag",
                        "meterStop",
                        "timestamp",
                        "transactionId",
                        "reason",
                        "transactionData",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StopTransactionRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StopTransactionRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StopTransactionRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                {
                    let names: &'static _ = &[
                        "id_tag",
                        "meter_stop",
                        "timestamp",
                        "transaction_id",
                        "reason",
                        "transaction_data",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.id_tag,
                        &&self.meter_stop,
                        &&self.timestamp,
                        &&self.transaction_id,
                        &&self.reason,
                        &&self.transaction_data,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StopTransactionRequest",
                        names,
                        values,
                    )
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StopTransactionRequest {
            #[inline]
            fn clone(&self) -> StopTransactionRequest {
                StopTransactionRequest {
                    id_tag: ::core::clone::Clone::clone(&self.id_tag),
                    meter_stop: ::core::clone::Clone::clone(&self.meter_stop),
                    timestamp: ::core::clone::Clone::clone(&self.timestamp),
                    transaction_id: ::core::clone::Clone::clone(&self.transaction_id),
                    reason: ::core::clone::Clone::clone(&self.reason),
                    transaction_data: ::core::clone::Clone::clone(&self.transaction_data),
                }
            }
        }
        /// Reason for stopping a transaction in StopTransaction.req.
        pub enum StopReason {
            /// Emergency stop button was used.
            EmergencyStop,
            /// disconnecting of cable, vehicle moved away from inductive charge unit.
            EVDisconnected,
            /// A hard reset command was received.
            HardReset,
            /// Stopped locally on request of the user at the Charge Point. This is a regular termination of a transaction. Examples: presenting an RFID tag, pressing a button to stop.
            Local,
            /// Any other reason.
            Other,
            /// Complete loss of power.
            PowerLoss,
            /// A locally initiated reset/reboot occurred. (for instance watchdog kicked in)
            Reboot,
            /// Stopped remotely on request of the user. This is a regular termination of a transaction. Examples: termination using a smartphone app, exceeding a (non local) prepaid credit.
            Remote,
            /// A soft reset command was received.
            SoftReset,
            /// Central System sent an Unlock Connector command.
            UnlockCommand,
            ///
            DeAuthorized,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StopReason {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        StopReason::EmergencyStop => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            0u32,
                            "EmergencyStop",
                        ),
                        StopReason::EVDisconnected => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            1u32,
                            "EVDisconnected",
                        ),
                        StopReason::HardReset => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            2u32,
                            "HardReset",
                        ),
                        StopReason::Local => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            3u32,
                            "Local",
                        ),
                        StopReason::Other => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            4u32,
                            "Other",
                        ),
                        StopReason::PowerLoss => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            5u32,
                            "PowerLoss",
                        ),
                        StopReason::Reboot => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            6u32,
                            "Reboot",
                        ),
                        StopReason::Remote => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            7u32,
                            "Remote",
                        ),
                        StopReason::SoftReset => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            8u32,
                            "SoftReset",
                        ),
                        StopReason::UnlockCommand => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            9u32,
                            "UnlockCommand",
                        ),
                        StopReason::DeAuthorized => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "StopReason",
                            10u32,
                            "DeAuthorized",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StopReason {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 11",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "EmergencyStop" => _serde::__private::Ok(__Field::__field0),
                                "EVDisconnected" => _serde::__private::Ok(__Field::__field1),
                                "HardReset" => _serde::__private::Ok(__Field::__field2),
                                "Local" => _serde::__private::Ok(__Field::__field3),
                                "Other" => _serde::__private::Ok(__Field::__field4),
                                "PowerLoss" => _serde::__private::Ok(__Field::__field5),
                                "Reboot" => _serde::__private::Ok(__Field::__field6),
                                "Remote" => _serde::__private::Ok(__Field::__field7),
                                "SoftReset" => _serde::__private::Ok(__Field::__field8),
                                "UnlockCommand" => _serde::__private::Ok(__Field::__field9),
                                "DeAuthorized" => _serde::__private::Ok(__Field::__field10),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"EmergencyStop" => _serde::__private::Ok(__Field::__field0),
                                b"EVDisconnected" => _serde::__private::Ok(__Field::__field1),
                                b"HardReset" => _serde::__private::Ok(__Field::__field2),
                                b"Local" => _serde::__private::Ok(__Field::__field3),
                                b"Other" => _serde::__private::Ok(__Field::__field4),
                                b"PowerLoss" => _serde::__private::Ok(__Field::__field5),
                                b"Reboot" => _serde::__private::Ok(__Field::__field6),
                                b"Remote" => _serde::__private::Ok(__Field::__field7),
                                b"SoftReset" => _serde::__private::Ok(__Field::__field8),
                                b"UnlockCommand" => _serde::__private::Ok(__Field::__field9),
                                b"DeAuthorized" => _serde::__private::Ok(__Field::__field10),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StopReason>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StopReason;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum StopReason")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::EmergencyStop)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::EVDisconnected)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::HardReset)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::Local)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::Other)
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::PowerLoss)
                                }
                                (__Field::__field6, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::Reboot)
                                }
                                (__Field::__field7, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::Remote)
                                }
                                (__Field::__field8, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::SoftReset)
                                }
                                (__Field::__field9, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::UnlockCommand)
                                }
                                (__Field::__field10, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(StopReason::DeAuthorized)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "EmergencyStop",
                        "EVDisconnected",
                        "HardReset",
                        "Local",
                        "Other",
                        "PowerLoss",
                        "Reboot",
                        "Remote",
                        "SoftReset",
                        "UnlockCommand",
                        "DeAuthorized",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "StopReason",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StopReason>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StopReason {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&StopReason::EmergencyStop,) => {
                        ::core::fmt::Formatter::write_str(f, "EmergencyStop")
                    }
                    (&StopReason::EVDisconnected,) => {
                        ::core::fmt::Formatter::write_str(f, "EVDisconnected")
                    }
                    (&StopReason::HardReset,) => ::core::fmt::Formatter::write_str(f, "HardReset"),
                    (&StopReason::Local,) => ::core::fmt::Formatter::write_str(f, "Local"),
                    (&StopReason::Other,) => ::core::fmt::Formatter::write_str(f, "Other"),
                    (&StopReason::PowerLoss,) => ::core::fmt::Formatter::write_str(f, "PowerLoss"),
                    (&StopReason::Reboot,) => ::core::fmt::Formatter::write_str(f, "Reboot"),
                    (&StopReason::Remote,) => ::core::fmt::Formatter::write_str(f, "Remote"),
                    (&StopReason::SoftReset,) => ::core::fmt::Formatter::write_str(f, "SoftReset"),
                    (&StopReason::UnlockCommand,) => {
                        ::core::fmt::Formatter::write_str(f, "UnlockCommand")
                    }
                    (&StopReason::DeAuthorized,) => {
                        ::core::fmt::Formatter::write_str(f, "DeAuthorized")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StopReason {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StopReason {
            #[inline]
            fn eq(&self, other: &StopReason) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for StopReason {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for StopReason {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for StopReason {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    StopReason::EmergencyStop => f.pad("EmergencyStop"),
                    StopReason::EVDisconnected => f.pad("EVDisconnected"),
                    StopReason::HardReset => f.pad("HardReset"),
                    StopReason::Local => f.pad("Local"),
                    StopReason::Other => f.pad("Other"),
                    StopReason::PowerLoss => f.pad("PowerLoss"),
                    StopReason::Reboot => f.pad("Reboot"),
                    StopReason::Remote => f.pad("Remote"),
                    StopReason::SoftReset => f.pad("SoftReset"),
                    StopReason::UnlockCommand => f.pad("UnlockCommand"),
                    StopReason::DeAuthorized => f.pad("DeAuthorized"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StopReason {
            #[inline]
            fn clone(&self) -> StopReason {
                match (&*self,) {
                    (&StopReason::EmergencyStop,) => StopReason::EmergencyStop,
                    (&StopReason::EVDisconnected,) => StopReason::EVDisconnected,
                    (&StopReason::HardReset,) => StopReason::HardReset,
                    (&StopReason::Local,) => StopReason::Local,
                    (&StopReason::Other,) => StopReason::Other,
                    (&StopReason::PowerLoss,) => StopReason::PowerLoss,
                    (&StopReason::Reboot,) => StopReason::Reboot,
                    (&StopReason::Remote,) => StopReason::Remote,
                    (&StopReason::SoftReset,) => StopReason::SoftReset,
                    (&StopReason::UnlockCommand,) => StopReason::UnlockCommand,
                    (&StopReason::DeAuthorized,) => StopReason::DeAuthorized,
                }
            }
        }
        const STOPTRANSACTIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"StopTransactionResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"idTagInfo\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"expiryDate\": {\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"parentIdTag\": {\n                    \"type\": \"string\",\n                    \"maxLength\": 20\n                },\n                \"status\": {\n                    \"type\": \"string\",\n                    \"additionalProperties\": false,\n                    \"enum\": [\n                        \"Accepted\",\n                        \"Blocked\",\n                        \"Expired\",\n                        \"Invalid\",\n                        \"ConcurrentTx\"\n                    ]\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"status\"\n            ]\n        }\n    },\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STOPTRANSACTIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static STOPTRANSACTIONRESPONSE_JSON: STOPTRANSACTIONRESPONSE_JSON =
            STOPTRANSACTIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STOPTRANSACTIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(STOPTRANSACTIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StopTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STOPTRANSACTIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct STOPTRANSACTIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static STOPTRANSACTIONRESPONSE_VALIDATOR: STOPTRANSACTIONRESPONSE_VALIDATOR =
            STOPTRANSACTIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for STOPTRANSACTIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&STOPTRANSACTIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/StopTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for STOPTRANSACTIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for StopTransactionResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = STOPTRANSACTIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/stop_transaction.rs:118",
                                    "ocpp::point_init::stop_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/point_init/stop_transaction.rs"),
                                    Some(118u32),
                                    Some("ocpp::point_init::stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/point_init/stop_transaction.rs:118",
                                    "ocpp::point_init::stop_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/point_init/stop_transaction.rs"),
                                    Some(118u32),
                                    Some("ocpp::point_init::stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the StopTransaction.conf PDU sent by the Central System to the Charge Point in response to a StopTransaction.req PDU.
        pub struct StopTransactionResponse {
            /// see [idtaginfo](crate::common_types::IdTagInfo)
            #[serde(skip_serializing_if = "Option::is_none")]
            pub id_tag_info: Option<IdTagInfo>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StopTransactionResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "StopTransactionResponse",
                        false as usize
                            + if Option::is_none(&self.id_tag_info) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.id_tag_info) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "idTagInfo",
                            &self.id_tag_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "idTagInfo",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for StopTransactionResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "idTagInfo" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"idTagInfo" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<StopTransactionResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StopTransactionResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StopTransactionResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<IdTagInfo>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StopTransactionResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StopTransactionResponse {
                                id_tag_info: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<IdTagInfo>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTagInfo",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<IdTagInfo>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTagInfo") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(StopTransactionResponse {
                                id_tag_info: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["idTagInfo"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StopTransactionResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<StopTransactionResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StopTransactionResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "StopTransactionResponse",
                    "id_tag_info",
                    &&self.id_tag_info,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StopTransactionResponse {
            #[inline]
            fn clone(&self) -> StopTransactionResponse {
                StopTransactionResponse {
                    id_tag_info: ::core::clone::Clone::clone(&self.id_tag_info),
                }
            }
        }
    }
    pub use crate::common::data_transfer::*;
    pub use authorize::*;
    pub use boot_notification::*;
    pub use diagnostic_status_notification::*;
    pub use firmware_status_notification::*;
    pub use heartbeat::*;
    pub use meter_values::*;
    pub use start_transaction::*;
    pub use status_notification::*;
    pub use stop_transaction::*;
}
pub mod server_init {
    //! A collection of messages initiated by the central server
    pub mod change_availability {
        //! Server request for a ChargePoint to change it's availability
        //!
        //! # Behaviour
        //! A Charge Point is considered available (operative) when it is charging or ready for charging. A Charge Point is considered unavailable when it
        //! does not allow any charging. The Central System SHALL send a ChangeAvailability.req PDU for requesting a Charge Point to change its availability.
        //! The Central System can change the availability to available or unavailable.
        //!
        //! In the event that Central System requests Charge Point to change to a status it is already in, Charge Point SHALL respond with availability
        //! status Accepted.
        //!
        //! When an availability change requested with a ChangeAvailability.req PDU has happened, the Charge Point SHALL inform Central System of its new
        //! availability status with a StatusNotification.req as described there.
        //!
        //! In the case the ChangeAvailability.req contains ConnectorId = 0, the status change applies to the Charge Point and all Connectors.
        //!
        //! *States are persistent* i.e. Connector set to Unavailable shall persist a reboot.
        //!
        //! # Response
        //! Upon receipt of a ChangeAvailability.req PDU, the Charge Point SHALL respond with a ChangeAvailability.conf PDU. The response PDU SHALL
        //! indicate whether the Charge Point is able to change to the requested availability or not. When a transaction is in progress Charge Point
        //! SHALL respond with availability status 'Scheduled' to indicate that it is scheduled to occur after the transaction has finished.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const CHANGEAVAILABILITYREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:ChangeAvailabilityRequest\",\r\n    \"title\": \"ChangeAvailabilityRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"type\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"Inoperative\",\r\n                \"Operative\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\",\r\n        \"type\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGEAVAILABILITYREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGEAVAILABILITYREQUEST_JSON: CHANGEAVAILABILITYREQUEST_JSON =
            CHANGEAVAILABILITYREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGEAVAILABILITYREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CHANGEAVAILABILITYREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeAvailability.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGEAVAILABILITYREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGEAVAILABILITYREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGEAVAILABILITYREQUEST_VALIDATOR: CHANGEAVAILABILITYREQUEST_VALIDATOR =
            CHANGEAVAILABILITYREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGEAVAILABILITYREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CHANGEAVAILABILITYREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeAvailability.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGEAVAILABILITYREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ChangeAvailabilityRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CHANGEAVAILABILITYREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_availability.rs:28",
                                    "ocpp::server_init::change_availability",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/change_availability.rs"),
                                    Some(28u32),
                                    Some("ocpp::server_init::change_availability"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_availability.rs:28",
                                    "ocpp::server_init::change_availability",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/change_availability.rs"),
                                    Some(28u32),
                                    Some("ocpp::server_init::change_availability"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ChangeAvailability.req PDU sent by the Central System to the Charge Point
        pub struct ChangeAvailabilityRequest {
            /// Required. The id of the connector for which availability needs to change. Id '0' (zero) is used if the availability of the Charge Point and all its connectors needs to change.
            pub connector_id: u32,
            /// Required. This contains the type of availability change that the Charge Point should perform.
            pub r#type: ChangeAvailabilityType,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeAvailabilityRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChangeAvailabilityRequest",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeAvailabilityRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "type" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"type" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeAvailabilityRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeAvailabilityRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChangeAvailabilityRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChangeAvailabilityRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                ChangeAvailabilityType,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ChangeAvailabilityRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChangeAvailabilityRequest {
                                connector_id: __field0,
                                r#type: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ChangeAvailabilityType> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChangeAvailabilityType,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("type") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChangeAvailabilityRequest {
                                connector_id: __field0,
                                r#type: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["connectorId", "type"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChangeAvailabilityRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeAvailabilityRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeAvailabilityRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ChangeAvailabilityRequest",
                    "connector_id",
                    &&self.connector_id,
                    "type",
                    &&self.r#type,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeAvailabilityRequest {
            #[inline]
            fn clone(&self) -> ChangeAvailabilityRequest {
                ChangeAvailabilityRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                }
            }
        }
        /// Requested availability change in ChangeAvailability.req.
        pub enum ChangeAvailabilityType {
            /// Charge point is not available for charging.
            Inoperative,
            /// Charge point is available for charging.
            Operative,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeAvailabilityType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChangeAvailabilityType::Inoperative => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeAvailabilityType",
                                0u32,
                                "Inoperative",
                            )
                        }
                        ChangeAvailabilityType::Operative => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeAvailabilityType",
                                1u32,
                                "Operative",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeAvailabilityType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Inoperative" => _serde::__private::Ok(__Field::__field0),
                                "Operative" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Inoperative" => _serde::__private::Ok(__Field::__field0),
                                b"Operative" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeAvailabilityType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeAvailabilityType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChangeAvailabilityType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeAvailabilityType::Inoperative)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeAvailabilityType::Operative)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Inoperative", "Operative"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChangeAvailabilityType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeAvailabilityType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeAvailabilityType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChangeAvailabilityType::Inoperative,) => {
                        ::core::fmt::Formatter::write_str(f, "Inoperative")
                    }
                    (&ChangeAvailabilityType::Operative,) => {
                        ::core::fmt::Formatter::write_str(f, "Operative")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChangeAvailabilityType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChangeAvailabilityType {
            #[inline]
            fn eq(&self, other: &ChangeAvailabilityType) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChangeAvailabilityType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChangeAvailabilityType {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChangeAvailabilityType {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChangeAvailabilityType::Inoperative => f.pad("Inoperative"),
                    ChangeAvailabilityType::Operative => f.pad("Operative"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeAvailabilityType {
            #[inline]
            fn clone(&self) -> ChangeAvailabilityType {
                match (&*self,) {
                    (&ChangeAvailabilityType::Inoperative,) => ChangeAvailabilityType::Inoperative,
                    (&ChangeAvailabilityType::Operative,) => ChangeAvailabilityType::Operative,
                }
            }
        }
        const CHANGEAVAILABILITYRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"ChangeAvailabilityResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\",\n                \"Scheduled\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGEAVAILABILITYRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGEAVAILABILITYRESPONSE_JSON: CHANGEAVAILABILITYRESPONSE_JSON =
            CHANGEAVAILABILITYRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGEAVAILABILITYRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CHANGEAVAILABILITYRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeAvailabilityResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGEAVAILABILITYRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGEAVAILABILITYRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGEAVAILABILITYRESPONSE_VALIDATOR: CHANGEAVAILABILITYRESPONSE_VALIDATOR =
            CHANGEAVAILABILITYRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGEAVAILABILITYRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CHANGEAVAILABILITYRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeAvailabilityResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGEAVAILABILITYRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ChangeAvailabilityResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CHANGEAVAILABILITYRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_availability.rs:49",
                                    "ocpp::server_init::change_availability",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/change_availability.rs"),
                                    Some(49u32),
                                    Some("ocpp::server_init::change_availability"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_availability.rs:49",
                                    "ocpp::server_init::change_availability",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/change_availability.rs"),
                                    Some(49u32),
                                    Some("ocpp::server_init::change_availability"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ChangeAvailability.conf PDU return by Charge Point to Central System.
        pub struct ChangeAvailabilityResponse {
            /// Required. This contains the type of availability change that the Charge Point should perform.
            pub status: ChangeAvailabilityStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeAvailabilityResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChangeAvailabilityResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeAvailabilityResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeAvailabilityResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeAvailabilityResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChangeAvailabilityResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ChangeAvailabilityStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChangeAvailabilityResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChangeAvailabilityResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ChangeAvailabilityStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChangeAvailabilityStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChangeAvailabilityResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChangeAvailabilityResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeAvailabilityResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeAvailabilityResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ChangeAvailabilityResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeAvailabilityResponse {
            #[inline]
            fn clone(&self) -> ChangeAvailabilityResponse {
                ChangeAvailabilityResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Elements that constitute an entry of a Local Authorization List update.
        pub enum ChangeAvailabilityStatus {
            /// Request has been accepted and will be executed.
            Accepted,
            /// Request has not been accepted and will not be executed.
            Rejected,
            /// Request has been accepted and will be executed when transaction(s) in progress have finished.
            Scheduled,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeAvailabilityStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChangeAvailabilityStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeAvailabilityStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        ChangeAvailabilityStatus::Rejected => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeAvailabilityStatus",
                                1u32,
                                "Rejected",
                            )
                        }
                        ChangeAvailabilityStatus::Scheduled => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeAvailabilityStatus",
                                2u32,
                                "Scheduled",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeAvailabilityStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Rejected" => _serde::__private::Ok(__Field::__field1),
                                "Scheduled" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Rejected" => _serde::__private::Ok(__Field::__field1),
                                b"Scheduled" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeAvailabilityStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeAvailabilityStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChangeAvailabilityStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeAvailabilityStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeAvailabilityStatus::Rejected)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeAvailabilityStatus::Scheduled)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Accepted", "Rejected", "Scheduled"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChangeAvailabilityStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeAvailabilityStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeAvailabilityStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChangeAvailabilityStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&ChangeAvailabilityStatus::Rejected,) => {
                        ::core::fmt::Formatter::write_str(f, "Rejected")
                    }
                    (&ChangeAvailabilityStatus::Scheduled,) => {
                        ::core::fmt::Formatter::write_str(f, "Scheduled")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChangeAvailabilityStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChangeAvailabilityStatus {
            #[inline]
            fn eq(&self, other: &ChangeAvailabilityStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChangeAvailabilityStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChangeAvailabilityStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChangeAvailabilityStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChangeAvailabilityStatus::Accepted => f.pad("Accepted"),
                    ChangeAvailabilityStatus::Rejected => f.pad("Rejected"),
                    ChangeAvailabilityStatus::Scheduled => f.pad("Scheduled"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeAvailabilityStatus {
            #[inline]
            fn clone(&self) -> ChangeAvailabilityStatus {
                match (&*self,) {
                    (&ChangeAvailabilityStatus::Accepted,) => ChangeAvailabilityStatus::Accepted,
                    (&ChangeAvailabilityStatus::Rejected,) => ChangeAvailabilityStatus::Rejected,
                    (&ChangeAvailabilityStatus::Scheduled,) => ChangeAvailabilityStatus::Scheduled,
                }
            }
        }
    }
    pub mod change_configuration {
        //! Server request for a ChargePoint to update it's configuration with a Key/Val pair.
        //!
        //! # Behaviour
        //! This request contains a key-value pair, where "key" is the name of the configuration setting to change and "value" contains the new setting for the configuration setting.
        //!
        //! Examples of Change Configuration requests to which a Charge Point responds with a ChangeConfiguration.conf with a status of 'Rejected' are requests with out-of-range values and requests with values that do not conform to an expected format.
        //!
        //! If a key value is defined as a CSL, it MAY be accompanied with a \[KeyName\] MaxLength key, indicating the max length of the CSL in items. If this key is not set, a safe value of 1 (one) item SHOULD be assumed.
        //! # Response
        //! Upon receipt of a ChangeConfiguration.req Charge Point SHALL reply with a ChangeConfiguration.conf indicating whether it was able to apply the
        //! change to its configuration. Content of "key" and "value" is not prescribed. The Charge Point SHALL set the status field in the ChangeConfiguration.conf according to the following rules:
        //!
        //! 1. If the change was applied successfully, and the change if effective immediately, the Charge Point SHALL respond with a status 'Accepted'.
        //! 2. If the change was applied successfully, but a reboot is needed to make it effective, the Charge Point SHALL respond with status 'RebootRequired'.
        //! 3. If "key" does not correspond to a configuration setting supported by Charge Point, it SHALL respond with a status 'NotSupported'.
        //! 4. If the Charge Point did not set the configuration, and none of the previous statuses applies, the Charge Point SHALL respond with status 'Rejected'.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const CHANGECONFIGURATIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:ChangeConfigurationRequest\",\r\n    \"title\": \"ChangeConfigurationRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"key\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 50\r\n        },\r\n        \"value\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 500\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"key\",\r\n        \"value\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGECONFIGURATIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGECONFIGURATIONREQUEST_JSON: CHANGECONFIGURATIONREQUEST_JSON =
            CHANGECONFIGURATIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGECONFIGURATIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CHANGECONFIGURATIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeConfiguration.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGECONFIGURATIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGECONFIGURATIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGECONFIGURATIONREQUEST_VALIDATOR: CHANGECONFIGURATIONREQUEST_VALIDATOR =
            CHANGECONFIGURATIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGECONFIGURATIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CHANGECONFIGURATIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeConfiguration.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGECONFIGURATIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ChangeConfigurationRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CHANGECONFIGURATIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_configuration.rs:23",
                                    "ocpp::server_init::change_configuration",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/change_configuration.rs"),
                                    Some(23u32),
                                    Some("ocpp::server_init::change_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_configuration.rs:23",
                                    "ocpp::server_init::change_configuration",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/change_configuration.rs"),
                                    Some(23u32),
                                    Some("ocpp::server_init::change_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ChangeConfiguration.req PDU sent by Central System to Charge Point. It is RECOMMENDED
        /// that the content and meaning of the 'key' and 'value' fields is agreed upon between Charge Point and Central System.
        pub struct ChangeConfigurationRequest {
            /// Required. The name of the configuration setting to change.
            pub key: String,
            /// Required. The new value as string for the setting.
            pub value: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeConfigurationRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChangeConfigurationRequest",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "key",
                        &self.key,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        &self.value,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeConfigurationRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "value" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"value" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeConfigurationRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeConfigurationRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChangeConfigurationRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChangeConfigurationRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ChangeConfigurationRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChangeConfigurationRequest {
                                key: __field0,
                                value: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("key") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("value") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChangeConfigurationRequest {
                                key: __field0,
                                value: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["key", "value"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChangeConfigurationRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeConfigurationRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeConfigurationRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ChangeConfigurationRequest",
                    "key",
                    &&self.key,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeConfigurationRequest {
            #[inline]
            fn clone(&self) -> ChangeConfigurationRequest {
                ChangeConfigurationRequest {
                    key: ::core::clone::Clone::clone(&self.key),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        const CHANGECONFIGURATIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"ChangeConfigurationResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\",\n                \"RebootRequired\",\n                \"NotSupported\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGECONFIGURATIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGECONFIGURATIONRESPONSE_JSON: CHANGECONFIGURATIONRESPONSE_JSON =
            CHANGECONFIGURATIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGECONFIGURATIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CHANGECONFIGURATIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeConfigurationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGECONFIGURATIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CHANGECONFIGURATIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CHANGECONFIGURATIONRESPONSE_VALIDATOR: CHANGECONFIGURATIONRESPONSE_VALIDATOR =
            CHANGECONFIGURATIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CHANGECONFIGURATIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CHANGECONFIGURATIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ChangeConfigurationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CHANGECONFIGURATIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ChangeConfigurationResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CHANGECONFIGURATIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_configuration.rs:36",
                                    "ocpp::server_init::change_configuration",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/change_configuration.rs"),
                                    Some(36u32),
                                    Some("ocpp::server_init::change_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/change_configuration.rs:36",
                                    "ocpp::server_init::change_configuration",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/change_configuration.rs"),
                                    Some(36u32),
                                    Some("ocpp::server_init::change_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ChangeConfiguration.conf PDU returned from Charge Point to Central System.
        pub struct ChangeConfigurationResponse {
            /// Required. Returns whether configuration change has been accepted.
            pub status: ChangeConfigurationStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeConfigurationResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ChangeConfigurationResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeConfigurationResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeConfigurationResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeConfigurationResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ChangeConfigurationResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ChangeConfigurationStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ChangeConfigurationResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ChangeConfigurationResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ChangeConfigurationStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChangeConfigurationStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ChangeConfigurationResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ChangeConfigurationResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeConfigurationResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeConfigurationResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ChangeConfigurationResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeConfigurationResponse {
            #[inline]
            fn clone(&self) -> ChangeConfigurationResponse {
                ChangeConfigurationResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status returned in response to ChangeAvailability.req.
        pub enum ChangeConfigurationStatus {
            /// Configuration key is supported and setting has been changed.
            Accepted,
            /// Configuration key is supported, but setting could not be changed.
            Rejected,
            /// Configuration key is supported and setting has been changed, but change will be available after reboot (Charge Point will not reboot itself)
            RebootRequired,
            /// Configuration key is not supported.
            NotSupported,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChangeConfigurationStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChangeConfigurationStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeConfigurationStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        ChangeConfigurationStatus::Rejected => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeConfigurationStatus",
                                1u32,
                                "Rejected",
                            )
                        }
                        ChangeConfigurationStatus::RebootRequired => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeConfigurationStatus",
                                2u32,
                                "RebootRequired",
                            )
                        }
                        ChangeConfigurationStatus::NotSupported => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChangeConfigurationStatus",
                                3u32,
                                "NotSupported",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChangeConfigurationStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Rejected" => _serde::__private::Ok(__Field::__field1),
                                "RebootRequired" => _serde::__private::Ok(__Field::__field2),
                                "NotSupported" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Rejected" => _serde::__private::Ok(__Field::__field1),
                                b"RebootRequired" => _serde::__private::Ok(__Field::__field2),
                                b"NotSupported" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChangeConfigurationStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChangeConfigurationStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChangeConfigurationStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeConfigurationStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeConfigurationStatus::Rejected)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeConfigurationStatus::RebootRequired)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChangeConfigurationStatus::NotSupported)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Accepted", "Rejected", "RebootRequired", "NotSupported"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChangeConfigurationStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChangeConfigurationStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChangeConfigurationStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChangeConfigurationStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&ChangeConfigurationStatus::Rejected,) => {
                        ::core::fmt::Formatter::write_str(f, "Rejected")
                    }
                    (&ChangeConfigurationStatus::RebootRequired,) => {
                        ::core::fmt::Formatter::write_str(f, "RebootRequired")
                    }
                    (&ChangeConfigurationStatus::NotSupported,) => {
                        ::core::fmt::Formatter::write_str(f, "NotSupported")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChangeConfigurationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChangeConfigurationStatus {
            #[inline]
            fn eq(&self, other: &ChangeConfigurationStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChangeConfigurationStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChangeConfigurationStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChangeConfigurationStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChangeConfigurationStatus::Accepted => f.pad("Accepted"),
                    ChangeConfigurationStatus::Rejected => f.pad("Rejected"),
                    ChangeConfigurationStatus::RebootRequired => f.pad("RebootRequired"),
                    ChangeConfigurationStatus::NotSupported => f.pad("NotSupported"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChangeConfigurationStatus {
            #[inline]
            fn clone(&self) -> ChangeConfigurationStatus {
                match (&*self,) {
                    (&ChangeConfigurationStatus::Accepted,) => ChangeConfigurationStatus::Accepted,
                    (&ChangeConfigurationStatus::Rejected,) => ChangeConfigurationStatus::Rejected,
                    (&ChangeConfigurationStatus::RebootRequired,) => {
                        ChangeConfigurationStatus::RebootRequired
                    }
                    (&ChangeConfigurationStatus::NotSupported,) => {
                        ChangeConfigurationStatus::NotSupported
                    }
                }
            }
        }
    }
    pub mod clear_cache {
        //! Server request for a ChargePoint to clear it's auth cache.
        //!
        //! # Response
        //! Upon receipt of a ClearCache.req PDU, the Charge Point SHALL respond with a ClearCache.conf PDU. The response PDU
        //! SHALL indicate whether the Charge Point was able to clear its Authorization Cache.
        pub use crate::common_types::SimpleStatus;
        use serde::{Deserialize, Serialize};
        use crate::validation_macros::{self, json_validate};
        const CLEARCACHEREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:ClearCacheRequest\",\r\n    \"title\": \"ClearCacheRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {},\r\n    \"additionalProperties\": false\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCACHEREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCACHEREQUEST_JSON: CLEARCACHEREQUEST_JSON = CLEARCACHEREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for CLEARCACHEREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CLEARCACHEREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearCache.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCACHEREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCACHEREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCACHEREQUEST_VALIDATOR: CLEARCACHEREQUEST_VALIDATOR =
            CLEARCACHEREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CLEARCACHEREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CLEARCACHEREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearCache.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCACHEREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ClearCacheRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CLEARCACHEREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_cache.rs:12",
                                    "ocpp::server_init::clear_cache",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/clear_cache.rs"),
                                    Some(12u32),
                                    Some("ocpp::server_init::clear_cache"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_cache.rs:12",
                                    "ocpp::server_init::clear_cache",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/clear_cache.rs"),
                                    Some(12u32),
                                    Some("ocpp::server_init::clear_cache"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ClearCache.req PDU sent by the Central System to the Charge Point.
        pub struct ClearCacheRequest {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ClearCacheRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ClearCacheRequest",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ClearCacheRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ClearCacheRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ClearCacheRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ClearCacheRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(ClearCacheRequest {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(ClearCacheRequest {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ClearCacheRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ClearCacheRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ClearCacheRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "ClearCacheRequest")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ClearCacheRequest {
            #[inline]
            fn clone(&self) -> ClearCacheRequest {
                ClearCacheRequest {}
            }
        }
        const CLEARCACHERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"ClearCacheResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCACHERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCACHERESPONSE_JSON: CLEARCACHERESPONSE_JSON = CLEARCACHERESPONSE_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for CLEARCACHERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CLEARCACHERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearCacheResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCACHERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCACHERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCACHERESPONSE_VALIDATOR: CLEARCACHERESPONSE_VALIDATOR =
            CLEARCACHERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CLEARCACHERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CLEARCACHERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearCacheResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCACHERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ClearCacheResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CLEARCACHERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_cache.rs:19",
                                    "ocpp::server_init::clear_cache",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/clear_cache.rs"),
                                    Some(19u32),
                                    Some("ocpp::server_init::clear_cache"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_cache.rs:19",
                                    "ocpp::server_init::clear_cache",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/clear_cache.rs"),
                                    Some(19u32),
                                    Some("ocpp::server_init::clear_cache"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ClearCache.conf PDU sent by the Charge Point to the Central System in Response to a ClearCache.
        pub struct ClearCacheResponse {
            /// Required. Accepted if the Charge Point has executed the request, otherwise rejected.
            pub status: SimpleStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ClearCacheResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ClearCacheResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ClearCacheResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ClearCacheResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ClearCacheResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ClearCacheResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                SimpleStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ClearCacheResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ClearCacheResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<SimpleStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<SimpleStatus>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ClearCacheResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ClearCacheResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ClearCacheResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ClearCacheResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ClearCacheResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ClearCacheResponse {
            #[inline]
            fn clone(&self) -> ClearCacheResponse {
                ClearCacheResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
    }
    pub mod clear_charging_profile {
        //! Server request for a ChargePoint to clear its Charging Profile
        //!
        //! The Charge Point SHALL respond with a ClearChargingProfile.conf PDU specifying whether it was able to process the request.
        use crate::validation_macros::{self, json_validate};
        use crate::ChargingProfilePurpose;
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        const CLEARCHARGINGPROFILEREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:ClearChargingProfileRequest\",\r\n    \"title\": \"ClearChargingProfileRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"id\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"chargingProfilePurpose\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"ChargePointMaxProfile\",\r\n                \"TxDefaultProfile\",\r\n                \"TxProfile\"\r\n            ]\r\n        },\r\n        \"stackLevel\": {\r\n            \"type\": \"integer\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCHARGINGPROFILEREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCHARGINGPROFILEREQUEST_JSON: CLEARCHARGINGPROFILEREQUEST_JSON =
            CLEARCHARGINGPROFILEREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CLEARCHARGINGPROFILEREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CLEARCHARGINGPROFILEREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearChargingProfile.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCHARGINGPROFILEREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCHARGINGPROFILEREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCHARGINGPROFILEREQUEST_VALIDATOR: CLEARCHARGINGPROFILEREQUEST_VALIDATOR =
            CLEARCHARGINGPROFILEREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CLEARCHARGINGPROFILEREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CLEARCHARGINGPROFILEREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearChargingProfile.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCHARGINGPROFILEREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ClearChargingProfileRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CLEARCHARGINGPROFILEREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_charging_profile.rs:12",
                                    "ocpp::server_init::clear_charging_profile",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/clear_charging_profile.rs"),
                                    Some(12u32),
                                    Some("ocpp::server_init::clear_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_charging_profile.rs:12",
                                    "ocpp::server_init::clear_charging_profile",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/clear_charging_profile.rs"),
                                    Some(12u32),
                                    Some("ocpp::server_init::clear_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ClearChargingProfile.req PDU sent by the Central System to the Charge Point.
        ///
        /// The Central System can use this message to clear (remove) either a specific charging profile (denoted by id) or a selection
        /// of charging profiles that match with the values of the optional connectorId, stackLevel and chargingProfilePurpose fields.
        pub struct ClearChargingProfileRequest {
            /// Optional. The ID of the charging profile to clear.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub id: Option<u32>,
            /// Optional. Specifies the ID of the connector for which to clear charging profiles. A connectorId of zero (0) specifies the charging profile for the overall Charge Point.
            /// Absence of this parameter means the clearing applies to all charging profiles that match the other criteria in the request.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub connector_id: Option<u32>,
            /// Optional. Specifies to purpose of the charging profiles that will be cleared, if they meet the other criteria in the request.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub charging_profile_purpose: Option<ChargingProfilePurpose>,
            /// Optional. specifies the stackLevel for which charging profiles will be cleared, if they meet the other criteria in the request
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stack_level: Option<u32>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ClearChargingProfileRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ClearChargingProfileRequest",
                        false as usize
                            + if Option::is_none(&self.id) { 0 } else { 1 }
                            + if Option::is_none(&self.connector_id) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.charging_profile_purpose) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.stack_level) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "id") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.connector_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "connectorId",
                            &self.connector_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "connectorId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.charging_profile_purpose) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chargingProfilePurpose",
                            &self.charging_profile_purpose,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "chargingProfilePurpose",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.stack_level) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "stackLevel",
                            &self.stack_level,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "stackLevel",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ClearChargingProfileRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "connectorId" => _serde::__private::Ok(__Field::__field1),
                                "chargingProfilePurpose" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "stackLevel" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"connectorId" => _serde::__private::Ok(__Field::__field1),
                                b"chargingProfilePurpose" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"stackLevel" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ClearChargingProfileRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ClearChargingProfileRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ClearChargingProfileRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ClearChargingProfileRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ClearChargingProfileRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<ChargingProfilePurpose>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ClearChargingProfileRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ClearChargingProfileRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ClearChargingProfileRequest {
                                id: __field0,
                                connector_id: __field1,
                                charging_profile_purpose: __field2,
                                stack_level: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<ChargingProfilePurpose>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingProfilePurpose",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ChargingProfilePurpose>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stackLevel",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "chargingProfilePurpose",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("stackLevel") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ClearChargingProfileRequest {
                                id: __field0,
                                connector_id: __field1,
                                charging_profile_purpose: __field2,
                                stack_level: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["id", "connectorId", "chargingProfilePurpose", "stackLevel"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ClearChargingProfileRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ClearChargingProfileRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ClearChargingProfileRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ClearChargingProfileRequest",
                    "id",
                    &&self.id,
                    "connector_id",
                    &&self.connector_id,
                    "charging_profile_purpose",
                    &&self.charging_profile_purpose,
                    "stack_level",
                    &&self.stack_level,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ClearChargingProfileRequest {
            #[inline]
            fn clone(&self) -> ClearChargingProfileRequest {
                ClearChargingProfileRequest {
                    id: ::core::clone::Clone::clone(&self.id),
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    charging_profile_purpose: ::core::clone::Clone::clone(
                        &self.charging_profile_purpose,
                    ),
                    stack_level: ::core::clone::Clone::clone(&self.stack_level),
                }
            }
        }
        const CLEARCHARGINGPROFILERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"ClearChargingProfileResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Unknown\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCHARGINGPROFILERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCHARGINGPROFILERESPONSE_JSON: CLEARCHARGINGPROFILERESPONSE_JSON =
            CLEARCHARGINGPROFILERESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CLEARCHARGINGPROFILERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(CLEARCHARGINGPROFILERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearChargingProfileResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCHARGINGPROFILERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct CLEARCHARGINGPROFILERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static CLEARCHARGINGPROFILERESPONSE_VALIDATOR: CLEARCHARGINGPROFILERESPONSE_VALIDATOR =
            CLEARCHARGINGPROFILERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for CLEARCHARGINGPROFILERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&CLEARCHARGINGPROFILERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ClearChargingProfileResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for CLEARCHARGINGPROFILERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ClearChargingProfileResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = CLEARCHARGINGPROFILERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_charging_profile.rs:33",
                                    "ocpp::server_init::clear_charging_profile",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/clear_charging_profile.rs"),
                                    Some(33u32),
                                    Some("ocpp::server_init::clear_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/clear_charging_profile.rs:33",
                                    "ocpp::server_init::clear_charging_profile",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/clear_charging_profile.rs"),
                                    Some(33u32),
                                    Some("ocpp::server_init::clear_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the ClearChargingProfile.conf PDU sent by the Charge Point to the Central System in response to a ClearChargingProfile.req PDU.
        pub struct ClearChargingProfileResponse {
            /// Required. Indicates if the Charge Point was able to execute the request.
            pub status: ClearChargeProfileStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ClearChargingProfileResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ClearChargingProfileResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ClearChargingProfileResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ClearChargingProfileResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ClearChargingProfileResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ClearChargingProfileResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ClearChargeProfileStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ClearChargingProfileResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ClearChargingProfileResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ClearChargeProfileStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ClearChargeProfileStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ClearChargingProfileResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ClearChargingProfileResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ClearChargingProfileResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ClearChargingProfileResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ClearChargingProfileResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ClearChargingProfileResponse {
            #[inline]
            fn clone(&self) -> ClearChargingProfileResponse {
                ClearChargingProfileResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status returned in response to ClearChargingProfile.req.
        pub enum ClearChargeProfileStatus {
            /// Request has been accepted and will be executed.
            Accepted,
            /// No Charging Profile(s) were found matching the request.
            Unknown,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ClearChargeProfileStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ClearChargeProfileStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ClearChargeProfileStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        ClearChargeProfileStatus::Unknown => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ClearChargeProfileStatus",
                                1u32,
                                "Unknown",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ClearChargeProfileStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Unknown" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Unknown" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ClearChargeProfileStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ClearChargeProfileStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ClearChargeProfileStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ClearChargeProfileStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ClearChargeProfileStatus::Unknown)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Accepted", "Unknown"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ClearChargeProfileStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ClearChargeProfileStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ClearChargeProfileStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ClearChargeProfileStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&ClearChargeProfileStatus::Unknown,) => {
                        ::core::fmt::Formatter::write_str(f, "Unknown")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ClearChargeProfileStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ClearChargeProfileStatus {
            #[inline]
            fn eq(&self, other: &ClearChargeProfileStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ClearChargeProfileStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ClearChargeProfileStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ClearChargeProfileStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ClearChargeProfileStatus::Accepted => f.pad("Accepted"),
                    ClearChargeProfileStatus::Unknown => f.pad("Unknown"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ClearChargeProfileStatus {
            #[inline]
            fn clone(&self) -> ClearChargeProfileStatus {
                match (&*self,) {
                    (&ClearChargeProfileStatus::Accepted,) => ClearChargeProfileStatus::Accepted,
                    (&ClearChargeProfileStatus::Unknown,) => ClearChargeProfileStatus::Unknown,
                }
            }
        }
    }
    pub mod get_composite_schedule {
        //! Server request for a ChargePoint to send it's Composite Schedule
        //!
        //! # Behaviour
        //! The reported schedule, in the GetCompositeSchedule.conf PDU, is the result of the calculation of all active schedules and possible
        //! local limits present in the Charge Point. Local Limits might be taken into account.
        //!
        //! # Response
        //! Upon receipt of a GetCompositeSchedule.req, the Charge Point SHALL calculate the Composite Charging Schedule intervals, from the moment
        //! the request PDU is received: Time X, up to X + Duration, and send them in the GetCompositeSchedule.conf PDU to the Central System.
        //!
        //! If the ConnectorId in the request is set to '0', the Charge Point SHALL report the total expected power or current the Charge Point
        //! expects to consume from the grid during the requested time period.
        //!
        //! Please note that the charging schedule sent by the charge point is only indicative for that pointin time. this schedule might change
        //! over time due to external causes (for instance, local balancing based on grid connection capacity is active and one Connector becomes available).
        //!
        //! If the Charge Point is not able to report the requested schedule, for instance if the connectorId is unknown, it SHALL respond with a status Rejected
        //!
        use crate::validation_macros::{self, json_validate};
        pub use crate::{ChargingRateUnit, ChargingSchedule, SimpleStatus};
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const GETCOMPOSITESCHEDULEREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:GetCompositeScheduleRequest\",\r\n    \"title\": \"GetCompositeScheduleRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n    \"duration\": {\r\n        \"type\": \"integer\"\r\n    },\r\n    \"chargingRateUnit\": {\r\n        \"type\": \"string\",\r\n        \"additionalProperties\": false,\r\n        \"enum\": [\r\n            \"A\",\r\n            \"W\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\",\r\n        \"duration\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCOMPOSITESCHEDULEREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCOMPOSITESCHEDULEREQUEST_JSON: GETCOMPOSITESCHEDULEREQUEST_JSON =
            GETCOMPOSITESCHEDULEREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCOMPOSITESCHEDULEREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETCOMPOSITESCHEDULEREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetCompositeSchedule.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCOMPOSITESCHEDULEREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCOMPOSITESCHEDULEREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCOMPOSITESCHEDULEREQUEST_VALIDATOR: GETCOMPOSITESCHEDULEREQUEST_VALIDATOR =
            GETCOMPOSITESCHEDULEREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCOMPOSITESCHEDULEREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETCOMPOSITESCHEDULEREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetCompositeSchedule.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCOMPOSITESCHEDULEREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetCompositeScheduleRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETCOMPOSITESCHEDULEREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_composite_schedule.rs:27",
                                    "ocpp::server_init::get_composite_schedule",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_composite_schedule.rs"),
                                    Some(27u32),
                                    Some("ocpp::server_init::get_composite_schedule"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_composite_schedule.rs:27",
                                    "ocpp::server_init::get_composite_schedule",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_composite_schedule.rs"),
                                    Some(27u32),
                                    Some("ocpp::server_init::get_composite_schedule"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetCompositeSchedule.req PDU sent by the Central System to the Charge Point.
        pub struct GetCompositeScheduleRequest {
            /// Required. The ID of the Connector for which the schedule is requested. When ConnectorId=0, the Charge Point will calculate the expected consumption for the grid connection.
            connector_id: u32,
            /// Required. Time in seconds. length of requested schedule
            duration: u32,
            /// Optional. Can be used to force a power or current profile
            #[serde(skip_serializing_if = "Option::is_none")]
            charging_rate_unit: Option<ChargingRateUnit>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetCompositeScheduleRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetCompositeScheduleRequest",
                        false as usize
                            + 1
                            + 1
                            + if Option::is_none(&self.charging_rate_unit) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "duration",
                        &self.duration,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.charging_rate_unit) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chargingRateUnit",
                            &self.charging_rate_unit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "chargingRateUnit",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetCompositeScheduleRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "duration" => _serde::__private::Ok(__Field::__field1),
                                "chargingRateUnit" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"duration" => _serde::__private::Ok(__Field::__field1),
                                b"chargingRateUnit" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetCompositeScheduleRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetCompositeScheduleRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetCompositeScheduleRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetCompositeScheduleRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GetCompositeScheduleRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<ChargingRateUnit>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GetCompositeScheduleRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetCompositeScheduleRequest {
                                connector_id: __field0,
                                duration: __field1,
                                charging_rate_unit: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<ChargingRateUnit>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "duration",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingRateUnit",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ChargingRateUnit>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("duration") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargingRateUnit") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetCompositeScheduleRequest {
                                connector_id: __field0,
                                duration: __field1,
                                charging_rate_unit: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["connectorId", "duration", "chargingRateUnit"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetCompositeScheduleRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetCompositeScheduleRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetCompositeScheduleRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "GetCompositeScheduleRequest",
                    "connector_id",
                    &&self.connector_id,
                    "duration",
                    &&self.duration,
                    "charging_rate_unit",
                    &&self.charging_rate_unit,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetCompositeScheduleRequest {
            #[inline]
            fn clone(&self) -> GetCompositeScheduleRequest {
                GetCompositeScheduleRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    duration: ::core::clone::Clone::clone(&self.duration),
                    charging_rate_unit: ::core::clone::Clone::clone(&self.charging_rate_unit),
                }
            }
        }
        const GETCOMPOSITESCHEDULERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"GetCompositeScheduleResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\"\n            ]\n        },\n    \"connectorId\": {\n        \"type\": \"integer\"\n        },\n    \"scheduleStart\": {\n        \"type\": \"string\",\n        \"format\": \"date-time\"\n    },\n    \"chargingSchedule\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"duration\": {\n                \"type\": \"integer\"\n            },\n            \"startSchedule\": {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n            },\n            \"chargingRateUnit\": {\n                \"type\": \"string\",\n                \"additionalProperties\": false,\n                \"enum\": [\n                    \"A\",\n                    \"W\"\n                    ]\n            },\n            \"chargingSchedulePeriod\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"startPeriod\": {\n                            \"type\": \"integer\"\n                        },\n                        \"limit\": {\n                            \"type\": \"number\",\n                            \"multipleOf\" : 0.1\n                        },\n                        \"numberPhases\": {\n                            \"type\": \"integer\"\n                        }\n                    },\n                    \"additionalProperties\": false,\n                    \"required\": [\n                        \"startPeriod\",\n                        \"limit\"\n                        ]\n                }\n            },\n            \"minChargingRate\": {\n                \"type\": \"number\",\n                \"multipleOf\" : 0.1\n            }\n        },\n        \"additionalProperties\": false,\n        \"required\": [\n            \"chargingRateUnit\",\n            \"chargingSchedulePeriod\"\n        ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCOMPOSITESCHEDULERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCOMPOSITESCHEDULERESPONSE_JSON: GETCOMPOSITESCHEDULERESPONSE_JSON =
            GETCOMPOSITESCHEDULERESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCOMPOSITESCHEDULERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETCOMPOSITESCHEDULERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetCompositeScheduleResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCOMPOSITESCHEDULERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCOMPOSITESCHEDULERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCOMPOSITESCHEDULERESPONSE_VALIDATOR: GETCOMPOSITESCHEDULERESPONSE_VALIDATOR =
            GETCOMPOSITESCHEDULERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCOMPOSITESCHEDULERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETCOMPOSITESCHEDULERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetCompositeScheduleResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCOMPOSITESCHEDULERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetCompositeScheduleResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETCOMPOSITESCHEDULERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_composite_schedule.rs:56",
                                    "ocpp::server_init::get_composite_schedule",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_composite_schedule.rs"),
                                    Some(56u32),
                                    Some("ocpp::server_init::get_composite_schedule"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_composite_schedule.rs:56",
                                    "ocpp::server_init::get_composite_schedule",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_composite_schedule.rs"),
                                    Some(56u32),
                                    Some("ocpp::server_init::get_composite_schedule"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetCompositeSchedule.conf PDU sent by the Charge Point to the Central System in response to a GetCompositeSchedule.req PDU.
        pub struct GetCompositeScheduleResponse {
            /// Required. Status of the request. The Charge Point will indicate if it was able to process the request
            pub status: SimpleStatus,
            /// Optional. The charging schedule contained in this notitication applies to a Connector
            #[serde(skip_serializing_if = "Option::is_none")]
            pub connector_id: Option<u32>,
            /// Optional. Time. Periods contained in the charging profile are relative to this point in time. If status is "Rejected", this field may be absent.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub schedule_start: Option<DateTime<Utc>>,
            /// Optional. Planned Composite Charging Schedule, the energy consumption over time. Always relative to ScheduleStart. If status is "Rejected", this field may be absent.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub charging_schedule: Option<ChargingSchedule>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetCompositeScheduleResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetCompositeScheduleResponse",
                        false as usize
                            + 1
                            + if Option::is_none(&self.connector_id) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.schedule_start) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.charging_schedule) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.connector_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "connectorId",
                            &self.connector_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "connectorId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.schedule_start) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "scheduleStart",
                            &self.schedule_start,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "scheduleStart",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.charging_schedule) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chargingSchedule",
                            &self.charging_schedule,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "chargingSchedule",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetCompositeScheduleResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                "connectorId" => _serde::__private::Ok(__Field::__field1),
                                "scheduleStart" => _serde::__private::Ok(__Field::__field2),
                                "chargingSchedule" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                b"connectorId" => _serde::__private::Ok(__Field::__field1),
                                b"scheduleStart" => _serde::__private::Ok(__Field::__field2),
                                b"chargingSchedule" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetCompositeScheduleResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetCompositeScheduleResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetCompositeScheduleResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                SimpleStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetCompositeScheduleResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GetCompositeScheduleResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GetCompositeScheduleResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<ChargingSchedule>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct GetCompositeScheduleResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetCompositeScheduleResponse {
                                status: __field0,
                                connector_id: __field1,
                                schedule_start: __field2,
                                charging_schedule: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<SimpleStatus> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<ChargingSchedule>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<SimpleStatus>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "scheduleStart",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingSchedule",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ChargingSchedule>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("scheduleStart") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargingSchedule") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetCompositeScheduleResponse {
                                status: __field0,
                                connector_id: __field1,
                                schedule_start: __field2,
                                charging_schedule: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["status", "connectorId", "scheduleStart", "chargingSchedule"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetCompositeScheduleResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetCompositeScheduleResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetCompositeScheduleResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "GetCompositeScheduleResponse",
                    "status",
                    &&self.status,
                    "connector_id",
                    &&self.connector_id,
                    "schedule_start",
                    &&self.schedule_start,
                    "charging_schedule",
                    &&self.charging_schedule,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetCompositeScheduleResponse {
            #[inline]
            fn clone(&self) -> GetCompositeScheduleResponse {
                GetCompositeScheduleResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    schedule_start: ::core::clone::Clone::clone(&self.schedule_start),
                    charging_schedule: ::core::clone::Clone::clone(&self.charging_schedule),
                }
            }
        }
    }
    pub mod get_configuration {
        //! Server request for a ChargePoint to send its current configuration
        //!
        //! # Behaviour
        //! The number of configuration keys requested in a single PDU MAY be limited by the Charge Point. This maximum can be retrieved by reading
        //! the configuration key GetConfigurationMaxKeys.
        //!
        //! # Response
        //! If the list of keys in the request PDU is empty or missing (it is optional), the Charge Point SHALL return a list of all configuration
        //! settings in GetConfiguration.conf. Otherwise Charge Point SHALL return a list of recognized keys and their corresponding values and read-only
        //! state. Unrecognized keys SHALL be placed in the response PDU as part of the optional unknown key list element of GetConfiguration.conf.
        //!
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const GETCONFIGURATIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:GetConfigurationRequest\",\r\n    \"title\": \"GetConfigurationRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"key\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": \"string\",\r\n                \"maxLength\": 50\r\n            }\r\n        }\r\n    },\r\n    \"additionalProperties\": false\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCONFIGURATIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCONFIGURATIONREQUEST_JSON: GETCONFIGURATIONREQUEST_JSON =
            GETCONFIGURATIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCONFIGURATIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETCONFIGURATIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetConfiguration.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCONFIGURATIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCONFIGURATIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCONFIGURATIONREQUEST_VALIDATOR: GETCONFIGURATIONREQUEST_VALIDATOR =
            GETCONFIGURATIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCONFIGURATIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETCONFIGURATIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetConfiguration.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCONFIGURATIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetConfigurationRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETCONFIGURATIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_configuration.rs:18",
                                    "ocpp::server_init::get_configuration",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_configuration.rs"),
                                    Some(18u32),
                                    Some("ocpp::server_init::get_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_configuration.rs:18",
                                    "ocpp::server_init::get_configuration",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_configuration.rs"),
                                    Some(18u32),
                                    Some("ocpp::server_init::get_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetConfiguration.req PDU sent by the Central System to the Charge Point.
        pub struct GetConfigurationRequest {
            /// Optional. List of keys for which the configuration value is requested. Keys are separated by ','
            #[serde(skip_serializing_if = "Option::is_none")]
            pub key: Option<String>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetConfigurationRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetConfigurationRequest",
                        false as usize + if Option::is_none(&self.key) { 0 } else { 1 },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.key) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "key") {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetConfigurationRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetConfigurationRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetConfigurationRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetConfigurationRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetConfigurationRequest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetConfigurationRequest { key: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("key") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetConfigurationRequest { key: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["key"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetConfigurationRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetConfigurationRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetConfigurationRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "GetConfigurationRequest",
                    "key",
                    &&self.key,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetConfigurationRequest {
            #[inline]
            fn clone(&self) -> GetConfigurationRequest {
                GetConfigurationRequest {
                    key: ::core::clone::Clone::clone(&self.key),
                }
            }
        }
        const GETCONFIGURATIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"GetConfigurationResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"configurationKey\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"key\": {\n                        \"type\": \"string\",\n                        \"maxLength\": 50\n                    },\n                    \"readonly\": {\n                        \"type\": \"boolean\"\n                    },\n                    \"value\": {\n                        \"type\": \"string\",\n                        \"maxLength\": 500\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"key\",\n                    \"readonly\"\n                ]\n            }\n        },\n        \"unknownKey\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\",\n                \"maxLength\": 50\n            }\n        }\n    },\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCONFIGURATIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCONFIGURATIONRESPONSE_JSON: GETCONFIGURATIONRESPONSE_JSON =
            GETCONFIGURATIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCONFIGURATIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETCONFIGURATIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetConfigurationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCONFIGURATIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETCONFIGURATIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETCONFIGURATIONRESPONSE_VALIDATOR: GETCONFIGURATIONRESPONSE_VALIDATOR =
            GETCONFIGURATIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETCONFIGURATIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETCONFIGURATIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetConfigurationResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETCONFIGURATIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetConfigurationResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETCONFIGURATIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_configuration.rs:29",
                                    "ocpp::server_init::get_configuration",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_configuration.rs"),
                                    Some(29u32),
                                    Some("ocpp::server_init::get_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_configuration.rs:29",
                                    "ocpp::server_init::get_configuration",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_configuration.rs"),
                                    Some(29u32),
                                    Some("ocpp::server_init::get_configuration"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetConfiguration.conf PDU sent by Charge Point the to the Central System in response to a GetConfiguration.req.
        pub struct GetConfigurationResponse {
            /// Optional. List of requested or known keys
            #[serde(skip_serializing_if = "Option::is_none")]
            pub configuration_key: Option<Vec<KeyValue>>,
            /// Optional. Requested keys that are unknown
            #[serde(skip_serializing_if = "Option::is_none")]
            pub unknown_key: Option<Vec<String>>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetConfigurationResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetConfigurationResponse",
                        false as usize
                            + if Option::is_none(&self.configuration_key) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.unknown_key) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.configuration_key) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "configurationKey",
                            &self.configuration_key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "configurationKey",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.unknown_key) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unknownKey",
                            &self.unknown_key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "unknownKey",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetConfigurationResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "configurationKey" => _serde::__private::Ok(__Field::__field0),
                                "unknownKey" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"configurationKey" => _serde::__private::Ok(__Field::__field0),
                                b"unknownKey" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetConfigurationResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetConfigurationResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetConfigurationResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<Vec<KeyValue>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetConfigurationResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<Vec<String>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GetConfigurationResponse with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetConfigurationResponse {
                                configuration_key: __field0,
                                unknown_key: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<Vec<KeyValue>>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<Vec<String>>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "configurationKey",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Vec<KeyValue>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unknownKey",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Vec<String>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("configurationKey") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("unknownKey") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetConfigurationResponse {
                                configuration_key: __field0,
                                unknown_key: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["configurationKey", "unknownKey"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetConfigurationResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetConfigurationResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetConfigurationResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "GetConfigurationResponse",
                    "configuration_key",
                    &&self.configuration_key,
                    "unknown_key",
                    &&self.unknown_key,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetConfigurationResponse {
            #[inline]
            fn clone(&self) -> GetConfigurationResponse {
                GetConfigurationResponse {
                    configuration_key: ::core::clone::Clone::clone(&self.configuration_key),
                    unknown_key: ::core::clone::Clone::clone(&self.unknown_key),
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Contains information about a specific configuration key. It is returned in GetConfiguration.conf.
        pub struct KeyValue {
            /// Key
            pub key: String,
            /// Required. False if the value can be set with the ChangeConfiguration message.
            pub readonly: bool,
            /// Optional. If key is known but not set, this field may be absent.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub value: Option<String>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for KeyValue {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "KeyValue",
                        false as usize + 1 + 1 + if Option::is_none(&self.value) { 0 } else { 1 },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "key",
                        &self.key,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "readonly",
                        &self.readonly,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.value) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            &self.value,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "value")
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for KeyValue {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "key" => _serde::__private::Ok(__Field::__field0),
                                "readonly" => _serde::__private::Ok(__Field::__field1),
                                "value" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"key" => _serde::__private::Ok(__Field::__field0),
                                b"readonly" => _serde::__private::Ok(__Field::__field1),
                                b"value" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<KeyValue>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = KeyValue;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "struct KeyValue")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KeyValue with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct KeyValue with 3 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct KeyValue with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(KeyValue {
                                key: __field0,
                                readonly: __field1,
                                value: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<String>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "key",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "readonly",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<bool>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("key") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("readonly") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("value") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(KeyValue {
                                key: __field0,
                                readonly: __field1,
                                value: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["key", "readonly", "value"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "KeyValue",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KeyValue>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for KeyValue {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "KeyValue",
                    "key",
                    &&self.key,
                    "readonly",
                    &&self.readonly,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for KeyValue {
            #[inline]
            fn clone(&self) -> KeyValue {
                KeyValue {
                    key: ::core::clone::Clone::clone(&self.key),
                    readonly: ::core::clone::Clone::clone(&self.readonly),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
    }
    pub mod get_diagnostics {
        //! Server request for a ChargePoint to send diagnostic information
        //!
        //! # Behaviour
        //! The Central System SHALL send a GetDiagnostics.req PDU for getting diagnostic information of a Charge Point with a
        //! location where the Charge Point MUST upload its diagnostic data to and optionally a begin and end time for the requested diagnostic information.
        //!
        //! # Response
        //! Upon receipt of a GetDiagnostics.req PDU, and if diagnostics information is available then Charge Point SHALL respond
        //! with a GetDiagnostics.conf PDU stating the name of the file containing the diagnostic information that will be uploaded.
        //! Charge Point SHALL upload a single file. Format of the diagnostics file is not prescribed. If no diagnostics file is available,
        //! then GetDiagnostics.conf SHALL NOT contain a file name.
        //!
        //! During uploading of a diagnostics file, the Charge Point MUST send DiagnosticsStatusNotification.req PDUs to keep the Central
        //! System updated with the status of the upload process.
        use crate::validation_macros::{self, json_validate};
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const GETDIAGNOSTICSREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:GetDiagnosticsRequest\",\r\n    \"title\": \"GetDiagnosticsRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"location\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uri\"\r\n        },\r\n        \"retries\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"retryInterval\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"startTime\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n        },\r\n        \"stopTime\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"location\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETDIAGNOSTICSREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETDIAGNOSTICSREQUEST_JSON: GETDIAGNOSTICSREQUEST_JSON =
            GETDIAGNOSTICSREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETDIAGNOSTICSREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETDIAGNOSTICSREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetDiagnostics.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETDIAGNOSTICSREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETDIAGNOSTICSREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETDIAGNOSTICSREQUEST_VALIDATOR: GETDIAGNOSTICSREQUEST_VALIDATOR =
            GETDIAGNOSTICSREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETDIAGNOSTICSREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETDIAGNOSTICSREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetDiagnostics.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETDIAGNOSTICSREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetDiagnosticsRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETDIAGNOSTICSREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_diagnostics.rs:22",
                                    "ocpp::server_init::get_diagnostics",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_diagnostics.rs"),
                                    Some(22u32),
                                    Some("ocpp::server_init::get_diagnostics"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_diagnostics.rs:22",
                                    "ocpp::server_init::get_diagnostics",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_diagnostics.rs"),
                                    Some(22u32),
                                    Some("ocpp::server_init::get_diagnostics"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetDiagnostics.req PDU sent by the Central System to the Charge Point.
        pub struct GetDiagnosticsRequest {
            /// Required. This contains the location (directory) where the diagnostics file shall be uploaded to.
            pub location: String,
            /// Optional. This specifies how many times Charge Point must try to upload the diagnostics before giving up. If this field is not present, it is left to Charge Point to decide how many times it wants to retry.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub retries: Option<u32>,
            /// Optional. The interval in seconds after which a retry may be attempted. If this field is not present, it is left to Charge Point to decide how long to wait between attempts.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub retry_interval: Option<u32>,
            /// Optional. This contains the date and time of the oldest logging information to include in the diagnostics.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub start_time: Option<DateTime<Utc>>,
            /// Optional. This contains the date and time of the latest logging information to include in the diagnostics.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub stop_time: Option<DateTime<Utc>>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetDiagnosticsRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetDiagnosticsRequest",
                        false as usize
                            + 1
                            + if Option::is_none(&self.retries) { 0 } else { 1 }
                            + if Option::is_none(&self.retry_interval) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.start_time) {
                                0
                            } else {
                                1
                            }
                            + if Option::is_none(&self.stop_time) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "location",
                        &self.location,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.retries) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "retries",
                            &self.retries,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "retries",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.retry_interval) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "retryInterval",
                            &self.retry_interval,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "retryInterval",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.start_time) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "startTime",
                            &self.start_time,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "startTime",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.stop_time) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "stopTime",
                            &self.stop_time,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "stopTime",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetDiagnosticsRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "location" => _serde::__private::Ok(__Field::__field0),
                                "retries" => _serde::__private::Ok(__Field::__field1),
                                "retryInterval" => _serde::__private::Ok(__Field::__field2),
                                "startTime" => _serde::__private::Ok(__Field::__field3),
                                "stopTime" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"location" => _serde::__private::Ok(__Field::__field0),
                                b"retries" => _serde::__private::Ok(__Field::__field1),
                                b"retryInterval" => _serde::__private::Ok(__Field::__field2),
                                b"startTime" => _serde::__private::Ok(__Field::__field3),
                                b"stopTime" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetDiagnosticsRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetDiagnosticsRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetDiagnosticsRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetDiagnosticsRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GetDiagnosticsRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GetDiagnosticsRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct GetDiagnosticsRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<DateTime<Utc>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct GetDiagnosticsRequest with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetDiagnosticsRequest {
                                location: __field0,
                                retries: __field1,
                                retry_interval: __field2,
                                start_time: __field3,
                                stop_time: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<DateTime<Utc>>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "location",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "retries",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "retryInterval",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "startTime",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stopTime",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<DateTime<Utc>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("location") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("retries") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("retryInterval") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("startTime") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("stopTime") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetDiagnosticsRequest {
                                location: __field0,
                                retries: __field1,
                                retry_interval: __field2,
                                start_time: __field3,
                                stop_time: __field4,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "location",
                        "retries",
                        "retryInterval",
                        "startTime",
                        "stopTime",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetDiagnosticsRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetDiagnosticsRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetDiagnosticsRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "GetDiagnosticsRequest",
                    "location",
                    &&self.location,
                    "retries",
                    &&self.retries,
                    "retry_interval",
                    &&self.retry_interval,
                    "start_time",
                    &&self.start_time,
                    "stop_time",
                    &&self.stop_time,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetDiagnosticsRequest {
            #[inline]
            fn clone(&self) -> GetDiagnosticsRequest {
                GetDiagnosticsRequest {
                    location: ::core::clone::Clone::clone(&self.location),
                    retries: ::core::clone::Clone::clone(&self.retries),
                    retry_interval: ::core::clone::Clone::clone(&self.retry_interval),
                    start_time: ::core::clone::Clone::clone(&self.start_time),
                    stop_time: ::core::clone::Clone::clone(&self.stop_time),
                }
            }
        }
        const GETDIAGNOSTICSRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"GetDiagnosticsResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"fileName\": {\n            \"type\": \"string\",\n            \"maxLength\": 255\n        }\n    },\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETDIAGNOSTICSRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETDIAGNOSTICSRESPONSE_JSON: GETDIAGNOSTICSRESPONSE_JSON =
            GETDIAGNOSTICSRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETDIAGNOSTICSRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETDIAGNOSTICSRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetDiagnosticsResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETDIAGNOSTICSRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETDIAGNOSTICSRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETDIAGNOSTICSRESPONSE_VALIDATOR: GETDIAGNOSTICSRESPONSE_VALIDATOR =
            GETDIAGNOSTICSRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETDIAGNOSTICSRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETDIAGNOSTICSRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetDiagnosticsResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETDIAGNOSTICSRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetDiagnosticsResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETDIAGNOSTICSRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_diagnostics.rs:41",
                                    "ocpp::server_init::get_diagnostics",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_diagnostics.rs"),
                                    Some(41u32),
                                    Some("ocpp::server_init::get_diagnostics"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_diagnostics.rs:41",
                                    "ocpp::server_init::get_diagnostics",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_diagnostics.rs"),
                                    Some(41u32),
                                    Some("ocpp::server_init::get_diagnostics"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetDiagnostics.conf PDU sent by the Charge Point to the Central System in response to a GetDiagnostics.req PDU.
        pub struct GetDiagnosticsResponse {
            /// Optional. This contains the name of the file with diagnostic information that will be uploaded. This field is not present when no diagnostic information is available.
            pub file_name: String,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetDiagnosticsResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetDiagnosticsResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "fileName",
                        &self.file_name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetDiagnosticsResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "fileName" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"fileName" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetDiagnosticsResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetDiagnosticsResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetDiagnosticsResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetDiagnosticsResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetDiagnosticsResponse {
                                file_name: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "fileName",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("fileName") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetDiagnosticsResponse {
                                file_name: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["fileName"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetDiagnosticsResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetDiagnosticsResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetDiagnosticsResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "GetDiagnosticsResponse",
                    "file_name",
                    &&self.file_name,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetDiagnosticsResponse {
            #[inline]
            fn clone(&self) -> GetDiagnosticsResponse {
                GetDiagnosticsResponse {
                    file_name: ::core::clone::Clone::clone(&self.file_name),
                }
            }
        }
    }
    pub mod get_local_list_version {
        //! Server request for a ChargePoint to send it's local auth list version.
        //!
        //! # Behaviour
        //! In order to support synchronisation of the Local Authorization List, Central System can request a Charge Point for the
        //! version number of the Local Authorization List. The Central System SHALL send a GetLocalListVersion.req PDU to request this value.
        //!
        //! # Response
        //! Upon receipt of a GetLocalListVersion.req PDU Charge Point SHALL respond with a GetLocalListVersion.conf PDU containing
        //! the version number of its Local Authorization List. A version number of 0 (zero) SHALL be used to indicate that the local
        //! authorization list is empty, and a version number of -1 SHALL be used to indicate that the Charge Point does not support Local
        //! Authorization Lists.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        const GETLOCALLISTVERSIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:GetLocalListVersionRequest\",\r\n    \"title\": \"GetLocalListVersionRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {},\r\n    \"additionalProperties\": false\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETLOCALLISTVERSIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETLOCALLISTVERSIONREQUEST_JSON: GETLOCALLISTVERSIONREQUEST_JSON =
            GETLOCALLISTVERSIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETLOCALLISTVERSIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETLOCALLISTVERSIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetLocalListVersion.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETLOCALLISTVERSIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETLOCALLISTVERSIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETLOCALLISTVERSIONREQUEST_VALIDATOR: GETLOCALLISTVERSIONREQUEST_VALIDATOR =
            GETLOCALLISTVERSIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETLOCALLISTVERSIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETLOCALLISTVERSIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetLocalListVersion.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETLOCALLISTVERSIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetLocalListVersionRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETLOCALLISTVERSIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_local_list_version.rs:17",
                                    "ocpp::server_init::get_local_list_version",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_local_list_version.rs"),
                                    Some(17u32),
                                    Some("ocpp::server_init::get_local_list_version"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_local_list_version.rs:17",
                                    "ocpp::server_init::get_local_list_version",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_local_list_version.rs"),
                                    Some(17u32),
                                    Some("ocpp::server_init::get_local_list_version"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetLocalListVersion.req PDU sent by the Central System to the Charge Point
        pub struct GetLocalListVersionRequest {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetLocalListVersionRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetLocalListVersionRequest",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetLocalListVersionRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetLocalListVersionRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetLocalListVersionRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetLocalListVersionRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(GetLocalListVersionRequest {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(GetLocalListVersionRequest {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetLocalListVersionRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetLocalListVersionRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetLocalListVersionRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "GetLocalListVersionRequest")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetLocalListVersionRequest {
            #[inline]
            fn clone(&self) -> GetLocalListVersionRequest {
                GetLocalListVersionRequest {}
            }
        }
        const GETLOCALLISTVERSIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"GetLocalListVersionResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"listVersion\": {\n            \"type\": \"integer\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"listVersion\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETLOCALLISTVERSIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETLOCALLISTVERSIONRESPONSE_JSON: GETLOCALLISTVERSIONRESPONSE_JSON =
            GETLOCALLISTVERSIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETLOCALLISTVERSIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(GETLOCALLISTVERSIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetLocalListVersionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETLOCALLISTVERSIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct GETLOCALLISTVERSIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static GETLOCALLISTVERSIONRESPONSE_VALIDATOR: GETLOCALLISTVERSIONRESPONSE_VALIDATOR =
            GETLOCALLISTVERSIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for GETLOCALLISTVERSIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&GETLOCALLISTVERSIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/GetLocalListVersionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for GETLOCALLISTVERSIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for GetLocalListVersionResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = GETLOCALLISTVERSIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_local_list_version.rs:24",
                                    "ocpp::server_init::get_local_list_version",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/get_local_list_version.rs"),
                                    Some(24u32),
                                    Some("ocpp::server_init::get_local_list_version"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/get_local_list_version.rs:24",
                                    "ocpp::server_init::get_local_list_version",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/get_local_list_version.rs"),
                                    Some(24u32),
                                    Some("ocpp::server_init::get_local_list_version"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the GetLocalListVersion.conf PDU sent by the Charge Point to Central System in response to a GetLocalListVersion.req PDU.
        pub struct GetLocalListVersionResponse {
            /// Required. This contains the current version number of the local authorization list in the Charge Point.
            pub list_version: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GetLocalListVersionResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "GetLocalListVersionResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "listVersion",
                        &self.list_version,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GetLocalListVersionResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "listVersion" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"listVersion" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GetLocalListVersionResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GetLocalListVersionResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GetLocalListVersionResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GetLocalListVersionResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GetLocalListVersionResponse {
                                list_version: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "listVersion",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("listVersion") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(GetLocalListVersionResponse {
                                list_version: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["listVersion"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GetLocalListVersionResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GetLocalListVersionResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for GetLocalListVersionResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "GetLocalListVersionResponse",
                    "list_version",
                    &&self.list_version,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for GetLocalListVersionResponse {
            #[inline]
            fn clone(&self) -> GetLocalListVersionResponse {
                GetLocalListVersionResponse {
                    list_version: ::core::clone::Clone::clone(&self.list_version),
                }
            }
        }
    }
    pub mod remote_start_transaction {
        //! Server request to start a transaction (Can include a charge profile)
        //!
        //! # Behaviour
        //! The following typical use cases are the reason for Remote Start Transaction:
        //! * Enable a CPO operator to help an EV driver that has problems starting a transaction.
        //! * Enable mobile apps to control charging transactions via the Central System.
        //! * Enable the use of SMS to control charging transactions via the Central System.
        //!
        //! The RemoteStartTransaction.req SHALL contain an identifier (idTag), which Charge Point SHALL use, if it is able to start a transaction,
        //! to send a StartTransaction.req to Central System. The transaction is started in the same way as described in StartTransaction. The
        //! RemoteStartTransaction.req MAY contain a connector id if the transaction is to be started on a specific connector. When no connector
        //! id is provided, the Charge Point is in control of the connector selection. A Charge Point MAY reject a RemoteStartTransaction.req without a connector id.
        //!
        //! The Central System MAY include a ChargingProfile in the RemoteStartTransaction request. The purpose of this ChargingProfile SHALL be set
        //! to TxProfile. If accepted, the Charge Point SHALL use this ChargingProfile for the transaction. If a Charge Point without support for Smart
        //! Charging receives a RemoteStartTransaction.req with a Charging Profile, this parameter SHOULD be ignored.
        //!
        //! # Response
        //! Upon receipt, the Charge Point SHALL reply with RemoteStartTransaction.conf and a status indicating whether it has accepted the request and will attempt to start a transaction.
        //! The effect of the RemoteStartTransaction.req message depends on the value of the AuthorizeRemoteTxRequests configuration key in the Charge Point.
        //!
        //! * If the value of AuthorizeRemoteTxRequests is true, the Charge Point SHALL behave as if in response to a local action at the Charge Point
        //! to start a transaction with the idTag given in the RemoteStartTransaction.req message. This means that the Charge Point will first try to
        //! authorize the idTag, using the Local Authorization List, Authorization Cache and/or an Authorize.req request. A transaction will only be
        //! started after authorization was obtained.
        //! * If the value of AuthorizeRemoteTxRequests is false, the Charge Point SHALL immediately try to start a transaction for the idTag given in
        //! the RemoteStartTransaction.req message. Note that after the transaction has been started, the Charge Point will send a StartTransaction
        //! request to the Central System, and the Central System will check the authorization status of the idTag when processing this StartTransaction request.
        //!
        use crate::validation_macros::{self, json_validate};
        pub use crate::{ChargingProfile, SimpleStatus};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const REMOTESTARTTRANSACTIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:RemoteStartTransactionRequest\",\r\n    \"title\": \"RemoteStartTransactionRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"idTag\": {\r\n            \"type\": \"string\",\r\n            \"maxLength\": 20\r\n        },\r\n        \"chargingProfile\": {\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"chargingProfileId\": {\r\n                    \"type\": \"integer\"\r\n                },\r\n                \"transactionId\": {\r\n                    \"type\": \"integer\"\r\n                },\r\n                \"stackLevel\": {\r\n                    \"type\": \"integer\"\r\n                },\r\n                \"chargingProfilePurpose\": {\r\n                    \"type\": \"string\",\r\n                    \"additionalProperties\": false,\r\n                    \"enum\": [\r\n                        \"ChargePointMaxProfile\",\r\n                        \"TxDefaultProfile\",\r\n                        \"TxProfile\"\r\n                    ]\r\n                },\r\n                \"chargingProfileKind\": {\r\n                    \"type\": \"string\",\r\n                    \"additionalProperties\": false,\r\n                    \"enum\": [\r\n                        \"Absolute\",\r\n                        \"Recurring\",\r\n                        \"Relative\"\r\n                    ]\r\n                },\r\n                \"recurrencyKind\": {\r\n                    \"type\": \"string\",\r\n                    \"additionalProperties\": false,\r\n                    \"enum\": [\r\n                        \"Daily\",\r\n                        \"Weekly\"\r\n                    ]\r\n                },\r\n                \"validFrom\": {\r\n                    \"type\": \"string\",\r\n                    \"format\": \"date-time\"\r\n                },\r\n                \"validTo\": {\r\n                    \"type\": \"string\",\r\n                    \"format\": \"date-time\"\r\n                },\r\n                \"chargingSchedule\": {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"duration\": {\r\n                            \"type\": \"integer\"\r\n                        },\r\n                        \"startSchedule\": {\r\n                            \"type\": \"string\",\r\n                            \"format\": \"date-time\"\r\n                        },\r\n                        \"chargingRateUnit\": {\r\n                            \"type\": \"string\",\r\n                            \"additionalProperties\": false,\r\n                            \"enum\": [\r\n                                \"A\",\r\n                                \"W\"\r\n                            ]\r\n                        },\r\n                        \"chargingSchedulePeriod\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": {\r\n                                \"type\": \"object\",\r\n                                \"properties\": {\r\n                                    \"startPeriod\": {\r\n                                        \"type\": \"integer\"\r\n                                    },\r\n                                    \"limit\": {\r\n                                        \"type\": \"number\",\r\n                                        \"multipleOf\" : 0.1\r\n                                    },\r\n                                    \"numberPhases\": {\r\n                                        \"type\": \"integer\"\r\n                                    }\r\n                                },\r\n                                \"additionalProperties\": false,\r\n                                \"required\": [\r\n                                    \"startPeriod\",\r\n                                    \"limit\"\r\n                                ]\r\n                            }\r\n                        },\r\n                        \"minChargingRate\": {\r\n                            \"type\": \"number\",\r\n                            \"multipleOf\" : 0.1\r\n                        }\r\n                    },\r\n                    \"additionalProperties\": false,\r\n                    \"required\": [\r\n                        \"chargingRateUnit\",\r\n                        \"chargingSchedulePeriod\"\r\n                    ]\r\n                }\r\n            },\r\n            \"additionalProperties\": false,\r\n            \"required\": [\r\n                \"chargingProfileId\",\r\n                \"stackLevel\",\r\n                \"chargingProfilePurpose\",\r\n                \"chargingProfileKind\",\r\n                \"chargingSchedule\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"idTag\"\r\n    ]\r\n}" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTARTTRANSACTIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTARTTRANSACTIONREQUEST_JSON: REMOTESTARTTRANSACTIONREQUEST_JSON =
            REMOTESTARTTRANSACTIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTARTTRANSACTIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(REMOTESTARTTRANSACTIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStartTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTARTTRANSACTIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTARTTRANSACTIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTARTTRANSACTIONREQUEST_VALIDATOR: REMOTESTARTTRANSACTIONREQUEST_VALIDATOR =
            REMOTESTARTTRANSACTIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTARTTRANSACTIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&REMOTESTARTTRANSACTIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStartTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTARTTRANSACTIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for RemoteStartTransactionRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = REMOTESTARTTRANSACTIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_start_transaction.rs:60",
                                    "ocpp::server_init::remote_start_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/remote_start_transaction.rs"),
                                    Some(60u32),
                                    Some("ocpp::server_init::remote_start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_start_transaction.rs:60",
                                    "ocpp::server_init::remote_start_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/remote_start_transaction.rs"),
                                    Some(60u32),
                                    Some("ocpp::server_init::remote_start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definitions of the RemoteStartTransaction.req PDU sent to Charge Point by Central System.
        pub struct RemoteStartTransactionRequest {
            /// Optional. Number of the connector on which to start the transaction. connectorId SHALL be > 0
            #[serde(skip_serializing_if = "Option::is_none")]
            pub connector_id: Option<u32>,
            /// Required. The identifier that Charge Point must use to start a transaction.
            pub id_tag: String,
            /// Optional. Charging Profile to be used by the Charge Point for the requested transaction. ChargingProfilePurpose MUST be set to TxProfile
            #[serde(skip_serializing_if = "Option::is_none")]
            pub charging_profile: Option<ChargingProfile>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RemoteStartTransactionRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "RemoteStartTransactionRequest",
                        false as usize
                            + if Option::is_none(&self.connector_id) {
                                0
                            } else {
                                1
                            }
                            + 1
                            + if Option::is_none(&self.charging_profile) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.connector_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "connectorId",
                            &self.connector_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "connectorId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "idTag",
                        &self.id_tag,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.charging_profile) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chargingProfile",
                            &self.charging_profile,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "chargingProfile",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RemoteStartTransactionRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "idTag" => _serde::__private::Ok(__Field::__field1),
                                "chargingProfile" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"idTag" => _serde::__private::Ok(__Field::__field1),
                                b"chargingProfile" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RemoteStartTransactionRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RemoteStartTransactionRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RemoteStartTransactionRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RemoteStartTransactionRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct RemoteStartTransactionRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<ChargingProfile>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct RemoteStartTransactionRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RemoteStartTransactionRequest {
                                connector_id: __field0,
                                id_tag: __field1,
                                charging_profile: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<ChargingProfile>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTag",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chargingProfile",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<ChargingProfile>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTag") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("chargingProfile") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(RemoteStartTransactionRequest {
                                connector_id: __field0,
                                id_tag: __field1,
                                charging_profile: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["connectorId", "idTag", "chargingProfile"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RemoteStartTransactionRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RemoteStartTransactionRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RemoteStartTransactionRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "RemoteStartTransactionRequest",
                    "connector_id",
                    &&self.connector_id,
                    "id_tag",
                    &&self.id_tag,
                    "charging_profile",
                    &&self.charging_profile,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RemoteStartTransactionRequest {
            #[inline]
            fn clone(&self) -> RemoteStartTransactionRequest {
                RemoteStartTransactionRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    id_tag: ::core::clone::Clone::clone(&self.id_tag),
                    charging_profile: ::core::clone::Clone::clone(&self.charging_profile),
                }
            }
        }
        const REMOTESTARTTRANSACTIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"RemoteStartTransactionResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTARTTRANSACTIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTARTTRANSACTIONRESPONSE_JSON: REMOTESTARTTRANSACTIONRESPONSE_JSON =
            REMOTESTARTTRANSACTIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTARTTRANSACTIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(REMOTESTARTTRANSACTIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStartTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTARTTRANSACTIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR: REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR =
            REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&REMOTESTARTTRANSACTIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStartTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for RemoteStartTransactionResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = REMOTESTARTTRANSACTIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_start_transaction.rs:75",
                                    "ocpp::server_init::remote_start_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/remote_start_transaction.rs"),
                                    Some(75u32),
                                    Some("ocpp::server_init::remote_start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_start_transaction.rs:75",
                                    "ocpp::server_init::remote_start_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/remote_start_transaction.rs"),
                                    Some(75u32),
                                    Some("ocpp::server_init::remote_start_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definitions of the RemoteStartTransaction.conf PDU sent from Charge Point to Central System.
        pub struct RemoteStartTransactionResponse {
            /// Required. Status indicating whether Charge Point accepts the request to start a transaction.
            pub status: SimpleStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RemoteStartTransactionResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "RemoteStartTransactionResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RemoteStartTransactionResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RemoteStartTransactionResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RemoteStartTransactionResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RemoteStartTransactionResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                SimpleStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RemoteStartTransactionResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RemoteStartTransactionResponse {
                                status: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<SimpleStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<SimpleStatus>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(RemoteStartTransactionResponse {
                                status: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RemoteStartTransactionResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RemoteStartTransactionResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RemoteStartTransactionResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RemoteStartTransactionResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RemoteStartTransactionResponse {
            #[inline]
            fn clone(&self) -> RemoteStartTransactionResponse {
                RemoteStartTransactionResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
    }
    pub mod remote_stop_transaction {
        //! Server request to stop a transaction
        //!
        //! # Behaviour
        //! Central System can request a Charge Point to stop a transaction by sending a RemoteStopTransaction.req to Charge Point with the
        //! identifier of the transaction.
        //!
        //! This remote request to stop a transaction is equal to a local action to stop a transaction. Therefore, the transaction SHALL be
        //! stopped, The Charge Point SHALL send a StopTransaction.req and, if applicable, unlock the connector.
        //!
        //! The following two main use cases are the reason for Remote Stop Transaction:
        //! * Enable a CPO operator to help an EV driver that has problems stopping a transaction.
        //! * Enable mobile apps to control charging transactions via the Central System.
        //!
        //! # Response
        //! Charge Point SHALL reply with RemoteStopTransaction.conf and a status indicating whether it has
        //! accepted the request and a transaction with the given transactionId is ongoing and will be stopped.
        //!
        pub use crate::common_types::SimpleStatus;
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        const REMOTESTOPTRANSACTIONREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:RemoteStopTransactionRequest\",\r\n    \"title\": \"RemoteStopTransactionRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"transactionId\": {\r\n            \"type\": \"integer\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"transactionId\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTOPTRANSACTIONREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTOPTRANSACTIONREQUEST_JSON: REMOTESTOPTRANSACTIONREQUEST_JSON =
            REMOTESTOPTRANSACTIONREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTOPTRANSACTIONREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(REMOTESTOPTRANSACTIONREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStopTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTOPTRANSACTIONREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTOPTRANSACTIONREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTOPTRANSACTIONREQUEST_VALIDATOR: REMOTESTOPTRANSACTIONREQUEST_VALIDATOR =
            REMOTESTOPTRANSACTIONREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTOPTRANSACTIONREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&REMOTESTOPTRANSACTIONREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStopTransaction.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTOPTRANSACTIONREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for RemoteStopTransactionRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = REMOTESTOPTRANSACTIONREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_stop_transaction.rs:24",
                                    "ocpp::server_init::remote_stop_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/remote_stop_transaction.rs"),
                                    Some(24u32),
                                    Some("ocpp::server_init::remote_stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_stop_transaction.rs:24",
                                    "ocpp::server_init::remote_stop_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/remote_stop_transaction.rs"),
                                    Some(24u32),
                                    Some("ocpp::server_init::remote_stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definitions of the RemoteStopTransaction.req PDU sent to Charge Point by Central System.
        pub struct RemoteStopTransactionRequest {
            /// Required. The identifier of the transaction which Charge Point is requested to stop
            pub transaction_id: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RemoteStopTransactionRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "RemoteStopTransactionRequest",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "transactionId",
                        &self.transaction_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RemoteStopTransactionRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "transactionId" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"transactionId" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RemoteStopTransactionRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RemoteStopTransactionRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RemoteStopTransactionRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RemoteStopTransactionRequest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RemoteStopTransactionRequest {
                                transaction_id: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transactionId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("transactionId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(RemoteStopTransactionRequest {
                                transaction_id: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["transactionId"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RemoteStopTransactionRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RemoteStopTransactionRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RemoteStopTransactionRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RemoteStopTransactionRequest",
                    "transaction_id",
                    &&self.transaction_id,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RemoteStopTransactionRequest {
            #[inline]
            fn clone(&self) -> RemoteStopTransactionRequest {
                RemoteStopTransactionRequest {
                    transaction_id: ::core::clone::Clone::clone(&self.transaction_id),
                }
            }
        }
        const REMOTESTOPTRANSACTIONRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"RemoteStopTransactionResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTOPTRANSACTIONRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTOPTRANSACTIONRESPONSE_JSON: REMOTESTOPTRANSACTIONRESPONSE_JSON =
            REMOTESTOPTRANSACTIONRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTOPTRANSACTIONRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(REMOTESTOPTRANSACTIONRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStopTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTOPTRANSACTIONRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR: REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR =
            REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&REMOTESTOPTRANSACTIONRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/RemoteStopTransactionResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for RemoteStopTransactionResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = REMOTESTOPTRANSACTIONRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_stop_transaction.rs:34",
                                    "ocpp::server_init::remote_stop_transaction",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/remote_stop_transaction.rs"),
                                    Some(34u32),
                                    Some("ocpp::server_init::remote_stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/remote_stop_transaction.rs:34",
                                    "ocpp::server_init::remote_stop_transaction",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/remote_stop_transaction.rs"),
                                    Some(34u32),
                                    Some("ocpp::server_init::remote_stop_transaction"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definitions of the RemoteStopTransaction.conf PDU sent from Charge Point to Central System.
        pub struct RemoteStopTransactionResponse {
            /// Required. Status indicating whether Charge Point accepts the request to stop a transaction.
            pub status: SimpleStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for RemoteStopTransactionResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "RemoteStopTransactionResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for RemoteStopTransactionResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<RemoteStopTransactionResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = RemoteStopTransactionResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RemoteStopTransactionResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                SimpleStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RemoteStopTransactionResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RemoteStopTransactionResponse {
                                status: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<SimpleStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<SimpleStatus>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(RemoteStopTransactionResponse {
                                status: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RemoteStopTransactionResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RemoteStopTransactionResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RemoteStopTransactionResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RemoteStopTransactionResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RemoteStopTransactionResponse {
            #[inline]
            fn clone(&self) -> RemoteStopTransactionResponse {
                RemoteStopTransactionResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
    }
    pub mod reset {
        //! Server request to reboot/reset ChargePoint
        //!
        //! # Behaviour
        //! The Central System SHALL send a Reset.req PDU for requesting a Charge Point to reset itself. The Central System can request a hard or
        //! a soft reset.
        //!
        //! After receipt of a Reset.req, The Charge Point SHALL send a StopTransaction.req for any ongoing transaction before performing the reset.
        //! If the Charge Point fails to receive a StopTransaction.conf form the Central System, it shall queue the StopTransaction.req.
        //!
        //! At receipt of a soft reset, the Charge Point SHALL stop ongoing transactions gracefully and send StopTransaction.req for every ongoing
        //! transaction. It should then restart the application software (if possible, otherwise restart the processor/controller).
        //!
        //! At receipt of a hard reset the Charge Point SHALL restart (all) the hardware, it is not required to gracefully stop ongoing transaction.
        //! If possible the Charge Point sends a StopTransaction.req for previously ongoing transactions after having restarted and having been accepted
        //! by the Central System via a BootNotification.conf. This is a last resort solution for a not correctly functioning Charge Points, by sending
        //! a "hard" reset, (queued) information might get lost.
        //! *States are persistent* i.e. Connector set to Unavailable shall persist a reboot.
        //!
        //! # Response
        //! Upon receipt of a Reset.req PDU, the Charge Point SHALL respond with a Reset.conf PDU. The response PDU SHALL include
        //! whether the Charge Point will attempt to reset itself.
        pub use crate::common_types::SimpleStatus;
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const RESETREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:ResetRequest\",\r\n    \"title\": \"ResetRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"type\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"Hard\",\r\n                \"Soft\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"type\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct RESETREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static RESETREQUEST_JSON: RESETREQUEST_JSON = RESETREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for RESETREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(RESETREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/Reset.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for RESETREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct RESETREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static RESETREQUEST_VALIDATOR: RESETREQUEST_VALIDATOR = RESETREQUEST_VALIDATOR {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for RESETREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&RESETREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/Reset.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for RESETREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ResetRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = RESETREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/reset.rs:29",
                                    "ocpp::server_init::reset",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/reset.rs"),
                                    Some(29u32),
                                    Some("ocpp::server_init::reset"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/reset.rs:29",
                                    "ocpp::server_init::reset",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/reset.rs"),
                                    Some(29u32),
                                    Some("ocpp::server_init::reset"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the Reset.req PDU sent by the Central System to the Charge Point.
        pub struct ResetRequest {
            /// Required. This contains the type of reset that the Charge Point should perform.
            pub r#type: ResetType,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ResetRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ResetRequest",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ResetRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "type" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"type" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ResetRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ResetRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ResetRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ResetType,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ResetRequest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ResetRequest { r#type: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ResetType> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<ResetType>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("type") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ResetRequest { r#type: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["type"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ResetRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ResetRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ResetRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ResetRequest",
                    "type",
                    &&self.r#type,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ResetRequest {
            #[inline]
            fn clone(&self) -> ResetRequest {
                ResetRequest {
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                }
            }
        }
        /// Type of reset requested by Reset.req.
        pub enum ResetType {
            /// Restart (all) the hardware, the Charge Point is not required to gracefully stop ongoing transaction. If possible the Charge Point sends a StopTransaction.req
            /// for previously ongoing transactions after having restarted and having been accepted by the Central System via a BootNotification.conf. This is a last resort
            /// solution for a not correctly functioning Charge Point, by sending a "hard" reset, (queued) information might get lost.
            Hard,
            /// Stop ongoing transactions gracefully and sending StopTransaction.req for every ongoing transaction. It should then restart the application software (if
            /// possible, otherwise restart the processor/controller).
            Soft,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ResetType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ResetType::Hard => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ResetType",
                            0u32,
                            "Hard",
                        ),
                        ResetType::Soft => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ResetType",
                            1u32,
                            "Soft",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ResetType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Hard" => _serde::__private::Ok(__Field::__field0),
                                "Soft" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Hard" => _serde::__private::Ok(__Field::__field0),
                                b"Soft" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ResetType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ResetType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum ResetType")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ResetType::Hard)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ResetType::Soft)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Hard", "Soft"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ResetType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ResetType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ResetType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ResetType::Hard,) => ::core::fmt::Formatter::write_str(f, "Hard"),
                    (&ResetType::Soft,) => ::core::fmt::Formatter::write_str(f, "Soft"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ResetType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ResetType {
            #[inline]
            fn eq(&self, other: &ResetType) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ResetType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ResetType {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ResetType {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ResetType::Hard => f.pad("Hard"),
                    ResetType::Soft => f.pad("Soft"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ResetType {
            #[inline]
            fn clone(&self) -> ResetType {
                match (&*self,) {
                    (&ResetType::Hard,) => ResetType::Hard,
                    (&ResetType::Soft,) => ResetType::Soft,
                }
            }
        }
        const RESETRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"ResetResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct RESETRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static RESETRESPONSE_JSON: RESETRESPONSE_JSON = RESETRESPONSE_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for RESETRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(RESETRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ResetResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for RESETRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct RESETRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static RESETRESPONSE_VALIDATOR: RESETRESPONSE_VALIDATOR = RESETRESPONSE_VALIDATOR {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for RESETRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&RESETRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/ResetResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for RESETRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for ResetResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = RESETRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/reset.rs:51",
                                    "ocpp::server_init::reset",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/reset.rs"),
                                    Some(51u32),
                                    Some("ocpp::server_init::reset"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/reset.rs:51",
                                    "ocpp::server_init::reset",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/reset.rs"),
                                    Some(51u32),
                                    Some("ocpp::server_init::reset"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the Reset.conf PDU sent by the Charge Point to the Central System in response to a Reset.req PDU.
        pub struct ResetResponse {
            /// Required. This indicates whether the Charge Point is able to perform the reset.
            pub status: SimpleStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ResetResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ResetResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ResetResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ResetResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ResetResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ResetResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                SimpleStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ResetResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ResetResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<SimpleStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<SimpleStatus>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ResetResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ResetResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ResetResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ResetResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ResetResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ResetResponse {
            #[inline]
            fn clone(&self) -> ResetResponse {
                ResetResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
    }
    pub mod send_local_list {
        //! Server request for a ChargePoint to send it's local auth list
        //!
        //! # Behaviour
        //! Central System can send a Local Authorization List that a Charge Point can use for authorization of idTags. The list MAY be
        //! either a full list to replace the current list in the Charge Point or it MAY be a differential list with updates to be applied
        //! to the current list in the Charge Point.
        //!
        //! The Central System SHALL send a SendLocalList.req PDU to send the list to a Charge Point. The SendLocalList.req PDU SHALL contain
        //! the type of update (full or differential) and the version number that the Charge Point MUST associate with the local authorization
        //! list after it has been updated.
        //!
        //! # Response
        //! Upon receipt of a SendLocalList.req PDU, the Charge Point SHALL respond with a SendLocalList.conf PDU. The response PDU SHALL
        //! indicate whether the Charge Point has accepted the update of the local authorization list. If the status is Failed or VersionMismatch
        //! and the updateType was Differential, then Central System SHOULD retry sending the full local authorization list with updateType Full.
        use crate::common_types::IdTagInfo;
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        const SENDLOCALLISTREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:SendLocalListRequest\",\r\n    \"title\": \"SendLocalListRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"listVersion\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"localAuthorizationList\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": \"object\",\r\n                \"properties\": {\r\n                    \"idTag\": {\r\n                        \"type\": \"string\",\r\n                        \"maxLength\": 20\r\n                    },\r\n                    \"idTagInfo\": {\r\n                        \"type\": \"object\",\r\n                        \"properties\": {\r\n                            \"expiryDate\": {\r\n                                \"type\": \"string\",\r\n                                \"format\": \"date-time\"\r\n                            },\r\n                            \"parentIdTag\": {\r\n                                \"type\": \"string\",\r\n                                \"maxLength\": 20\r\n                            },\r\n                            \"status\": {\r\n                                \"type\": \"string\",\r\n                                \"additionalProperties\": false,\r\n                                \"enum\": [\r\n                                    \"Accepted\",\r\n                                    \"Blocked\",\r\n                                    \"Expired\",\r\n                                    \"Invalid\",\r\n                                    \"ConcurrentTx\"\r\n                                ]\r\n                            }\r\n                        },\r\n                        \"additionalProperties\": false,\r\n                        \"required\": [\r\n                            \"status\"\r\n                        ]\r\n                    }\r\n                },\r\n                \"additionalProperties\": false,\r\n                \"required\": [\r\n                    \"idTag\"\r\n                ]\r\n            }\r\n        },\r\n        \"updateType\": {\r\n            \"type\": \"string\",\r\n            \"additionalProperties\": false,\r\n            \"enum\": [\r\n                \"Differential\",\r\n                \"Full\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"listVersion\",\r\n        \"updateType\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SENDLOCALLISTREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static SENDLOCALLISTREQUEST_JSON: SENDLOCALLISTREQUEST_JSON = SENDLOCALLISTREQUEST_JSON {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for SENDLOCALLISTREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(SENDLOCALLISTREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SendLocalList.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SENDLOCALLISTREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SENDLOCALLISTREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static SENDLOCALLISTREQUEST_VALIDATOR: SENDLOCALLISTREQUEST_VALIDATOR =
            SENDLOCALLISTREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SENDLOCALLISTREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&SENDLOCALLISTREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SendLocalList.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SENDLOCALLISTREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for SendLocalListRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = SENDLOCALLISTREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/send_local_list.rs:36",
                                    "ocpp::server_init::send_local_list",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/send_local_list.rs"),
                                    Some(36u32),
                                    Some("ocpp::server_init::send_local_list"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/send_local_list.rs:36",
                                    "ocpp::server_init::send_local_list",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/send_local_list.rs"),
                                    Some(36u32),
                                    Some("ocpp::server_init::send_local_list"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the SendLocalList.req PDU sent by the Central System to the Charge Point. If no (empty)
        /// localAuthorizationList is given and the updateType is Full, all identifications are removed from the list. Requesting a Differential
        /// update without (empty) localAuthorizationList will have no effect on the list. All idTags in the localAuthorizationList MUST be
        /// unique, no duplicate values are allowed.
        pub struct SendLocalListRequest {
            /// Required. In case of a full update this is the version number of the full list. In case of a differential update
            /// it is the version number of the list after the update has been applied.
            pub list_version: u32,
            /// Optional. In case of a full update this contains the list of values that form the new local authorization list.
            /// In case of a differential update it contains the changes to be applied to the local authorization list in the
            /// Charge Point. Maximum number of AuthorizationData elements is available in the configuration key: SendLocalListMaxLength
            #[serde(skip_serializing_if = "Option::is_none")]
            pub local_authorization_list: Option<Vec<LocalAuthorizationList>>,
            /// Required. This contains the type of update (full or differential) of this request.
            pub update_type: UpdateType,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SendLocalListRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SendLocalListRequest",
                        false as usize
                            + 1
                            + if Option::is_none(&self.local_authorization_list) {
                                0
                            } else {
                                1
                            }
                            + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "listVersion",
                        &self.list_version,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.local_authorization_list) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "localAuthorizationList",
                            &self.local_authorization_list,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "localAuthorizationList",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "updateType",
                        &self.update_type,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SendLocalListRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "listVersion" => _serde::__private::Ok(__Field::__field0),
                                "localAuthorizationList" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "updateType" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"listVersion" => _serde::__private::Ok(__Field::__field0),
                                b"localAuthorizationList" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"updateType" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SendLocalListRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SendLocalListRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SendLocalListRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SendLocalListRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<Vec<LocalAuthorizationList>>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SendLocalListRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                UpdateType,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct SendLocalListRequest with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SendLocalListRequest {
                                list_version: __field0,
                                local_authorization_list: __field1,
                                update_type: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<Vec<LocalAuthorizationList>>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<UpdateType> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "listVersion",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "localAuthorizationList",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Vec<LocalAuthorizationList>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "updateType",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<UpdateType>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("listVersion") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field(
                                        "localAuthorizationList",
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("updateType") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(SendLocalListRequest {
                                list_version: __field0,
                                local_authorization_list: __field1,
                                update_type: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["listVersion", "localAuthorizationList", "updateType"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SendLocalListRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SendLocalListRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SendLocalListRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "SendLocalListRequest",
                    "list_version",
                    &&self.list_version,
                    "local_authorization_list",
                    &&self.local_authorization_list,
                    "update_type",
                    &&self.update_type,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SendLocalListRequest {
            #[inline]
            fn clone(&self) -> SendLocalListRequest {
                SendLocalListRequest {
                    list_version: ::core::clone::Clone::clone(&self.list_version),
                    local_authorization_list: ::core::clone::Clone::clone(
                        &self.local_authorization_list,
                    ),
                    update_type: ::core::clone::Clone::clone(&self.update_type),
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Elements that constitute an entry of a Local Authorization List update.
        pub struct LocalAuthorizationList {
            /// Required. The identifier to which this authorization applies.
            pub id_tag: String,
            /// Optional. (Required when UpdateType is Full) This contains information about authorization status, expiry and parent id.
            /// For a Differential update the following applies: If this element is present, then this entry SHALL be added or updated in
            /// the Local Authorization List. If this element is absent, than the entry for this idtag in the Local Authorization List SHALL be deleted.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub id_tag_info: Option<IdTagInfo>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for LocalAuthorizationList {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "LocalAuthorizationList",
                        false as usize
                            + 1
                            + if Option::is_none(&self.id_tag_info) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "idTag",
                        &self.id_tag,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.id_tag_info) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "idTagInfo",
                            &self.id_tag_info,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "idTagInfo",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for LocalAuthorizationList {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "idTag" => _serde::__private::Ok(__Field::__field0),
                                "idTagInfo" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"idTag" => _serde::__private::Ok(__Field::__field0),
                                b"idTagInfo" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<LocalAuthorizationList>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = LocalAuthorizationList;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct LocalAuthorizationList",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct LocalAuthorizationList with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<IdTagInfo>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct LocalAuthorizationList with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(LocalAuthorizationList {
                                id_tag: __field0,
                                id_tag_info: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<IdTagInfo>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTag",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "idTagInfo",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<IdTagInfo>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTag") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("idTagInfo") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(LocalAuthorizationList {
                                id_tag: __field0,
                                id_tag_info: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["idTag", "idTagInfo"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "LocalAuthorizationList",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<LocalAuthorizationList>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for LocalAuthorizationList {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "LocalAuthorizationList",
                    "id_tag",
                    &&self.id_tag,
                    "id_tag_info",
                    &&self.id_tag_info,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for LocalAuthorizationList {
            #[inline]
            fn clone(&self) -> LocalAuthorizationList {
                LocalAuthorizationList {
                    id_tag: ::core::clone::Clone::clone(&self.id_tag),
                    id_tag_info: ::core::clone::Clone::clone(&self.id_tag_info),
                }
            }
        }
        /// Type of update for a SendLocalList.req.
        pub enum UpdateType {
            /// Indicates that the current Local Authorization List must be updated with the values in this message.
            Differential,
            /// Indicates that the current Local Authorization List must be replaced by the values in this message.
            Full,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UpdateType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        UpdateType::Differential => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UpdateType",
                            0u32,
                            "Differential",
                        ),
                        UpdateType::Full => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UpdateType",
                            1u32,
                            "Full",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UpdateType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Differential" => _serde::__private::Ok(__Field::__field0),
                                "Full" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Differential" => _serde::__private::Ok(__Field::__field0),
                                b"Full" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UpdateType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UpdateType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum UpdateType")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UpdateType::Differential)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UpdateType::Full)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Differential", "Full"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "UpdateType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UpdateType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdateType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&UpdateType::Differential,) => {
                        ::core::fmt::Formatter::write_str(f, "Differential")
                    }
                    (&UpdateType::Full,) => ::core::fmt::Formatter::write_str(f, "Full"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for UpdateType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UpdateType {
            #[inline]
            fn eq(&self, other: &UpdateType) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for UpdateType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for UpdateType {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for UpdateType {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    UpdateType::Differential => f.pad("Differential"),
                    UpdateType::Full => f.pad("Full"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdateType {
            #[inline]
            fn clone(&self) -> UpdateType {
                match (&*self,) {
                    (&UpdateType::Differential,) => UpdateType::Differential,
                    (&UpdateType::Full,) => UpdateType::Full,
                }
            }
        }
        const SENDLOCALLISTRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"SendLocalListResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Failed\",\n                \"NotSupported\",\n                \"VersionMismatch\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SENDLOCALLISTRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static SENDLOCALLISTRESPONSE_JSON: SENDLOCALLISTRESPONSE_JSON =
            SENDLOCALLISTRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SENDLOCALLISTRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(SENDLOCALLISTRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SendLocalListResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SENDLOCALLISTRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SENDLOCALLISTRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static SENDLOCALLISTRESPONSE_VALIDATOR: SENDLOCALLISTRESPONSE_VALIDATOR =
            SENDLOCALLISTRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SENDLOCALLISTRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&SENDLOCALLISTRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SendLocalListResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SENDLOCALLISTRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for SendLocalListResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = SENDLOCALLISTRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/send_local_list.rs:79",
                                    "ocpp::server_init::send_local_list",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/send_local_list.rs"),
                                    Some(79u32),
                                    Some("ocpp::server_init::send_local_list"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/send_local_list.rs:79",
                                    "ocpp::server_init::send_local_list",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/send_local_list.rs"),
                                    Some(79u32),
                                    Some("ocpp::server_init::send_local_list"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the SendLocalList.conf PDU sent by the Charge Point to the Central System in response to a SendLocalList.req PDU.
        pub struct SendLocalListResponse {
            /// Required. This indicates whether the Charge Point has successfully received and applied the update of the local authorization list.
            pub status: UpdateStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SendLocalListResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SendLocalListResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SendLocalListResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SendLocalListResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SendLocalListResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SendLocalListResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                UpdateStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SendLocalListResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SendLocalListResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<UpdateStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<UpdateStatus>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(SendLocalListResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SendLocalListResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SendLocalListResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SendLocalListResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SendLocalListResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SendLocalListResponse {
            #[inline]
            fn clone(&self) -> SendLocalListResponse {
                SendLocalListResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Type of update for a SendLocalList.req.
        pub enum UpdateStatus {
            /// Local Authorization List successfully updated.
            Accepted,
            /// Failed to update the Local Authorization List.
            Failed,
            /// Update of Local Authorization List is not supported by Charge Point.
            NotSupported,
            /// Version number in the request for a differential update is less or equal then version number of current list.
            VersionMismatch,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UpdateStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        UpdateStatus::Accepted => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UpdateStatus",
                            0u32,
                            "Accepted",
                        ),
                        UpdateStatus::Failed => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UpdateStatus",
                            1u32,
                            "Failed",
                        ),
                        UpdateStatus::NotSupported => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UpdateStatus",
                            2u32,
                            "NotSupported",
                        ),
                        UpdateStatus::VersionMismatch => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "UpdateStatus",
                                3u32,
                                "VersionMismatch",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UpdateStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Failed" => _serde::__private::Ok(__Field::__field1),
                                "NotSupported" => _serde::__private::Ok(__Field::__field2),
                                "VersionMismatch" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Failed" => _serde::__private::Ok(__Field::__field1),
                                b"NotSupported" => _serde::__private::Ok(__Field::__field2),
                                b"VersionMismatch" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UpdateStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UpdateStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum UpdateStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UpdateStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UpdateStatus::Failed)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UpdateStatus::NotSupported)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UpdateStatus::VersionMismatch)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Accepted", "Failed", "NotSupported", "VersionMismatch"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "UpdateStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UpdateStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdateStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&UpdateStatus::Accepted,) => ::core::fmt::Formatter::write_str(f, "Accepted"),
                    (&UpdateStatus::Failed,) => ::core::fmt::Formatter::write_str(f, "Failed"),
                    (&UpdateStatus::NotSupported,) => {
                        ::core::fmt::Formatter::write_str(f, "NotSupported")
                    }
                    (&UpdateStatus::VersionMismatch,) => {
                        ::core::fmt::Formatter::write_str(f, "VersionMismatch")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for UpdateStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UpdateStatus {
            #[inline]
            fn eq(&self, other: &UpdateStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for UpdateStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for UpdateStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for UpdateStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    UpdateStatus::Accepted => f.pad("Accepted"),
                    UpdateStatus::Failed => f.pad("Failed"),
                    UpdateStatus::NotSupported => f.pad("NotSupported"),
                    UpdateStatus::VersionMismatch => f.pad("VersionMismatch"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdateStatus {
            #[inline]
            fn clone(&self) -> UpdateStatus {
                match (&*self,) {
                    (&UpdateStatus::Accepted,) => UpdateStatus::Accepted,
                    (&UpdateStatus::Failed,) => UpdateStatus::Failed,
                    (&UpdateStatus::NotSupported,) => UpdateStatus::NotSupported,
                    (&UpdateStatus::VersionMismatch,) => UpdateStatus::VersionMismatch,
                }
            }
        }
    }
    pub mod set_charging_profile {
        //! Server request to set a charging schedule for a ChargePoint
        //!
        //! A Central System can send a SetChargingProfile.req to a Charge Point, to set a charging profile, in the following situations:
        //! 1. At the start of a transaction to set the charging profile for the transaction;
        //! 2. In a RemoteStartTransaction.req sent to a Charge Point
        //! 3. During a transaction to change the active profile for the transaction;
        //! 4. Outside the context of a transaction as a separate message to set a charging profile to a local controller, Charge Point, or a default charging profile to a connector.
        //!
        //! # 1. Setting a charging profile at start of transaction
        //! If the Central System receives a StartTransaction.req the Central System SHALL respond with a StartTransaction.conf. If there is a need for a charging profile, The Central System MAY choose to send a SetChargingProfile.req to the Charge Point.
        //!
        //! It is RECOMMENDED to check the timestamp in the StartTransaction.req PDU prior to sending a charging profile to check if the transaction is likely to be still ongoing. The StartTransaction.req might have been cached during an offline period.
        //!
        //! # 2. Setting a charge profile in a RemoteStartTransaction request
        //! The Central System MAY include a charging profile in a RemoteStartTransaction request.
        //! If the Central System includes a ChargingProfile, the ChargingProfilePurpose MUST be set to TxProfile and the transactionId SHALL NOT be set.
        //!
        //! The Charge Point SHALL apply the given profile to the newly started transaction. This transaction will get a transactionId assigned by Central System via a StartTransaction.conf.
        //!
        //! When the Charge Point receives a SetChargingProfile.req, with the transactionId for this transaction, with the same StackLevel as the profile given in the RemoteStartTransaction.req, the Charge Point SHALL replace the existing charging profile, otherwise it SHALL install/stack the profile next to the already existing profile(s).
        //!
        //! # 3. Setting a charging profile during a transaction.
        //! The Central System MAY send a charging profile to a Charge Point to update the charging profile for that transaction. The Central System SHALL use the SetChargingProfile.req PDU for that purpose. If a charging profile with the same chargingProfileId, or the same combination of stackLevel / ChargingProfilePurpose, exists on the Charge Point, the new charging profile SHALL replace the existing charging profile, otherwise it SHALL be added. The Charge Point SHALL then re-evaluate its collection of charge profiles to determine which charging profile will become active. In order to ensure that the updated charging profile applies only to the current transaction, the chargingProfilePurpose of the ChargingProfile MUST be set to TxProfile. (See section: Charging Profile Purposes)
        //!
        //! # 4. Setting a charging profile outside of a transaction
        //! The Central System MAY send charging profiles to a Charge Point that are to be used as default charging profiles.
        //! The Central System SHALL use the SetChargingProfile.req PDU for that purpose. Such charging profiles MAY be sent at any time. If a charging profile with the same chargingProfileId, or the same combination of stackLevel ChargingProfilePurpose, exists on the Charge Point, the new charging profile SHALL replace the existing charging profile, otherwise it SHALL be added. The Charge Point SHALL then re-evaluate its collection of charge profiles to determine which charging profile will become active.
        //!
        //! # Note
        //!
        //! * To prevent mismatch between transactions and a TxProfile, The Central System SHALL include the transactionId in a SetChargingProfile.req if the profile applies to a specific transaction.
        //!
        //! * It is not possible to set a ChargingProfile with purpose set to TxProfile without presence of an active transaction, or in advance of a transaction.
        //!
        //! * When a ChargingProfile is refreshed during execution, it is advised to put the startSchedule of the new ChargingProfile in the past, so there is no period of default charging behaviour inbetween the ChargingProfiles. The Charge Point SHALL continue to execute the existing ChargingProfile until the new ChargingProfile is installed.
        //!
        //! * If the chargingSchedulePeriod is longer than duration, the remainder periods SHALL not be executed. If duration is longer than the chargingSchedulePeriod, the Charge Point SHALL keep the value of the last chargingSchedulePeriod until duration has ended.
        //!
        //! * When recurrencyKind is used in combination with a chargingSchedulePeriod and/or duration that is longer then the recurrence period duration, the remainder periods SHALL not be executed.
        //!
        //! * The StartSchedule of the first chargingSchedulePeriod in a chargingSchedule SHALL always be 0
        //!
        //! * When recurrencyKind is used in combination with a chargingSchedule duration shorter than the recurrencyKind period, the Charge Point SHALL fall back to default behaviour after the chargingSchedule duration ends.
        //! This fall back means that the Charge Point SHALL use a ChargingProfile with a lower stackLevel if available.
        //! If no other ChargingProfile is available, the Charge Point SHALL allow charging as if no ChargingProfile is installed.
        //! If the chargingSchedulePeriod and/or duration is longer then the recurrence period duration, the remainder periods SHALL not be executed.
        use crate::validation_macros::{self, json_validate};
        pub use crate::ChargingProfile;
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const SETCHARGINGPROFILEREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:SetChargingProfileRequest\",\r\n    \"title\": \"SetChargingProfileRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"csChargingProfiles\": {\r\n            \"type\": \"object\",\r\n            \"properties\": {\r\n                \"chargingProfileId\": {\r\n                    \"type\": \"integer\"\r\n                },\r\n                \"transactionId\": {\r\n                    \"type\": \"integer\"\r\n                },\r\n                \"stackLevel\": {\r\n                    \"type\": \"integer\"\r\n                },\r\n                \"chargingProfilePurpose\": {\r\n                    \"type\": \"string\",\r\n                    \"additionalProperties\": false,\r\n                    \"enum\": [\r\n                        \"ChargePointMaxProfile\",\r\n                        \"TxDefaultProfile\",\r\n                        \"TxProfile\"\r\n                    ]\r\n                },\r\n                \"chargingProfileKind\": {\r\n                    \"type\": \"string\",\r\n                    \"additionalProperties\": false,\r\n                    \"enum\": [\r\n                        \"Absolute\",\r\n                        \"Recurring\",\r\n                        \"Relative\"\r\n                    ]\r\n                },\r\n                \"recurrencyKind\": {\r\n                    \"type\": \"string\",\r\n                    \"additionalProperties\": false,\r\n                    \"enum\": [\r\n                        \"Daily\",\r\n                        \"Weekly\"\r\n                    ]\r\n                },\r\n                \"validFrom\": {\r\n                    \"type\": \"string\",\r\n                    \"format\": \"date-time\"\r\n                },\r\n                \"validTo\": {\r\n                    \"type\": \"string\",\r\n                    \"format\": \"date-time\"\r\n                },\r\n                \"chargingSchedule\": {\r\n                    \"type\": \"object\",\r\n                    \"properties\": {\r\n                        \"duration\": {\r\n                            \"type\": \"integer\"\r\n                        },\r\n                        \"startSchedule\": {\r\n                            \"type\": \"string\",\r\n                            \"format\": \"date-time\"\r\n                        },\r\n                        \"chargingRateUnit\": {\r\n                            \"type\": \"string\",\r\n                            \"additionalProperties\": false,\r\n                            \"enum\": [\r\n                                \"A\",\r\n                                \"W\"\r\n                            ]\r\n                        },\r\n                        \"chargingSchedulePeriod\": {\r\n                            \"type\": \"array\",\r\n                            \"items\": {\r\n                                \"type\": \"object\",\r\n                                \"properties\": {\r\n                                    \"startPeriod\": {\r\n                                        \"type\": \"integer\"\r\n                                    },\r\n                                \"limit\": {\r\n                                    \"type\": \"number\",\r\n                                    \"multipleOf\" : 0.1\r\n                                },\r\n                                \"numberPhases\": {\r\n                                        \"type\": \"integer\"\r\n                                    }\r\n                                },\r\n                                \"additionalProperties\": false,\r\n                                \"required\": [\r\n                                    \"startPeriod\",\r\n                                    \"limit\"\r\n                                ]\r\n                            }\r\n                        },\r\n                        \"minChargingRate\": {\r\n                            \"type\": \"number\",\r\n                            \"multipleOf\" : 0.1\r\n                        }\r\n                    },\r\n                    \"additionalProperties\": false,\r\n                    \"required\": [\r\n                        \"chargingRateUnit\",\r\n                        \"chargingSchedulePeriod\"\r\n                    ]\r\n                }\r\n            },\r\n            \"additionalProperties\": false,\r\n            \"required\": [\r\n                \"chargingProfileId\",\r\n                \"stackLevel\",\r\n                \"chargingProfilePurpose\",\r\n                \"chargingProfileKind\",\r\n                \"chargingSchedule\"\r\n            ]\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\",\r\n        \"csChargingProfiles\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SETCHARGINGPROFILEREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static SETCHARGINGPROFILEREQUEST_JSON: SETCHARGINGPROFILEREQUEST_JSON =
            SETCHARGINGPROFILEREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SETCHARGINGPROFILEREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(SETCHARGINGPROFILEREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SetChargingProfile.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SETCHARGINGPROFILEREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SETCHARGINGPROFILEREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static SETCHARGINGPROFILEREQUEST_VALIDATOR: SETCHARGINGPROFILEREQUEST_VALIDATOR =
            SETCHARGINGPROFILEREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SETCHARGINGPROFILEREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&SETCHARGINGPROFILEREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SetChargingProfile.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SETCHARGINGPROFILEREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for SetChargingProfileRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = SETCHARGINGPROFILEREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/set_charging_profile.rs:76",
                                    "ocpp::server_init::set_charging_profile",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/set_charging_profile.rs"),
                                    Some(76u32),
                                    Some("ocpp::server_init::set_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/set_charging_profile.rs:76",
                                    "ocpp::server_init::set_charging_profile",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/set_charging_profile.rs"),
                                    Some(76u32),
                                    Some("ocpp::server_init::set_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the SetChargingProfile.req PDU sent by the Central System to the Charge Point.
        /// The Central System uses this message to send charging profiles to a Charge Point.
        pub struct SetChargingProfileRequest {
            /// Required. The connector to which the charging profile applies. If connectorId = 0, the message contains an overall limit for the Charge Point.
            pub connector_id: u32,
            /// Required. The charging profile to be set at the Charge Point.
            pub cs_charging_profiles: ChargingProfile,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SetChargingProfileRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SetChargingProfileRequest",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "csChargingProfiles",
                        &self.cs_charging_profiles,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SetChargingProfileRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                "csChargingProfiles" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                b"csChargingProfiles" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SetChargingProfileRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SetChargingProfileRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SetChargingProfileRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SetChargingProfileRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                ChargingProfile,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SetChargingProfileRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SetChargingProfileRequest {
                                connector_id: __field0,
                                cs_charging_profiles: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<ChargingProfile> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "csChargingProfiles",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<ChargingProfile>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("csChargingProfiles")
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(SetChargingProfileRequest {
                                connector_id: __field0,
                                cs_charging_profiles: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["connectorId", "csChargingProfiles"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SetChargingProfileRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SetChargingProfileRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SetChargingProfileRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SetChargingProfileRequest",
                    "connector_id",
                    &&self.connector_id,
                    "cs_charging_profiles",
                    &&self.cs_charging_profiles,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SetChargingProfileRequest {
            #[inline]
            fn clone(&self) -> SetChargingProfileRequest {
                SetChargingProfileRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                    cs_charging_profiles: ::core::clone::Clone::clone(&self.cs_charging_profiles),
                }
            }
        }
        const SETCHARGINGPROFILERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"SetChargingProfileResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\",\n                \"NotSupported\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SETCHARGINGPROFILERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static SETCHARGINGPROFILERESPONSE_JSON: SETCHARGINGPROFILERESPONSE_JSON =
            SETCHARGINGPROFILERESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SETCHARGINGPROFILERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(SETCHARGINGPROFILERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SetChargingProfileResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SETCHARGINGPROFILERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct SETCHARGINGPROFILERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static SETCHARGINGPROFILERESPONSE_VALIDATOR: SETCHARGINGPROFILERESPONSE_VALIDATOR =
            SETCHARGINGPROFILERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for SETCHARGINGPROFILERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&SETCHARGINGPROFILERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/SetChargingProfileResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for SETCHARGINGPROFILERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for SetChargingProfileResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = SETCHARGINGPROFILERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/set_charging_profile.rs:89",
                                    "ocpp::server_init::set_charging_profile",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/set_charging_profile.rs"),
                                    Some(89u32),
                                    Some("ocpp::server_init::set_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/set_charging_profile.rs:89",
                                    "ocpp::server_init::set_charging_profile",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/set_charging_profile.rs"),
                                    Some(89u32),
                                    Some("ocpp::server_init::set_charging_profile"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the SetChargingProfile.conf PDU sent by the Charge Point to the Central System in response to a SetChargingProfile.req PDU.
        pub struct SetChargingProfileResponse {
            /// Required. Returns whether the Charge Point has been able to process the message successfully. This does not guarantee the
            /// schedule will be followed to the letter. There might be other constraints the Charge Point may need to take into account.
            pub status: ChargingProfileStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SetChargingProfileResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SetChargingProfileResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SetChargingProfileResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SetChargingProfileResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SetChargingProfileResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SetChargingProfileResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                ChargingProfileStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SetChargingProfileResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SetChargingProfileResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ChargingProfileStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                ChargingProfileStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(SetChargingProfileResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SetChargingProfileResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SetChargingProfileResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SetChargingProfileResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SetChargingProfileResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SetChargingProfileResponse {
            #[inline]
            fn clone(&self) -> SetChargingProfileResponse {
                SetChargingProfileResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status returned in response to SetChargingProfile.req.
        pub enum ChargingProfileStatus {
            /// Request has been accepted and will be executed.
            Accepted,
            /// Request has not been accepted and will not be executed.
            Rejected,
            /// Charge Point indicates that the request is not supported.
            NotSupported,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ChargingProfileStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ChargingProfileStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfileStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        ChargingProfileStatus::Rejected => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfileStatus",
                                1u32,
                                "Rejected",
                            )
                        }
                        ChargingProfileStatus::NotSupported => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ChargingProfileStatus",
                                2u32,
                                "NotSupported",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ChargingProfileStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Rejected" => _serde::__private::Ok(__Field::__field1),
                                "NotSupported" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Rejected" => _serde::__private::Ok(__Field::__field1),
                                b"NotSupported" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ChargingProfileStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ChargingProfileStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ChargingProfileStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfileStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfileStatus::Rejected)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ChargingProfileStatus::NotSupported)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Accepted", "Rejected", "NotSupported"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ChargingProfileStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ChargingProfileStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ChargingProfileStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ChargingProfileStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&ChargingProfileStatus::Rejected,) => {
                        ::core::fmt::Formatter::write_str(f, "Rejected")
                    }
                    (&ChargingProfileStatus::NotSupported,) => {
                        ::core::fmt::Formatter::write_str(f, "NotSupported")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ChargingProfileStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ChargingProfileStatus {
            #[inline]
            fn eq(&self, other: &ChargingProfileStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for ChargingProfileStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ChargingProfileStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for ChargingProfileStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    ChargingProfileStatus::Accepted => f.pad("Accepted"),
                    ChargingProfileStatus::Rejected => f.pad("Rejected"),
                    ChargingProfileStatus::NotSupported => f.pad("NotSupported"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ChargingProfileStatus {
            #[inline]
            fn clone(&self) -> ChargingProfileStatus {
                match (&*self,) {
                    (&ChargingProfileStatus::Accepted,) => ChargingProfileStatus::Accepted,
                    (&ChargingProfileStatus::Rejected,) => ChargingProfileStatus::Rejected,
                    (&ChargingProfileStatus::NotSupported,) => ChargingProfileStatus::NotSupported,
                }
            }
        }
    }
    pub mod trigger_message {
        //! Server request to trigger a message response from a charge point
        //!
        //! During normal operation, the Charge Point informs the Central System of its state and any relevant occurrences.If there is
        //! nothing to report the Charge Point will send at least a heartBeat at a predefined interval. Under normal circumstances this
        //! is just fine, but what if the Central System has (whatever) reason to doubt the last known state? What can a Central System
        //! do if a firmware update is in progress and the last status notification it received about it was much longer ago than could
        //! reasonably be expected? The same can be asked for the progress of a diagnostics request. The problem in these situations is
        //! not that the information needed isnt covered by existing messages, the problem is strictly a timing issue. The Charge Point
        //! has the information, but has no way of knowing that the Central System would like an update.
        //!
        //! The TriggerMessage.req makes it possible for the Central System, to request the Charge Point, to send Charge Point-initiated
        //! messages. In the request the Central System indicates which message it wishes to receive. For every such requested message
        //! the Central System MAY optionally indicate to which connector this request applies. The requested message is leading: if the
        //! specified connectorId is not relevant to the message, it should be ignored. In such cases the requested message should still
        //! be sent.
        //!
        //! Inversely, if the connectorId is relevant but absent, this should be interpreted as for all allowed connectorId values.
        //! For example, a request for a statusNotification for connectorId 0 is a request for the status of the Charge Point. A request
        //! for a statusNotification without connectorId is a request for multiple statusNotifications: the notification for the Charge
        //! Point itself and a notification for each of its connectors.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        use strum_macros::Display;
        const TRIGGERMESSAGEREQUEST_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"TriggerMessageRequest\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"requestedMessage\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"BootNotification\",\n                \"DiagnosticsStatusNotification\",\n                \"FirmwareStatusNotification\",\n                \"Heartbeat\",\n                \"MeterValues\",\n                \"StatusNotification\"\n            ]\n        },\n        \"connectorId\": {\n            \"type\": \"integer\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"requestedMessage\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct TRIGGERMESSAGEREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static TRIGGERMESSAGEREQUEST_JSON: TRIGGERMESSAGEREQUEST_JSON =
            TRIGGERMESSAGEREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for TRIGGERMESSAGEREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(TRIGGERMESSAGEREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/TriggerMessage.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for TRIGGERMESSAGEREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct TRIGGERMESSAGEREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static TRIGGERMESSAGEREQUEST_VALIDATOR: TRIGGERMESSAGEREQUEST_VALIDATOR =
            TRIGGERMESSAGEREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for TRIGGERMESSAGEREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&TRIGGERMESSAGEREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/TriggerMessage.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for TRIGGERMESSAGEREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for TriggerMessageRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = TRIGGERMESSAGEREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/trigger_message.rs:28",
                                    "ocpp::server_init::trigger_message",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/trigger_message.rs"),
                                    Some(28u32),
                                    Some("ocpp::server_init::trigger_message"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/trigger_message.rs:28",
                                    "ocpp::server_init::trigger_message",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/trigger_message.rs"),
                                    Some(28u32),
                                    Some("ocpp::server_init::trigger_message"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// This contains the field definition of the TriggerMessage.req PDU sent by the Central System to the Charge Point.
        pub struct TriggerMessageRequest {
            /// Required.
            pub requested_message: MessageTrigger,
            /// Optional. Only filled in when request applies to a specific connector.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub connector_id: Option<u32>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TriggerMessageRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "TriggerMessageRequest",
                        false as usize
                            + 1
                            + if Option::is_none(&self.connector_id) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "requestedMessage",
                        &self.requested_message,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.connector_id) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "connectorId",
                            &self.connector_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "connectorId",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TriggerMessageRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "requestedMessage" => _serde::__private::Ok(__Field::__field0),
                                "connectorId" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"requestedMessage" => _serde::__private::Ok(__Field::__field0),
                                b"connectorId" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TriggerMessageRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TriggerMessageRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TriggerMessageRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                MessageTrigger,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TriggerMessageRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TriggerMessageRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TriggerMessageRequest {
                                requested_message: __field0,
                                connector_id: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<MessageTrigger> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "requestedMessage",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<MessageTrigger>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("requestedMessage") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(TriggerMessageRequest {
                                requested_message: __field0,
                                connector_id: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["requestedMessage", "connectorId"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TriggerMessageRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TriggerMessageRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TriggerMessageRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TriggerMessageRequest",
                    "requested_message",
                    &&self.requested_message,
                    "connector_id",
                    &&self.connector_id,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TriggerMessageRequest {
            #[inline]
            fn clone(&self) -> TriggerMessageRequest {
                TriggerMessageRequest {
                    requested_message: ::core::clone::Clone::clone(&self.requested_message),
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                }
            }
        }
        #[allow(missing_docs)]
        /// Type of request to be triggered in a TriggerMessage.req.
        pub enum MessageTrigger {
            BootNotification,
            DiagnosticsStatusNotification,
            FirmwareStatusNotification,
            Heartbeat,
            MeterValues,
            StatusNotification,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MessageTrigger {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        MessageTrigger::BootNotification => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "MessageTrigger",
                                0u32,
                                "BootNotification",
                            )
                        }
                        MessageTrigger::DiagnosticsStatusNotification => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "MessageTrigger",
                                1u32,
                                "DiagnosticsStatusNotification",
                            )
                        }
                        MessageTrigger::FirmwareStatusNotification => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "MessageTrigger",
                                2u32,
                                "FirmwareStatusNotification",
                            )
                        }
                        MessageTrigger::Heartbeat => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "MessageTrigger",
                            3u32,
                            "Heartbeat",
                        ),
                        MessageTrigger::MeterValues => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "MessageTrigger",
                            4u32,
                            "MeterValues",
                        ),
                        MessageTrigger::StatusNotification => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "MessageTrigger",
                                5u32,
                                "StatusNotification",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MessageTrigger {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 6",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "BootNotification" => _serde::__private::Ok(__Field::__field0),
                                "DiagnosticsStatusNotification" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "FirmwareStatusNotification" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "Heartbeat" => _serde::__private::Ok(__Field::__field3),
                                "MeterValues" => _serde::__private::Ok(__Field::__field4),
                                "StatusNotification" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"BootNotification" => _serde::__private::Ok(__Field::__field0),
                                b"DiagnosticsStatusNotification" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"FirmwareStatusNotification" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"Heartbeat" => _serde::__private::Ok(__Field::__field3),
                                b"MeterValues" => _serde::__private::Ok(__Field::__field4),
                                b"StatusNotification" => _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MessageTrigger>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MessageTrigger;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum MessageTrigger",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(MessageTrigger::BootNotification)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        MessageTrigger::DiagnosticsStatusNotification,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(
                                        MessageTrigger::FirmwareStatusNotification,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(MessageTrigger::Heartbeat)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(MessageTrigger::MeterValues)
                                }
                                (__Field::__field5, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(MessageTrigger::StatusNotification)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "BootNotification",
                        "DiagnosticsStatusNotification",
                        "FirmwareStatusNotification",
                        "Heartbeat",
                        "MeterValues",
                        "StatusNotification",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "MessageTrigger",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MessageTrigger>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(missing_docs)]
        impl ::core::fmt::Debug for MessageTrigger {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&MessageTrigger::BootNotification,) => {
                        ::core::fmt::Formatter::write_str(f, "BootNotification")
                    }
                    (&MessageTrigger::DiagnosticsStatusNotification,) => {
                        ::core::fmt::Formatter::write_str(f, "DiagnosticsStatusNotification")
                    }
                    (&MessageTrigger::FirmwareStatusNotification,) => {
                        ::core::fmt::Formatter::write_str(f, "FirmwareStatusNotification")
                    }
                    (&MessageTrigger::Heartbeat,) => {
                        ::core::fmt::Formatter::write_str(f, "Heartbeat")
                    }
                    (&MessageTrigger::MeterValues,) => {
                        ::core::fmt::Formatter::write_str(f, "MeterValues")
                    }
                    (&MessageTrigger::StatusNotification,) => {
                        ::core::fmt::Formatter::write_str(f, "StatusNotification")
                    }
                }
            }
        }
        #[allow(missing_docs)]
        impl ::core::marker::StructuralPartialEq for MessageTrigger {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(missing_docs)]
        impl ::core::cmp::PartialEq for MessageTrigger {
            #[inline]
            fn eq(&self, other: &MessageTrigger) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[allow(missing_docs)]
        impl ::core::marker::StructuralEq for MessageTrigger {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(missing_docs)]
        impl ::core::cmp::Eq for MessageTrigger {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for MessageTrigger {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    MessageTrigger::BootNotification => f.pad("BootNotification"),
                    MessageTrigger::DiagnosticsStatusNotification => {
                        f.pad("DiagnosticsStatusNotification")
                    }
                    MessageTrigger::FirmwareStatusNotification => {
                        f.pad("FirmwareStatusNotification")
                    }
                    MessageTrigger::Heartbeat => f.pad("Heartbeat"),
                    MessageTrigger::MeterValues => f.pad("MeterValues"),
                    MessageTrigger::StatusNotification => f.pad("StatusNotification"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for MessageTrigger {
            #[inline]
            fn clone(&self) -> MessageTrigger {
                match (&*self,) {
                    (&MessageTrigger::BootNotification,) => MessageTrigger::BootNotification,
                    (&MessageTrigger::DiagnosticsStatusNotification,) => {
                        MessageTrigger::DiagnosticsStatusNotification
                    }
                    (&MessageTrigger::FirmwareStatusNotification,) => {
                        MessageTrigger::FirmwareStatusNotification
                    }
                    (&MessageTrigger::Heartbeat,) => MessageTrigger::Heartbeat,
                    (&MessageTrigger::MeterValues,) => MessageTrigger::MeterValues,
                    (&MessageTrigger::StatusNotification,) => MessageTrigger::StatusNotification,
                }
            }
        }
        const TRIGGERMESSAGERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"TriggerMessageResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Accepted\",\n                \"Rejected\",\n                \"NotImplemented\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct TRIGGERMESSAGERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static TRIGGERMESSAGERESPONSE_JSON: TRIGGERMESSAGERESPONSE_JSON =
            TRIGGERMESSAGERESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for TRIGGERMESSAGERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(TRIGGERMESSAGERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/TriggerMessageResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for TRIGGERMESSAGERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct TRIGGERMESSAGERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static TRIGGERMESSAGERESPONSE_VALIDATOR: TRIGGERMESSAGERESPONSE_VALIDATOR =
            TRIGGERMESSAGERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for TRIGGERMESSAGERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&TRIGGERMESSAGERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/TriggerMessageResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for TRIGGERMESSAGERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for TriggerMessageResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = TRIGGERMESSAGERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/trigger_message.rs:53",
                                    "ocpp::server_init::trigger_message",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/trigger_message.rs"),
                                    Some(53u32),
                                    Some("ocpp::server_init::trigger_message"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/trigger_message.rs:53",
                                    "ocpp::server_init::trigger_message",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/trigger_message.rs"),
                                    Some(53u32),
                                    Some("ocpp::server_init::trigger_message"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// This contains the field definition of the TriggerMessage.conf PDU sent by the Charge Point to the Central System in response to a TriggerMessage.req PDU.
        pub struct TriggerMessageResponse {
            /// Required. Indicates whether the Charge Point will send the requested notification or not.
            pub status: TriggerMessageStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TriggerMessageResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "TriggerMessageResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TriggerMessageResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TriggerMessageResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TriggerMessageResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TriggerMessageResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                TriggerMessageStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TriggerMessageResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TriggerMessageResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<TriggerMessageStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                TriggerMessageStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(TriggerMessageResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TriggerMessageResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TriggerMessageResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TriggerMessageResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "TriggerMessageResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TriggerMessageResponse {
            #[inline]
            fn clone(&self) -> TriggerMessageResponse {
                TriggerMessageResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status in TriggerMessage.conf.
        pub enum TriggerMessageStatus {
            /// Requested notification will be sent.
            Accepted,
            /// Requested notification will not be sent.
            Rejected,
            /// Requested notification cannot be sent because it is either not implemented or unknown.
            NotImplemented,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TriggerMessageStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TriggerMessageStatus::Accepted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TriggerMessageStatus",
                                0u32,
                                "Accepted",
                            )
                        }
                        TriggerMessageStatus::Rejected => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TriggerMessageStatus",
                                1u32,
                                "Rejected",
                            )
                        }
                        TriggerMessageStatus::NotImplemented => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TriggerMessageStatus",
                                2u32,
                                "NotImplemented",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TriggerMessageStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Accepted" => _serde::__private::Ok(__Field::__field0),
                                "Rejected" => _serde::__private::Ok(__Field::__field1),
                                "NotImplemented" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                b"Rejected" => _serde::__private::Ok(__Field::__field1),
                                b"NotImplemented" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TriggerMessageStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TriggerMessageStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TriggerMessageStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(TriggerMessageStatus::Accepted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(TriggerMessageStatus::Rejected)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(TriggerMessageStatus::NotImplemented)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Accepted", "Rejected", "NotImplemented"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TriggerMessageStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TriggerMessageStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TriggerMessageStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TriggerMessageStatus::Accepted,) => {
                        ::core::fmt::Formatter::write_str(f, "Accepted")
                    }
                    (&TriggerMessageStatus::Rejected,) => {
                        ::core::fmt::Formatter::write_str(f, "Rejected")
                    }
                    (&TriggerMessageStatus::NotImplemented,) => {
                        ::core::fmt::Formatter::write_str(f, "NotImplemented")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for TriggerMessageStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TriggerMessageStatus {
            #[inline]
            fn eq(&self, other: &TriggerMessageStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for TriggerMessageStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for TriggerMessageStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for TriggerMessageStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    TriggerMessageStatus::Accepted => f.pad("Accepted"),
                    TriggerMessageStatus::Rejected => f.pad("Rejected"),
                    TriggerMessageStatus::NotImplemented => f.pad("NotImplemented"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TriggerMessageStatus {
            #[inline]
            fn clone(&self) -> TriggerMessageStatus {
                match (&*self,) {
                    (&TriggerMessageStatus::Accepted,) => TriggerMessageStatus::Accepted,
                    (&TriggerMessageStatus::Rejected,) => TriggerMessageStatus::Rejected,
                    (&TriggerMessageStatus::NotImplemented,) => {
                        TriggerMessageStatus::NotImplemented
                    }
                }
            }
        }
    }
    pub mod unlock_connector {
        //! Server request for a ChargePoint to allow a connector to unlock from a vehicle
        //!
        //! # Behaviour
        //! The purpose of this message: Help EV drivers that have problems unplugging their cable from the Charge Point in case of malfunction of the
        //! Connector cable retention. When a EV driver calls the CPO help-desk, an operator could manually trigger the sending of an UnlockConnector.req
        //! to the Charge Point, forcing a new attempt to unlock the connector. Hopefully this time the connector unlocks and the EV driver can unplug the cable and drive away.
        //!
        //! The UnlockConnector.req SHOULD NOT be used to remotely stop a running transaction, use the Remote Stop Transaction instead.
        //!
        //! # Response
        //! Upon receipt of an UnlockConnector.req PDU, the Charge Point SHALL respond with a UnlockConnector.conf PDU. The response PDU SHALL
        //! indicate whether the Charge Point was able to unlock its connector. If there was a transaction in progress on the specific connector,
        //! then Charge Point SHALL finish the transaction first as described in Stop Transaction.
        use crate::validation_macros::{self, json_validate};
        use serde::{Deserialize, Serialize};
        use strum_macros::Display;
        const UNLOCKCONNECTORREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:UnlockConnectorRequest\",\r\n    \"title\": \"UnlockConnectorRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"connectorId\": {\r\n            \"type\": \"integer\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"connectorId\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UNLOCKCONNECTORREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static UNLOCKCONNECTORREQUEST_JSON: UNLOCKCONNECTORREQUEST_JSON =
            UNLOCKCONNECTORREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UNLOCKCONNECTORREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(UNLOCKCONNECTORREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UnlockConnector.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UNLOCKCONNECTORREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UNLOCKCONNECTORREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static UNLOCKCONNECTORREQUEST_VALIDATOR: UNLOCKCONNECTORREQUEST_VALIDATOR =
            UNLOCKCONNECTORREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UNLOCKCONNECTORREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&UNLOCKCONNECTORREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UnlockConnector.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UNLOCKCONNECTORREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for UnlockConnectorRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = UNLOCKCONNECTORREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/unlock_connector.rs:20",
                                    "ocpp::server_init::unlock_connector",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/unlock_connector.rs"),
                                    Some(20u32),
                                    Some("ocpp::server_init::unlock_connector"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/unlock_connector.rs:20",
                                    "ocpp::server_init::unlock_connector",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/unlock_connector.rs"),
                                    Some(20u32),
                                    Some("ocpp::server_init::unlock_connector"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the UnlockConnector.req PDU sent by the Central System to the Charge Point.
        pub struct UnlockConnectorRequest {
            /// Required. This contains the identifier of the connector to be unlocked.
            pub connector_id: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UnlockConnectorRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "UnlockConnectorRequest",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "connectorId",
                        &self.connector_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UnlockConnectorRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "connectorId" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"connectorId" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UnlockConnectorRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UnlockConnectorRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UnlockConnectorRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UnlockConnectorRequest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UnlockConnectorRequest {
                                connector_id: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "connectorId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("connectorId") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(UnlockConnectorRequest {
                                connector_id: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["connectorId"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UnlockConnectorRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UnlockConnectorRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UnlockConnectorRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "UnlockConnectorRequest",
                    "connector_id",
                    &&self.connector_id,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UnlockConnectorRequest {
            #[inline]
            fn clone(&self) -> UnlockConnectorRequest {
                UnlockConnectorRequest {
                    connector_id: ::core::clone::Clone::clone(&self.connector_id),
                }
            }
        }
        const UNLOCKCONNECTORRESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"UnlockConnectorResponse\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"additionalProperties\": false,\n            \"enum\": [\n                \"Unlocked\",\n                \"UnlockFailed\",\n                \"NotSupported\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UNLOCKCONNECTORRESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static UNLOCKCONNECTORRESPONSE_JSON: UNLOCKCONNECTORRESPONSE_JSON =
            UNLOCKCONNECTORRESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UNLOCKCONNECTORRESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(UNLOCKCONNECTORRESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UnlockConnectorResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UNLOCKCONNECTORRESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UNLOCKCONNECTORRESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static UNLOCKCONNECTORRESPONSE_VALIDATOR: UNLOCKCONNECTORRESPONSE_VALIDATOR =
            UNLOCKCONNECTORRESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UNLOCKCONNECTORRESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&UNLOCKCONNECTORRESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UnlockConnectorResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UNLOCKCONNECTORRESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for UnlockConnectorResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = UNLOCKCONNECTORRESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/unlock_connector.rs:30",
                                    "ocpp::server_init::unlock_connector",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/unlock_connector.rs"),
                                    Some(30u32),
                                    Some("ocpp::server_init::unlock_connector"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/unlock_connector.rs:30",
                                    "ocpp::server_init::unlock_connector",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/unlock_connector.rs"),
                                    Some(30u32),
                                    Some("ocpp::server_init::unlock_connector"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the UnlockConnector.conf PDU sent by the Charge Point to the Central System in response to an UnlockConnector.req PDU.
        pub struct UnlockConnectorResponse {
            /// Required. This indicates whether the Charge Point has unlocked the connector.
            pub status: UnlockConnectorStatus,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UnlockConnectorResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "UnlockConnectorResponse",
                        false as usize + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UnlockConnectorResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"status" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UnlockConnectorResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UnlockConnectorResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UnlockConnectorResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                UnlockConnectorStatus,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UnlockConnectorResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UnlockConnectorResponse { status: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<UnlockConnectorStatus> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "status",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                UnlockConnectorStatus,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("status") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(UnlockConnectorResponse { status: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UnlockConnectorResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UnlockConnectorResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UnlockConnectorResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "UnlockConnectorResponse",
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UnlockConnectorResponse {
            #[inline]
            fn clone(&self) -> UnlockConnectorResponse {
                UnlockConnectorResponse {
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        /// Status in response to UnlockConnector.req.
        pub enum UnlockConnectorStatus {
            /// Connector has successfully been unlocked.
            Unlocked,
            /// Failed to unlock the connector: The Charge Point has tried to unlock the connector and has detected that the connector is still locked or the unlock mechanism failed
            UnlockFailed,
            /// Charge Point has no connector lock, or ConnectorId is unknown.
            NotSupported,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UnlockConnectorStatus {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        UnlockConnectorStatus::Unlocked => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "UnlockConnectorStatus",
                                0u32,
                                "Unlocked",
                            )
                        }
                        UnlockConnectorStatus::UnlockFailed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "UnlockConnectorStatus",
                                1u32,
                                "UnlockFailed",
                            )
                        }
                        UnlockConnectorStatus::NotSupported => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "UnlockConnectorStatus",
                                2u32,
                                "NotSupported",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UnlockConnectorStatus {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Unlocked" => _serde::__private::Ok(__Field::__field0),
                                "UnlockFailed" => _serde::__private::Ok(__Field::__field1),
                                "NotSupported" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Unlocked" => _serde::__private::Ok(__Field::__field0),
                                b"UnlockFailed" => _serde::__private::Ok(__Field::__field1),
                                b"NotSupported" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UnlockConnectorStatus>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UnlockConnectorStatus;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum UnlockConnectorStatus",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UnlockConnectorStatus::Unlocked)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UnlockConnectorStatus::UnlockFailed)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(UnlockConnectorStatus::NotSupported)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Unlocked", "UnlockFailed", "NotSupported"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "UnlockConnectorStatus",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UnlockConnectorStatus>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UnlockConnectorStatus {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&UnlockConnectorStatus::Unlocked,) => {
                        ::core::fmt::Formatter::write_str(f, "Unlocked")
                    }
                    (&UnlockConnectorStatus::UnlockFailed,) => {
                        ::core::fmt::Formatter::write_str(f, "UnlockFailed")
                    }
                    (&UnlockConnectorStatus::NotSupported,) => {
                        ::core::fmt::Formatter::write_str(f, "NotSupported")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for UnlockConnectorStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UnlockConnectorStatus {
            #[inline]
            fn eq(&self, other: &UnlockConnectorStatus) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for UnlockConnectorStatus {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for UnlockConnectorStatus {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        impl ::core::fmt::Display for UnlockConnectorStatus {
            fn fmt(
                &self,
                f: &mut ::core::fmt::Formatter,
            ) -> ::core::result::Result<(), ::core::fmt::Error> {
                match *self {
                    UnlockConnectorStatus::Unlocked => f.pad("Unlocked"),
                    UnlockConnectorStatus::UnlockFailed => f.pad("UnlockFailed"),
                    UnlockConnectorStatus::NotSupported => f.pad("NotSupported"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UnlockConnectorStatus {
            #[inline]
            fn clone(&self) -> UnlockConnectorStatus {
                match (&*self,) {
                    (&UnlockConnectorStatus::Unlocked,) => UnlockConnectorStatus::Unlocked,
                    (&UnlockConnectorStatus::UnlockFailed,) => UnlockConnectorStatus::UnlockFailed,
                    (&UnlockConnectorStatus::NotSupported,) => UnlockConnectorStatus::NotSupported,
                }
            }
        }
    }
    pub mod update_firmware {
        //! Server request for a chargepoint to update it's firmware
        //!
        //! # Behaviour
        //! Central System can notify a Charge Point that it needs to update its firmware. The Central System SHALL send an UpdateFirmware.req
        //! PDU to instruct the Charge Point to install new firmware. The PDU SHALL contain a date and time after which the Charge Point is
        //! allowed to retrieve the new firmware and the location from which the firmware can be downloaded.
        //!
        //! The Charge Point SHALL, if the new firmware image is "valid", install the new firmware as soon as it is able to.
        //!
        //! If it is not possible to continue charging during installation of firmware, it is RECOMMENDED to wait until Charging Session has
        //! ended (Charge Point idle) before commencing installation. It is RECOMMENDED to set connectors that are not in use to UNAVAILABLE
        //! while the Charge Point waits for the Session to end.
        //!
        //! # Response
        //! Upon receipt of an UpdateFirmware.req PDU, the Charge Point SHALL respond with a UpdateFirmware.conf PDU. The Charge Point SHOULD
        //! start retrieving the firmware as soon as possible after retrieve-date. During downloading and installation of the firmware, the
        //! Charge Point MUST send FirmwareStatusNotification.req PDUs to keep the Central System updated with the status of the update process.
        use crate::validation_macros::{self, json_validate};
        use chrono::{DateTime, Utc};
        use serde::{Deserialize, Serialize};
        use serde_with::skip_serializing_none;
        const UPDATEFIRMWAREREQUEST_SCHEMA : & str = "{\r\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\r\n    \"id\": \"urn:OCPP:1.6:2019:12:UpdateFirmwareRequest\",\r\n    \"title\": \"UpdateFirmwareRequest\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"location\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"uri\"\r\n        },\r\n        \"retries\": {\r\n            \"type\": \"integer\"\r\n        },\r\n        \"retrieveDate\": {\r\n            \"type\": \"string\",\r\n            \"format\": \"date-time\"\r\n        },\r\n        \"retryInterval\": {\r\n            \"type\": \"integer\"\r\n        }\r\n    },\r\n    \"additionalProperties\": false,\r\n    \"required\": [\r\n        \"location\",\r\n        \"retrieveDate\"\r\n    ]\r\n}\r\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UPDATEFIRMWAREREQUEST_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static UPDATEFIRMWAREREQUEST_JSON: UPDATEFIRMWAREREQUEST_JSON =
            UPDATEFIRMWAREREQUEST_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UPDATEFIRMWAREREQUEST_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(UPDATEFIRMWAREREQUEST_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UpdateFirmware.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UPDATEFIRMWAREREQUEST_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UPDATEFIRMWAREREQUEST_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static UPDATEFIRMWAREREQUEST_VALIDATOR: UPDATEFIRMWAREREQUEST_VALIDATOR =
            UPDATEFIRMWAREREQUEST_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UPDATEFIRMWAREREQUEST_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&UPDATEFIRMWAREREQUEST_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UpdateFirmware.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UPDATEFIRMWAREREQUEST_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for UpdateFirmwareRequest {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = UPDATEFIRMWAREREQUEST_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/update_firmware.rs:25",
                                    "ocpp::server_init::update_firmware",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/update_firmware.rs"),
                                    Some(25u32),
                                    Some("ocpp::server_init::update_firmware"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/update_firmware.rs:25",
                                    "ocpp::server_init::update_firmware",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/update_firmware.rs"),
                                    Some(25u32),
                                    Some("ocpp::server_init::update_firmware"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the UpdateFirmware.req PDU sent by the Central System to the Charge Point.
        pub struct UpdateFirmwareRequest {
            /// Required. This contains a string containing a URI pointing to a location from which to retrieve the firmware.
            pub location: String,
            /// Optional. This specifies how many times Charge Point must try to download the firmware before giving up. If this field is not
            /// present, it is left to Charge Point to decide how many times it wants to retry.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub retries: Option<u32>,
            /// Required. This contains the date and time after which the Charge Point is allowed to retrieve the (new) firmware.
            pub retrieve_date: DateTime<Utc>,
            /// Optional. The interval in seconds after which a retry may be attempted. If this field is not present, it is left to Charge Point
            /// to decide how long to wait between attempts.
            #[serde(skip_serializing_if = "Option::is_none")]
            pub retry_interval: Option<u32>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UpdateFirmwareRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "UpdateFirmwareRequest",
                        false as usize
                            + 1
                            + if Option::is_none(&self.retries) { 0 } else { 1 }
                            + 1
                            + if Option::is_none(&self.retry_interval) {
                                0
                            } else {
                                1
                            },
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "location",
                        &self.location,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.retries) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "retries",
                            &self.retries,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "retries",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "retrieveDate",
                        &self.retrieve_date,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.retry_interval) {
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "retryInterval",
                            &self.retry_interval,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(
                            &mut __serde_state,
                            "retryInterval",
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UpdateFirmwareRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "location" => _serde::__private::Ok(__Field::__field0),
                                "retries" => _serde::__private::Ok(__Field::__field1),
                                "retrieveDate" => _serde::__private::Ok(__Field::__field2),
                                "retryInterval" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"location" => _serde::__private::Ok(__Field::__field0),
                                b"retries" => _serde::__private::Ok(__Field::__field1),
                                b"retrieveDate" => _serde::__private::Ok(__Field::__field2),
                                b"retryInterval" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UpdateFirmwareRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UpdateFirmwareRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UpdateFirmwareRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UpdateFirmwareRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UpdateFirmwareRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                DateTime<Utc>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct UpdateFirmwareRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct UpdateFirmwareRequest with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UpdateFirmwareRequest {
                                location: __field0,
                                retries: __field1,
                                retrieve_date: __field2,
                                retry_interval: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<DateTime<Utc>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "location",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "retries",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "retrieveDate",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<DateTime<Utc>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "retryInterval",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("location") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("retries") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("retrieveDate") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("retryInterval") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(UpdateFirmwareRequest {
                                location: __field0,
                                retries: __field1,
                                retrieve_date: __field2,
                                retry_interval: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["location", "retries", "retrieveDate", "retryInterval"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UpdateFirmwareRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UpdateFirmwareRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdateFirmwareRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "UpdateFirmwareRequest",
                    "location",
                    &&self.location,
                    "retries",
                    &&self.retries,
                    "retrieve_date",
                    &&self.retrieve_date,
                    "retry_interval",
                    &&self.retry_interval,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdateFirmwareRequest {
            #[inline]
            fn clone(&self) -> UpdateFirmwareRequest {
                UpdateFirmwareRequest {
                    location: ::core::clone::Clone::clone(&self.location),
                    retries: ::core::clone::Clone::clone(&self.retries),
                    retrieve_date: ::core::clone::Clone::clone(&self.retrieve_date),
                    retry_interval: ::core::clone::Clone::clone(&self.retry_interval),
                }
            }
        }
        const UPDATEFIRMWARERESPONSE_SCHEMA : & str = "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"UpdateFirmwareResponse\",\n    \"type\": \"object\",\n    \"properties\": {},\n    \"additionalProperties\": false\n}\n" ;
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UPDATEFIRMWARERESPONSE_JSON {
            __private_field: (),
        }
        #[doc(hidden)]
        static UPDATEFIRMWARERESPONSE_JSON: UPDATEFIRMWARERESPONSE_JSON =
            UPDATEFIRMWARERESPONSE_JSON {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UPDATEFIRMWARERESPONSE_JSON {
            type Target = serde_json::Value;
            fn deref(&self) -> &serde_json::Value {
                #[inline(always)]
                fn __static_ref_initialize() -> serde_json::Value {
                    serde_json::from_str(UPDATEFIRMWARERESPONSE_SCHEMA).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File Format: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UpdateFirmwareResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static serde_json::Value {
                    static LAZY: ::lazy_static::lazy::Lazy<serde_json::Value> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UPDATEFIRMWARERESPONSE_JSON {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UPDATEFIRMWARERESPONSE_VALIDATOR {
            __private_field: (),
        }
        #[doc(hidden)]
        static UPDATEFIRMWARERESPONSE_VALIDATOR: UPDATEFIRMWARERESPONSE_VALIDATOR =
            UPDATEFIRMWARERESPONSE_VALIDATOR {
                __private_field: (),
            };
        impl ::lazy_static::__Deref for UPDATEFIRMWARERESPONSE_VALIDATOR {
            type Target = jsonschema::JSONSchema;
            fn deref(&self) -> &jsonschema::JSONSchema {
                #[inline(always)]
                fn __static_ref_initialize() -> jsonschema::JSONSchema {
                    jsonschema::JSONSchema::compile(&UPDATEFIRMWARERESPONSE_JSON).expect(&{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Invalid Schema File: "],
                            &[::core::fmt::ArgumentV1::new_display(
                                &"../json_schemas/UpdateFirmwareResponse.json",
                            )],
                        ));
                        res
                    })
                }
                #[inline(always)]
                fn __stability() -> &'static jsonschema::JSONSchema {
                    static LAZY: ::lazy_static::lazy::Lazy<jsonschema::JSONSchema> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UPDATEFIRMWARERESPONSE_VALIDATOR {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl validation_macros::JsonValidate for UpdateFirmwareResponse {
            fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
                use tracing::{warn, trace};
                if let Err(val) = UPDATEFIRMWARERESPONSE_VALIDATOR
                    .validate(&::serde_json::to_value(&self).unwrap())
                    .map_err(|errors| {
                        validation_macros::JsonValidateError::ValidationError(Vec::from_iter(
                            errors.map(|e| e.to_string()),
                        ))
                    })
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/update_firmware.rs:44",
                                    "ocpp::server_init::update_firmware",
                                    ::tracing::Level::WARN,
                                    Some("src/server_init/update_firmware.rs"),
                                    Some(44u32),
                                    Some("ocpp::server_init::update_firmware"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &[
                                            "Validate failed on Json Value Struct ",
                                            ", with error: ",
                                            " ",
                                        ],
                                        &[
                                            ::core::fmt::ArgumentV1::new_debug(&&self),
                                            ::core::fmt::ArgumentV1::new_display(&val),
                                        ],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Err(val);
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src/server_init/update_firmware.rs:44",
                                    "ocpp::server_init::update_firmware",
                                    ::tracing::Level::TRACE,
                                    Some("src/server_init/update_firmware.rs"),
                                    Some(44u32),
                                    Some("ocpp::server_init::update_firmware"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE.metadata().fields().value_set(&[(
                                    &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                    Some(&::core::fmt::Arguments::new_v1(
                                        &["Succesfully validated Json Value Struct "],
                                        &[::core::fmt::ArgumentV1::new_debug(&&self)],
                                    ) as &Value),
                                )])
                            });
                        } else {
                        }
                    };
                    return Ok(());
                }
            }
        }
        #[serde(rename_all = "camelCase")]
        /// Field definition of the UpdateFirmware.conf PDU sent by the Charge Point to the Central System in response to a UpdateFirmware.req PDU.
        pub struct UpdateFirmwareResponse {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UpdateFirmwareResponse {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "UpdateFirmwareResponse",
                        false as usize,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UpdateFirmwareResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UpdateFirmwareResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UpdateFirmwareResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UpdateFirmwareResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(UpdateFirmwareResponse {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::__private::Ok(UpdateFirmwareResponse {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UpdateFirmwareResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UpdateFirmwareResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdateFirmwareResponse {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "UpdateFirmwareResponse")
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdateFirmwareResponse {
            #[inline]
            fn clone(&self) -> UpdateFirmwareResponse {
                UpdateFirmwareResponse {}
            }
        }
    }
    pub use crate::common::data_transfer::*;
    pub use change_availability::*;
    pub use change_configuration::*;
    pub use clear_cache::*;
    pub use clear_charging_profile::*;
    pub use get_composite_schedule::*;
    pub use get_configuration::*;
    pub use get_diagnostics::*;
    pub use get_local_list_version::*;
    pub use remote_start_transaction::*;
    pub use remote_stop_transaction::*;
    pub use reset::*;
    pub use send_local_list::*;
    pub use set_charging_profile::*;
    pub use trigger_message::*;
    pub use unlock_connector::*;
    pub use update_firmware::*;
}
pub mod validation_macros {
    //! Validator trait for structs with an associated schema
    use std::error::Error;
    use std::fmt;
    pub use macros::json_validate;
    /// Errors associated with validating against a json schema
    pub enum JsonValidateError {
        /// Error if validation fails
        ValidationError(Vec<String>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for JsonValidateError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&JsonValidateError::ValidationError(ref __self_0),) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ValidationError",
                        &&*__self_0,
                    )
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for JsonValidateError {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for JsonValidateError {
        #[inline]
        fn eq(&self, other: &JsonValidateError) -> bool {
            match (&*self, &*other) {
                (
                    &JsonValidateError::ValidationError(ref __self_0),
                    &JsonValidateError::ValidationError(ref __arg_1_0),
                ) => *__self_0 == *__arg_1_0,
            }
        }
        #[inline]
        fn ne(&self, other: &JsonValidateError) -> bool {
            match (&*self, &*other) {
                (
                    &JsonValidateError::ValidationError(ref __self_0),
                    &JsonValidateError::ValidationError(ref __arg_1_0),
                ) => *__self_0 != *__arg_1_0,
            }
        }
    }
    impl fmt::Display for JsonValidateError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Self::ValidationError(e) => {
                    let result = f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["Validation Error: "],
                        &[::core::fmt::ArgumentV1::new_debug(&e)],
                    ));
                    result
                }
            }
        }
    }
    impl Error for JsonValidateError {}
    /// Trait for structures that can be validated against a schema
    pub trait JsonValidate {
        /// Validate schema against json document
        fn schema_validate(&self) -> Result<(), JsonValidateError>;
    }
    pub use macros::ValidateCompare;
}
#[cfg(test)]
pub mod test {
    use crate::{point_init::boot_notification::*, validation_macros::JsonValidate};
    use chrono::Utc;
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_boot_notification_response_validates: test::TestDescAndFn =
        test::TestDescAndFn {
            desc: test::TestDesc {
                name: test::StaticTestName("test::test_boot_notification_response_validates"),
                ignore: false,
                ignore_message: ::core::option::Option::None,
                compile_fail: false,
                no_run: false,
                should_panic: test::ShouldPanic::No,
                test_type: test::TestType::UnitTest,
            },
            testfn: test::StaticTestFn(|| {
                test::assert_test_result(test_boot_notification_response_validates())
            }),
        };
    fn test_boot_notification_response_validates() {
        let bn_res = BootNotificationResponse {
            current_time: Utc::now().into(),
            status: BootNotificationStatus::Accepted,
            interval: 10,
        };
        if !bn_res.schema_validate().is_ok() {
            ::core::panicking::panic("assertion failed: bn_res.schema_validate().is_ok()")
        };
    }
    fn implements_display<T: std::fmt::Display>() {}
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_enum_display: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("test::test_enum_display"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(test_enum_display())),
    };
    fn test_enum_display() {
        implements_display::<crate::common_types::SimpleStatus>();
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_boot_notification_request_validates: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("test::test_boot_notification_request_validates"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| {
            test::assert_test_result(test_boot_notification_request_validates())
        }),
    };
    fn test_boot_notification_request_validates() {
        let bn_req = BootNotificationRequest {
            charge_point_vendor: "test1".to_string(),
            charge_point_model: "test2".to_string(),
            charge_point_serial_number: Some("test3".to_string()),
            charge_box_serial_number: Some("test4".to_string()),
            firmware_version: Some("test5".to_string()),
            iccid: Some("test6".to_string()),
            imsi: Some("test7".to_string()),
            meter_type: None,
            meter_serial_number: None,
        };
        if !bn_req.schema_validate().is_ok() {
            ::core::panicking::panic("assertion failed: bn_req.schema_validate().is_ok()")
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_boot_notification_request_charge_point_model_string_length_limit:
        test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName(
                "test::test_boot_notification_request_charge_point_model_string_length_limit",
            ),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| {
            test::assert_test_result(
                test_boot_notification_request_charge_point_model_string_length_limit(),
            )
        }),
    };
    fn test_boot_notification_request_charge_point_model_string_length_limit() {
        let bn_req = BootNotificationRequest {
            charge_point_vendor: "test1".to_string(),
            charge_point_model: "test2 AND SOME ARBITRARILY LONG STRING HERE TO BREAK THINGS"
                .to_string(),
            charge_point_serial_number: Some("test3".to_string()),
            charge_box_serial_number: Some("test4".to_string()),
            firmware_version: Some("test5".to_string()),
            iccid: Some("test6".to_string()),
            imsi: Some("test7".to_string()),
            meter_type: Some("test8".to_string()),
            meter_serial_number: Some("test9".to_string()),
        };
        if !bn_req.schema_validate().is_err() {
            ::core::panicking::panic("assertion failed: bn_req.schema_validate().is_err()")
        };
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_deserialize_json_call: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("test::test_deserialize_json_call"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(test_deserialize_json_call())),
    };
    fn test_deserialize_json_call() -> Result<(), Box<dyn std::error::Error>> {
        let json = "[2,\"63:2\",\"StatusNotification\",{\"connectorId\":0,\"errorCode\":\"NoError\",\"status\":\"Available\",\"timestamp\":\"2022-01-24T04:30:50.621Z\"}]" ;
        let value: crate::OCPPMessage = serde_json::from_str(json)?;
        if !match value {
            crate::OCPPMessage::Call(..) => true,
            _ => false,
        } {
            ::core::panicking::panic(
                "assertion failed: matches!(value, crate :: OCPPMessage :: Call(..))",
            )
        };
        if let crate::OCPPMessage::Call(call) = value {
            if !match call.payload {
                crate::OCPPCallPayload::StatusNotification(..) => true,
                _ => false,
            } {
                :: core :: panicking :: panic ("assertion failed: matches!(call.payload, crate :: OCPPCallPayload :: StatusNotification(..))")
            };
        }
        Ok(())
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_deserialize_json_call_result: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("test::test_deserialize_json_call_result"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(
            || test::assert_test_result(test_deserialize_json_call_result()),
        ),
    };
    fn test_deserialize_json_call_result() -> Result<(), Box<dyn std::error::Error>> {
        let json = "[3,\"63:2\",{}]";
        let value: crate::OCPPMessage = serde_json::from_str(json)?;
        if !match value {
            crate::OCPPMessage::CallResultUnknown(..) => true,
            _ => false,
        } {
            ::core::panicking::panic(
                "assertion failed: matches!(value, crate :: OCPPMessage :: CallResultUnknown(..))",
            )
        };
        if let crate::OCPPMessage::CallResultUnknown(unknown) = value {
            let result = crate::OCPPCallResult::from_unknown(
                &crate::OCPPCallAction::StatusNotification,
                unknown,
            )?;
            if !match result.payload {
                crate::OCPPCallResultPayload::StatusNotification(..) => true,
                _ => false,
            } {
                :: core :: panicking :: panic ("assertion failed: matches!(result.payload, crate :: OCPPCallResultPayload ::\\n    StatusNotification(..))")
            };
        }
        Ok(())
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_serialize_get_configuration_call: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("test::test_serialize_get_configuration_call"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| {
            test::assert_test_result(test_serialize_get_configuration_call())
        }),
    };
    fn test_serialize_get_configuration_call() -> Result<(), Box<dyn std::error::Error>> {
        let req = crate::GetConfigurationRequest { key: None };
        req.schema_validate()?;
        let message = crate::OCPPMessage::Call(
            (
                String::from("64:1"),
                crate::OCPPCallPayload::GetConfiguration(req),
            )
                .into(),
        );
        let json = serde_json::to_string(&message)?;
        let expected = "[2,\"64:1\",\"GetConfiguration\",{}]";
        match (&json, &expected) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        Ok(())
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_charge_point_builder: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("test::test_charge_point_builder"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(test_charge_point_builder())),
    };
    fn test_charge_point_builder() -> Result<(), Box<dyn std::error::Error>> {
        use crate::charging_profile::*;
        let builder = ChargingProfile::builder(ChargingRateUnit::W)
            .id(999)
            .level(5);
        let profile = builder.build();
        let example_profile = ChargingProfile {
            charging_profile_id: 999,
            transaction_id: None,
            stack_level: 5,
            charging_profile_kind: ChargingProfileKind::Relative,
            charging_profile_purpose: ChargingProfilePurpose::TxProfile,
            recurrency_kind: None,
            valid_to: None,
            valid_from: None,
            charging_schedule: ChargingSchedule {
                duration: None,
                start_schedule: None,
                charging_rate_unit: ChargingRateUnit::W,
                min_charging_rate: None,
                charging_schedule_period: Vec::new(),
            },
        };
        match (&profile, &example_profile) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        return Ok(());
    }
}
pub use common::*;
pub use point_init::*;
pub use server_init::*;
use validation_macros::JsonValidate;
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use strum_macros::Display;
use thiserror::Error;
/// Overarching OCPP Message use to encapsulate calls, call results and call errors
#[serde(untagged)]
pub enum OCPPMessage {
    /// OCPP Call or Request, sent from Client to Server
    Call(OCPPCall),
    /// OCPP Call Result or Response, sent from Server to Client
    #[serde(skip_deserializing)]
    CallResult(OCPPCallResult),
    /// OCPP Call Result or Response, sent from Server to Client
    #[serde(skip_serializing)]
    CallResultUnknown(OCPPCallResultUnknown),
    /// OCPP Call Error, sent from Server to Client
    CallError(OCPPCallError),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for OCPPMessage {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                OCPPMessage::Call(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPMessage::CallResult(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPMessage::CallResultUnknown(..) => {
                    _serde::__private::Err(_serde::ser::Error::custom(
                        "the enum variant OCPPMessage::CallResultUnknown cannot be serialized",
                    ))
                }
                OCPPMessage::CallError(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for OCPPMessage {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            let __content =
                match <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                    __deserializer,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <OCPPCall as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPMessage::Call,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <OCPPCallResultUnknown as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPMessage::CallResultUnknown,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <OCPPCallError as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPMessage::CallError,
            ) {
                return _serde::__private::Ok(__ok);
            }
            _serde::__private::Err(_serde::de::Error::custom(
                "data did not match any variant of untagged enum OCPPMessage",
            ))
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for OCPPMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&OCPPMessage::Call(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Call", &&*__self_0)
            }
            (&OCPPMessage::CallResult(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "CallResult", &&*__self_0)
            }
            (&OCPPMessage::CallResultUnknown(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CallResultUnknown",
                    &&*__self_0,
                )
            }
            (&OCPPMessage::CallError(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "CallError", &&*__self_0)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OCPPMessage {
    #[inline]
    fn clone(&self) -> OCPPMessage {
        match (&*self,) {
            (&OCPPMessage::Call(ref __self_0),) => {
                OCPPMessage::Call(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPMessage::CallResult(ref __self_0),) => {
                OCPPMessage::CallResult(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPMessage::CallResultUnknown(ref __self_0),) => {
                OCPPMessage::CallResultUnknown(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPMessage::CallError(ref __self_0),) => {
                OCPPMessage::CallError(::core::clone::Clone::clone(&*__self_0))
            }
        }
    }
}
/// OCPP Call or Request, sent from Client to Server
pub struct OCPPCall {
    /// Unique message ID, used to match pairs of requests/responses
    pub unique_id: String,
    /// The type of message
    action: String,
    /// Message payload
    pub payload: OCPPCallPayload,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for OCPPCall {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "OCPPCall",
            "unique_id",
            &&self.unique_id,
            "action",
            &&self.action,
            "payload",
            &&self.payload,
        )
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OCPPCall {
    #[inline]
    fn clone(&self) -> OCPPCall {
        OCPPCall {
            unique_id: ::core::clone::Clone::clone(&self.unique_id),
            action: ::core::clone::Clone::clone(&self.action),
            payload: ::core::clone::Clone::clone(&self.payload),
        }
    }
}
impl Serialize for OCPPCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (2, &self.unique_id, &self.action, &self.payload).serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for OCPPCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (message_type_id, unique_id, action, payload_raw): (
            u8,
            String,
            String,
            serde_json::Value,
        ) = Deserialize::deserialize(deserializer)?;
        if message_type_id != 2 {
            return Err(de::Error::invalid_value(
                de::Unexpected::Unsigned(message_type_id.into()),
                &"Message Type ID for Call should be '2'",
            ));
        }
        let payload = match action.as_ref() {
            "Authorize" => OCPPCallPayload::Authorize(
                AuthorizeRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "BootNotification" => OCPPCallPayload::BootNotification(
                BootNotificationRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "ChangeAvailability" => OCPPCallPayload::ChangeAvailability(
                ChangeAvailabilityRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "ChangeConfiguration" => OCPPCallPayload::ChangeConfiguration(
                ChangeConfigurationRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "ClearCache" => OCPPCallPayload::ClearCache(
                ClearCacheRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "ClearChargingProfile" => OCPPCallPayload::ClearChargingProfile(
                ClearChargingProfileRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "DataTransfer" => OCPPCallPayload::DataTransfer(
                DataTransferRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "DiagnosticsStatusNotification" => OCPPCallPayload::DiagnosticsStatusNotification(
                DiagnosticsStatusNotificationRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "FirmwareStatusNotification" => OCPPCallPayload::FirmwareStatusNotification(
                FirmwareStatusNotificationRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "GetCompositeSchedule" => OCPPCallPayload::GetCompositeSchedule(
                GetCompositeScheduleRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "GetConfiguration" => OCPPCallPayload::GetConfiguration(
                GetConfigurationRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "GetDiagnostics" => OCPPCallPayload::GetDiagnostics(
                GetDiagnosticsRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "GetLocalListVersion" => OCPPCallPayload::GetLocalListVersion(
                GetLocalListVersionRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "Heartbeat" => OCPPCallPayload::Heartbeat(
                HeartbeatRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "MeterValues" => OCPPCallPayload::MeterValues(
                MeterValuesRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "RemoteStartTransaction" => OCPPCallPayload::RemoteStartTransaction(
                RemoteStartTransactionRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "RemoteStopTransaction" => OCPPCallPayload::RemoteStopTransaction(
                RemoteStopTransactionRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "Reset" => {
                OCPPCallPayload::Reset(ResetRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?)
            }
            "SendLocalList" => OCPPCallPayload::SendLocalList(
                SendLocalListRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "SetChargingProfile" => OCPPCallPayload::SetChargingProfile(
                SetChargingProfileRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "StartTransaction" => OCPPCallPayload::StartTransaction(
                StartTransactionRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "StatusNotification" => OCPPCallPayload::StatusNotification(
                StatusNotificationRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "StopTransaction" => OCPPCallPayload::StopTransaction(
                StopTransactionRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "TriggerMessage" => OCPPCallPayload::TriggerMessage(
                TriggerMessageRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "UnlockConnector" => OCPPCallPayload::UnlockConnector(
                UnlockConnectorRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            "UpdateFirmware" => OCPPCallPayload::UpdateFirmware(
                UpdateFirmwareRequest::deserialize(payload_raw).map_err(|e| {
                    de::Error::custom({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &[::core::fmt::ArgumentV1::new_display(&e)],
                        ));
                        res
                    })
                })?,
            ),
            _ => {
                return Err(de::Error::unknown_variant(
                    &action,
                    &[
                        "Authorize",
                        "BootNotification",
                        "ChangeAvailability",
                        "ChangeConfiguration",
                        "ClearCache",
                        "ClearChargingProfile",
                        "DataTransfer",
                        "DiagnosticsStatusNotification",
                        "FirmwareStatusNotification",
                        "GetCompositeSchedule",
                        "GetConfiguration",
                        "GetDiagnostics",
                        "GetLocalListVersion",
                        "Heartbeat",
                        "MeterValues",
                        "RemoteStartTransaction",
                        "RemoteStopTransaction",
                        "Reset",
                        "SendLocalList",
                        "SetChargingProfile",
                        "StartTransaction",
                        "StatusNotification",
                        "StopTransaction",
                        "TriggerMessage",
                        "UnlockConnector",
                        "UpdateFirmware",
                    ],
                ));
            }
        };
        Ok(OCPPCall {
            unique_id,
            action,
            payload,
        })
    }
}
impl From<(String, OCPPCallPayload)> for OCPPCall {
    fn from(from: (String, OCPPCallPayload)) -> OCPPCall {
        let (unique_id, payload) = from;
        let action = String::from(match payload {
            OCPPCallPayload::Authorize(_) => "Authorize",
            OCPPCallPayload::BootNotification(_) => "BootNotification",
            OCPPCallPayload::ChangeAvailability(_) => "ChangeAvailability",
            OCPPCallPayload::ChangeConfiguration(_) => "ChangeConfiguration",
            OCPPCallPayload::ClearCache(_) => "ClearCache",
            OCPPCallPayload::ClearChargingProfile(_) => "ClearChargingProfile",
            OCPPCallPayload::DataTransfer(_) => "DataTransfer",
            OCPPCallPayload::DiagnosticsStatusNotification(_) => "DiagnosticsStatusNotification",
            OCPPCallPayload::FirmwareStatusNotification(_) => "FirmwareStatusNotification",
            OCPPCallPayload::GetCompositeSchedule(_) => "GetCompositeSchedule",
            OCPPCallPayload::GetConfiguration(_) => "GetConfiguration",
            OCPPCallPayload::GetDiagnostics(_) => "GetDiagnostics",
            OCPPCallPayload::GetLocalListVersion(_) => "GetLocalListVersion",
            OCPPCallPayload::Heartbeat(_) => "Heartbeat",
            OCPPCallPayload::MeterValues(_) => "MeterValues",
            OCPPCallPayload::RemoteStartTransaction(_) => "RemoteStartTransaction",
            OCPPCallPayload::RemoteStopTransaction(_) => "RemoteStopTransaction",
            OCPPCallPayload::Reset(_) => "Reset",
            OCPPCallPayload::SendLocalList(_) => "SendLocalList",
            OCPPCallPayload::SetChargingProfile(_) => "SetChargingProfile",
            OCPPCallPayload::StartTransaction(_) => "StartTransaction",
            OCPPCallPayload::StatusNotification(_) => "StatusNotification",
            OCPPCallPayload::StopTransaction(_) => "StopTransaction",
            OCPPCallPayload::TriggerMessage(_) => "TriggerMessage",
            OCPPCallPayload::UnlockConnector(_) => "UnlockConnector",
            OCPPCallPayload::UpdateFirmware(_) => "UpdateFirmware",
        });
        OCPPCall {
            unique_id,
            action,
            payload,
        }
    }
}
/// OCPP Call Result or Response, sent from Server to Client
/// For deserialization see [OCPPCallResultUnknown] and [OCPPCallResult::from_unknown]
pub struct OCPPCallResult {
    /// Unique message ID, used to match pairs of requests/responses
    pub unique_id: String,
    /// Message payload
    pub payload: OCPPCallResultPayload,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for OCPPCallResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "OCPPCallResult",
            "unique_id",
            &&self.unique_id,
            "payload",
            &&self.payload,
        )
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OCPPCallResult {
    #[inline]
    fn clone(&self) -> OCPPCallResult {
        OCPPCallResult {
            unique_id: ::core::clone::Clone::clone(&self.unique_id),
            payload: ::core::clone::Clone::clone(&self.payload),
        }
    }
}
impl Serialize for OCPPCallResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (3, &self.unique_id, &self.payload).serialize(serializer)
    }
}
/// OCPP Call Result or Response, sent from Server to Client
/// Helper type for partial deserialization of unknown types of result
/// Use this in conjunction with [OCPPCallResult::from_unknown]
pub struct OCPPCallResultUnknown {
    /// Unique message ID, used to match pairs of requests/responses
    pub unique_id: String,
    /// Message payload
    pub payload: serde_json::Value,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for OCPPCallResultUnknown {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "OCPPCallResultUnknown",
            "unique_id",
            &&self.unique_id,
            "payload",
            &&self.payload,
        )
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OCPPCallResultUnknown {
    #[inline]
    fn clone(&self) -> OCPPCallResultUnknown {
        OCPPCallResultUnknown {
            unique_id: ::core::clone::Clone::clone(&self.unique_id),
            payload: ::core::clone::Clone::clone(&self.payload),
        }
    }
}
impl<'de> Deserialize<'de> for OCPPCallResultUnknown {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (message_type_id, unique_id, payload): (u8, String, serde_json::Value) =
            Deserialize::deserialize(deserializer)?;
        if message_type_id != 3 {
            return Err(de::Error::invalid_value(
                de::Unexpected::Unsigned(message_type_id.into()),
                &"Message Type ID for Call Result should be '3'",
            ));
        }
        Ok(OCPPCallResultUnknown { unique_id, payload })
    }
}
impl OCPPCallResult {
    /// Convert OCPP Call result of an unspecified type into a specific and
    /// valid call result. Fails in case the provided call result is not a
    /// valid instance of the specified call type
    ///
    /// # Example
    /// ```
    /// # fn ocpp_from_unknown_example() -> Result<(), serde_json::Error> {
    /// use ocpp::*;
    ///
    /// // Decode message generically
    /// let json = "[3,\"63:2\",{}]";
    /// let value: OCPPMessage = serde_json::from_str(json)?;
    ///
    /// if let OCPPMessage::CallResultUnknown(unknown) = value {
    ///     // Convert from CallResultUnknown to CallResult, in this case assuming that we have a
    ///     // StatusNotification
    ///     let result = OCPPCallResult::from_unknown(&OCPPCallAction::StatusNotification, unknown)?;
    ///     println!("Decoded status notification response: {:#?}", result)
    /// }
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_unknown(
        action: &OCPPCallAction,
        unknown: OCPPCallResultUnknown,
    ) -> Result<Self, serde_json::Error> {
        let OCPPCallResultUnknown { unique_id, payload } = unknown;
        let payload = match action {
            OCPPCallAction::Authorize => {
                OCPPCallResultPayload::Authorize(AuthorizeResponse::deserialize(payload)?)
            }
            OCPPCallAction::BootNotification => OCPPCallResultPayload::BootNotification(
                BootNotificationResponse::deserialize(payload)?,
            ),
            OCPPCallAction::ChangeAvailability => OCPPCallResultPayload::ChangeAvailability(
                ChangeAvailabilityResponse::deserialize(payload)?,
            ),
            OCPPCallAction::ChangeConfiguration => OCPPCallResultPayload::ChangeConfiguration(
                ChangeConfigurationResponse::deserialize(payload)?,
            ),
            OCPPCallAction::ClearCache => {
                OCPPCallResultPayload::ClearCache(ClearCacheResponse::deserialize(payload)?)
            }
            OCPPCallAction::ClearChargingProfile => OCPPCallResultPayload::ClearChargingProfile(
                ClearChargingProfileResponse::deserialize(payload)?,
            ),
            OCPPCallAction::DataTransfer => {
                OCPPCallResultPayload::DataTransfer(DataTransferResponse::deserialize(payload)?)
            }
            OCPPCallAction::DiagnosticsStatusNotification => {
                OCPPCallResultPayload::DiagnosticsStatusNotification(
                    DiagnosticsStatusNotificationResponse::deserialize(payload)?,
                )
            }
            OCPPCallAction::FirmwareStatusNotification => {
                OCPPCallResultPayload::FirmwareStatusNotification(
                    FirmwareStatusNotificationResponse::deserialize(payload)?,
                )
            }
            OCPPCallAction::GetCompositeSchedule => OCPPCallResultPayload::GetCompositeSchedule(
                GetCompositeScheduleResponse::deserialize(payload)?,
            ),
            OCPPCallAction::GetConfiguration => OCPPCallResultPayload::GetConfiguration(
                GetConfigurationResponse::deserialize(payload)?,
            ),
            OCPPCallAction::GetDiagnostics => {
                OCPPCallResultPayload::GetDiagnostics(GetDiagnosticsResponse::deserialize(payload)?)
            }
            OCPPCallAction::GetLocalListVersion => OCPPCallResultPayload::GetLocalListVersion(
                GetLocalListVersionResponse::deserialize(payload)?,
            ),
            OCPPCallAction::Heartbeat => {
                OCPPCallResultPayload::Heartbeat(HeartbeatResponse::deserialize(payload)?)
            }
            OCPPCallAction::MeterValues => {
                OCPPCallResultPayload::MeterValues(MeterValuesResponse::deserialize(payload)?)
            }
            OCPPCallAction::RemoteStartTransaction => {
                OCPPCallResultPayload::RemoteStartTransaction(
                    RemoteStartTransactionResponse::deserialize(payload)?,
                )
            }
            OCPPCallAction::RemoteStopTransaction => OCPPCallResultPayload::RemoteStopTransaction(
                RemoteStopTransactionResponse::deserialize(payload)?,
            ),
            OCPPCallAction::Reset => {
                OCPPCallResultPayload::Reset(ResetResponse::deserialize(payload)?)
            }
            OCPPCallAction::SendLocalList => {
                OCPPCallResultPayload::SendLocalList(SendLocalListResponse::deserialize(payload)?)
            }
            OCPPCallAction::SetChargingProfile => OCPPCallResultPayload::SetChargingProfile(
                SetChargingProfileResponse::deserialize(payload)?,
            ),
            OCPPCallAction::StartTransaction => OCPPCallResultPayload::StartTransaction(
                StartTransactionResponse::deserialize(payload)?,
            ),
            OCPPCallAction::StatusNotification => OCPPCallResultPayload::StatusNotification(
                StatusNotificationResponse::deserialize(payload)?,
            ),
            OCPPCallAction::StopTransaction => OCPPCallResultPayload::StopTransaction(
                StopTransactionResponse::deserialize(payload)?,
            ),
            OCPPCallAction::TriggerMessage => {
                OCPPCallResultPayload::TriggerMessage(TriggerMessageResponse::deserialize(payload)?)
            }
            OCPPCallAction::UnlockConnector => OCPPCallResultPayload::UnlockConnector(
                UnlockConnectorResponse::deserialize(payload)?,
            ),
            OCPPCallAction::UpdateFirmware => {
                OCPPCallResultPayload::UpdateFirmware(UpdateFirmwareResponse::deserialize(payload)?)
            }
        };
        Ok(OCPPCallResult { unique_id, payload })
    }
}
/// OCPP Call Error, sent from Server to Client
pub struct OCPPCallError {
    /// Unique message ID, used to match pairs of requests/responses
    pub unique_id: String,
    /// Short error code
    pub error_code: OCPPCallErrorCode,
    /// Human readable error discription
    pub error_description: String,
    /// Error details
    pub error_details: serde_json::Value,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for OCPPCallError {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "OCPPCallError",
            "unique_id",
            &&self.unique_id,
            "error_code",
            &&self.error_code,
            "error_description",
            &&self.error_description,
            "error_details",
            &&self.error_details,
        )
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for OCPPCallError {
    #[inline]
    fn clone(&self) -> OCPPCallError {
        OCPPCallError {
            unique_id: ::core::clone::Clone::clone(&self.unique_id),
            error_code: ::core::clone::Clone::clone(&self.error_code),
            error_description: ::core::clone::Clone::clone(&self.error_description),
            error_details: ::core::clone::Clone::clone(&self.error_details),
        }
    }
}
impl Serialize for OCPPCallError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (
            4,
            &self.unique_id,
            &self.error_code,
            &self.error_description,
            &self.error_details,
        )
            .serialize(serializer)
    }
}
impl<'de> Deserialize<'de> for OCPPCallError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (message_type_id, unique_id, error_code, error_description, error_details): (
            u8,
            String,
            OCPPCallErrorCode,
            String,
            serde_json::Value,
        ) = Deserialize::deserialize(deserializer)?;
        if message_type_id != 4 {
            return Err(de::Error::invalid_value(
                de::Unexpected::Unsigned(message_type_id.into()),
                &"Message Type ID for Call Error should be '4'",
            ));
        }
        Ok(OCPPCallError {
            unique_id,
            error_code,
            error_description,
            error_details,
        })
    }
}
impl OCPPCallError {
    fn from_call(unique_id: &str, error_code: OCPPCallErrorCode) -> OCPPCallError {
        OCPPCallError {
            unique_id: String::from(unique_id),
            error_code,
            error_description: String::new(),
            error_details: ::serde_json::Value::Object(::serde_json::Map::new()),
        }
    }
}
/// OCPP Call Error Code
#[allow(missing_docs)]
pub enum OCPPCallErrorCode {
    NotImplemented,
    NotSupported,
    InternalError,
    ProtocolError,
    SecurityError,
    FormationViolation,
    PropertyConstraintViolation,
    OccurenceConstraintViolation,
    TypeConstraintViolation,
    GenericError,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for OCPPCallErrorCode {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                OCPPCallErrorCode::NotImplemented => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "OCPPCallErrorCode",
                    0u32,
                    "NotImplemented",
                ),
                OCPPCallErrorCode::NotSupported => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "OCPPCallErrorCode",
                    1u32,
                    "NotSupported",
                ),
                OCPPCallErrorCode::InternalError => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "OCPPCallErrorCode",
                    2u32,
                    "InternalError",
                ),
                OCPPCallErrorCode::ProtocolError => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "OCPPCallErrorCode",
                    3u32,
                    "ProtocolError",
                ),
                OCPPCallErrorCode::SecurityError => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "OCPPCallErrorCode",
                    4u32,
                    "SecurityError",
                ),
                OCPPCallErrorCode::FormationViolation => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "OCPPCallErrorCode",
                        5u32,
                        "FormationViolation",
                    )
                }
                OCPPCallErrorCode::PropertyConstraintViolation => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "OCPPCallErrorCode",
                        6u32,
                        "PropertyConstraintViolation",
                    )
                }
                OCPPCallErrorCode::OccurenceConstraintViolation => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "OCPPCallErrorCode",
                        7u32,
                        "OccurenceConstraintViolation",
                    )
                }
                OCPPCallErrorCode::TypeConstraintViolation => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "OCPPCallErrorCode",
                        8u32,
                        "TypeConstraintViolation",
                    )
                }
                OCPPCallErrorCode::GenericError => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "OCPPCallErrorCode",
                    9u32,
                    "GenericError",
                ),
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for OCPPCallErrorCode {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 10",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "NotImplemented" => _serde::__private::Ok(__Field::__field0),
                        "NotSupported" => _serde::__private::Ok(__Field::__field1),
                        "InternalError" => _serde::__private::Ok(__Field::__field2),
                        "ProtocolError" => _serde::__private::Ok(__Field::__field3),
                        "SecurityError" => _serde::__private::Ok(__Field::__field4),
                        "FormationViolation" => _serde::__private::Ok(__Field::__field5),
                        "PropertyConstraintViolation" => _serde::__private::Ok(__Field::__field6),
                        "OccurenceConstraintViolation" => _serde::__private::Ok(__Field::__field7),
                        "TypeConstraintViolation" => _serde::__private::Ok(__Field::__field8),
                        "GenericError" => _serde::__private::Ok(__Field::__field9),
                        _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"NotImplemented" => _serde::__private::Ok(__Field::__field0),
                        b"NotSupported" => _serde::__private::Ok(__Field::__field1),
                        b"InternalError" => _serde::__private::Ok(__Field::__field2),
                        b"ProtocolError" => _serde::__private::Ok(__Field::__field3),
                        b"SecurityError" => _serde::__private::Ok(__Field::__field4),
                        b"FormationViolation" => _serde::__private::Ok(__Field::__field5),
                        b"PropertyConstraintViolation" => _serde::__private::Ok(__Field::__field6),
                        b"OccurenceConstraintViolation" => _serde::__private::Ok(__Field::__field7),
                        b"TypeConstraintViolation" => _serde::__private::Ok(__Field::__field8),
                        b"GenericError" => _serde::__private::Ok(__Field::__field9),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<OCPPCallErrorCode>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = OCPPCallErrorCode;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum OCPPCallErrorCode")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::NotImplemented)
                        }
                        (__Field::__field1, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::NotSupported)
                        }
                        (__Field::__field2, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::InternalError)
                        }
                        (__Field::__field3, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::ProtocolError)
                        }
                        (__Field::__field4, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::SecurityError)
                        }
                        (__Field::__field5, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::FormationViolation)
                        }
                        (__Field::__field6, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::PropertyConstraintViolation)
                        }
                        (__Field::__field7, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::OccurenceConstraintViolation)
                        }
                        (__Field::__field8, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::TypeConstraintViolation)
                        }
                        (__Field::__field9, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(OCPPCallErrorCode::GenericError)
                        }
                    }
                }
            }
            const VARIANTS: &'static [&'static str] = &[
                "NotImplemented",
                "NotSupported",
                "InternalError",
                "ProtocolError",
                "SecurityError",
                "FormationViolation",
                "PropertyConstraintViolation",
                "OccurenceConstraintViolation",
                "TypeConstraintViolation",
                "GenericError",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "OCPPCallErrorCode",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<OCPPCallErrorCode>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::fmt::Debug for OCPPCallErrorCode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&OCPPCallErrorCode::NotImplemented,) => {
                ::core::fmt::Formatter::write_str(f, "NotImplemented")
            }
            (&OCPPCallErrorCode::NotSupported,) => {
                ::core::fmt::Formatter::write_str(f, "NotSupported")
            }
            (&OCPPCallErrorCode::InternalError,) => {
                ::core::fmt::Formatter::write_str(f, "InternalError")
            }
            (&OCPPCallErrorCode::ProtocolError,) => {
                ::core::fmt::Formatter::write_str(f, "ProtocolError")
            }
            (&OCPPCallErrorCode::SecurityError,) => {
                ::core::fmt::Formatter::write_str(f, "SecurityError")
            }
            (&OCPPCallErrorCode::FormationViolation,) => {
                ::core::fmt::Formatter::write_str(f, "FormationViolation")
            }
            (&OCPPCallErrorCode::PropertyConstraintViolation,) => {
                ::core::fmt::Formatter::write_str(f, "PropertyConstraintViolation")
            }
            (&OCPPCallErrorCode::OccurenceConstraintViolation,) => {
                ::core::fmt::Formatter::write_str(f, "OccurenceConstraintViolation")
            }
            (&OCPPCallErrorCode::TypeConstraintViolation,) => {
                ::core::fmt::Formatter::write_str(f, "TypeConstraintViolation")
            }
            (&OCPPCallErrorCode::GenericError,) => {
                ::core::fmt::Formatter::write_str(f, "GenericError")
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::clone::Clone for OCPPCallErrorCode {
    #[inline]
    fn clone(&self) -> OCPPCallErrorCode {
        match (&*self,) {
            (&OCPPCallErrorCode::NotImplemented,) => OCPPCallErrorCode::NotImplemented,
            (&OCPPCallErrorCode::NotSupported,) => OCPPCallErrorCode::NotSupported,
            (&OCPPCallErrorCode::InternalError,) => OCPPCallErrorCode::InternalError,
            (&OCPPCallErrorCode::ProtocolError,) => OCPPCallErrorCode::ProtocolError,
            (&OCPPCallErrorCode::SecurityError,) => OCPPCallErrorCode::SecurityError,
            (&OCPPCallErrorCode::FormationViolation,) => OCPPCallErrorCode::FormationViolation,
            (&OCPPCallErrorCode::PropertyConstraintViolation,) => {
                OCPPCallErrorCode::PropertyConstraintViolation
            }
            (&OCPPCallErrorCode::OccurenceConstraintViolation,) => {
                OCPPCallErrorCode::OccurenceConstraintViolation
            }
            (&OCPPCallErrorCode::TypeConstraintViolation,) => {
                OCPPCallErrorCode::TypeConstraintViolation
            }
            (&OCPPCallErrorCode::GenericError,) => OCPPCallErrorCode::GenericError,
        }
    }
}
#[allow(unused_qualifications)]
impl std::error::Error for OCPPCallErrorCode {}
impl std::fmt::Display for OCPPCallErrorCode {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        {
            let result = f.write_fmt(::core::fmt::Arguments::new_v1(
                &[""],
                &[::core::fmt::ArgumentV1::new_debug(&self)],
            ));
            result
        }
    }
}
/// OCPP Call Types
#[non_exhaustive]
#[allow(missing_docs)]
#[serde(untagged)]
pub enum OCPPCallPayload {
    Authorize(AuthorizeRequest),
    BootNotification(BootNotificationRequest),
    ChangeAvailability(ChangeAvailabilityRequest),
    ChangeConfiguration(ChangeConfigurationRequest),
    ClearCache(ClearCacheRequest),
    ClearChargingProfile(ClearChargingProfileRequest),
    DataTransfer(DataTransferRequest),
    DiagnosticsStatusNotification(DiagnosticsStatusNotificationRequest),
    FirmwareStatusNotification(FirmwareStatusNotificationRequest),
    GetCompositeSchedule(GetCompositeScheduleRequest),
    GetConfiguration(GetConfigurationRequest),
    GetDiagnostics(GetDiagnosticsRequest),
    GetLocalListVersion(GetLocalListVersionRequest),
    Heartbeat(HeartbeatRequest),
    MeterValues(MeterValuesRequest),
    RemoteStartTransaction(RemoteStartTransactionRequest),
    RemoteStopTransaction(RemoteStopTransactionRequest),
    Reset(ResetRequest),
    SendLocalList(SendLocalListRequest),
    SetChargingProfile(SetChargingProfileRequest),
    StartTransaction(StartTransactionRequest),
    StatusNotification(StatusNotificationRequest),
    StopTransaction(StopTransactionRequest),
    TriggerMessage(TriggerMessageRequest),
    UnlockConnector(UnlockConnectorRequest),
    UpdateFirmware(UpdateFirmwareRequest),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for OCPPCallPayload {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                OCPPCallPayload::Authorize(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::BootNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::ChangeAvailability(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::ChangeConfiguration(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::ClearCache(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::ClearChargingProfile(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::DataTransfer(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::DiagnosticsStatusNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::FirmwareStatusNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::GetCompositeSchedule(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::GetConfiguration(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::GetDiagnostics(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::GetLocalListVersion(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::Heartbeat(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::MeterValues(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::RemoteStartTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::RemoteStopTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::Reset(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::SendLocalList(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::SetChargingProfile(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::StartTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::StatusNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::StopTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::TriggerMessage(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::UnlockConnector(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallPayload::UpdateFirmware(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for OCPPCallPayload {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            let __content =
                match <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                    __deserializer,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <AuthorizeRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::Authorize,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <BootNotificationRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::BootNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ChangeAvailabilityRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::ChangeAvailability,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ChangeConfigurationRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::ChangeConfiguration,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ClearCacheRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::ClearCache,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ClearChargingProfileRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::ClearChargingProfile,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <DataTransferRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::DataTransfer,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <DiagnosticsStatusNotificationRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::DiagnosticsStatusNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <FirmwareStatusNotificationRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::FirmwareStatusNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetCompositeScheduleRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::GetCompositeSchedule,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetConfigurationRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::GetConfiguration,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetDiagnosticsRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::GetDiagnostics,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetLocalListVersionRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::GetLocalListVersion,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <HeartbeatRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::Heartbeat,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <MeterValuesRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::MeterValues,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <RemoteStartTransactionRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::RemoteStartTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <RemoteStopTransactionRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::RemoteStopTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ResetRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::Reset,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <SendLocalListRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::SendLocalList,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <SetChargingProfileRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::SetChargingProfile,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <StartTransactionRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::StartTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <StatusNotificationRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::StatusNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <StopTransactionRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::StopTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <TriggerMessageRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::TriggerMessage,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <UnlockConnectorRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::UnlockConnector,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <UpdateFirmwareRequest as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallPayload::UpdateFirmware,
            ) {
                return _serde::__private::Ok(__ok);
            }
            _serde::__private::Err(_serde::de::Error::custom(
                "data did not match any variant of untagged enum OCPPCallPayload",
            ))
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::fmt::Debug for OCPPCallPayload {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&OCPPCallPayload::Authorize(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Authorize", &&*__self_0)
            }
            (&OCPPCallPayload::BootNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "BootNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::ChangeAvailability(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ChangeAvailability",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::ChangeConfiguration(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ChangeConfiguration",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::ClearCache(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ClearCache", &&*__self_0)
            }
            (&OCPPCallPayload::ClearChargingProfile(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ClearChargingProfile",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::DataTransfer(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "DataTransfer", &&*__self_0)
            }
            (&OCPPCallPayload::DiagnosticsStatusNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DiagnosticsStatusNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::FirmwareStatusNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "FirmwareStatusNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::GetCompositeSchedule(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetCompositeSchedule",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::GetConfiguration(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetConfiguration",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::GetDiagnostics(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "GetDiagnostics", &&*__self_0)
            }
            (&OCPPCallPayload::GetLocalListVersion(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetLocalListVersion",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::Heartbeat(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Heartbeat", &&*__self_0)
            }
            (&OCPPCallPayload::MeterValues(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "MeterValues", &&*__self_0)
            }
            (&OCPPCallPayload::RemoteStartTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "RemoteStartTransaction",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::RemoteStopTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "RemoteStopTransaction",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::Reset(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Reset", &&*__self_0)
            }
            (&OCPPCallPayload::SendLocalList(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "SendLocalList", &&*__self_0)
            }
            (&OCPPCallPayload::SetChargingProfile(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "SetChargingProfile",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::StartTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "StartTransaction",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::StatusNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "StatusNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallPayload::StopTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "StopTransaction", &&*__self_0)
            }
            (&OCPPCallPayload::TriggerMessage(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TriggerMessage", &&*__self_0)
            }
            (&OCPPCallPayload::UnlockConnector(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "UnlockConnector", &&*__self_0)
            }
            (&OCPPCallPayload::UpdateFirmware(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "UpdateFirmware", &&*__self_0)
            }
        }
    }
}
impl ::core::fmt::Display for OCPPCallPayload {
    fn fmt(
        &self,
        f: &mut ::core::fmt::Formatter,
    ) -> ::core::result::Result<(), ::core::fmt::Error> {
        match *self {
            OCPPCallPayload::Authorize(..) => f.pad("Authorize"),
            OCPPCallPayload::BootNotification(..) => f.pad("BootNotification"),
            OCPPCallPayload::ChangeAvailability(..) => f.pad("ChangeAvailability"),
            OCPPCallPayload::ChangeConfiguration(..) => f.pad("ChangeConfiguration"),
            OCPPCallPayload::ClearCache(..) => f.pad("ClearCache"),
            OCPPCallPayload::ClearChargingProfile(..) => f.pad("ClearChargingProfile"),
            OCPPCallPayload::DataTransfer(..) => f.pad("DataTransfer"),
            OCPPCallPayload::DiagnosticsStatusNotification(..) => {
                f.pad("DiagnosticsStatusNotification")
            }
            OCPPCallPayload::FirmwareStatusNotification(..) => f.pad("FirmwareStatusNotification"),
            OCPPCallPayload::GetCompositeSchedule(..) => f.pad("GetCompositeSchedule"),
            OCPPCallPayload::GetConfiguration(..) => f.pad("GetConfiguration"),
            OCPPCallPayload::GetDiagnostics(..) => f.pad("GetDiagnostics"),
            OCPPCallPayload::GetLocalListVersion(..) => f.pad("GetLocalListVersion"),
            OCPPCallPayload::Heartbeat(..) => f.pad("Heartbeat"),
            OCPPCallPayload::MeterValues(..) => f.pad("MeterValues"),
            OCPPCallPayload::RemoteStartTransaction(..) => f.pad("RemoteStartTransaction"),
            OCPPCallPayload::RemoteStopTransaction(..) => f.pad("RemoteStopTransaction"),
            OCPPCallPayload::Reset(..) => f.pad("Reset"),
            OCPPCallPayload::SendLocalList(..) => f.pad("SendLocalList"),
            OCPPCallPayload::SetChargingProfile(..) => f.pad("SetChargingProfile"),
            OCPPCallPayload::StartTransaction(..) => f.pad("StartTransaction"),
            OCPPCallPayload::StatusNotification(..) => f.pad("StatusNotification"),
            OCPPCallPayload::StopTransaction(..) => f.pad("StopTransaction"),
            OCPPCallPayload::TriggerMessage(..) => f.pad("TriggerMessage"),
            OCPPCallPayload::UnlockConnector(..) => f.pad("UnlockConnector"),
            OCPPCallPayload::UpdateFirmware(..) => f.pad("UpdateFirmware"),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::clone::Clone for OCPPCallPayload {
    #[inline]
    fn clone(&self) -> OCPPCallPayload {
        match (&*self,) {
            (&OCPPCallPayload::Authorize(ref __self_0),) => {
                OCPPCallPayload::Authorize(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::BootNotification(ref __self_0),) => {
                OCPPCallPayload::BootNotification(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::ChangeAvailability(ref __self_0),) => {
                OCPPCallPayload::ChangeAvailability(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::ChangeConfiguration(ref __self_0),) => {
                OCPPCallPayload::ChangeConfiguration(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::ClearCache(ref __self_0),) => {
                OCPPCallPayload::ClearCache(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::ClearChargingProfile(ref __self_0),) => {
                OCPPCallPayload::ClearChargingProfile(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::DataTransfer(ref __self_0),) => {
                OCPPCallPayload::DataTransfer(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::DiagnosticsStatusNotification(ref __self_0),) => {
                OCPPCallPayload::DiagnosticsStatusNotification(::core::clone::Clone::clone(
                    &*__self_0,
                ))
            }
            (&OCPPCallPayload::FirmwareStatusNotification(ref __self_0),) => {
                OCPPCallPayload::FirmwareStatusNotification(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::GetCompositeSchedule(ref __self_0),) => {
                OCPPCallPayload::GetCompositeSchedule(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::GetConfiguration(ref __self_0),) => {
                OCPPCallPayload::GetConfiguration(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::GetDiagnostics(ref __self_0),) => {
                OCPPCallPayload::GetDiagnostics(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::GetLocalListVersion(ref __self_0),) => {
                OCPPCallPayload::GetLocalListVersion(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::Heartbeat(ref __self_0),) => {
                OCPPCallPayload::Heartbeat(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::MeterValues(ref __self_0),) => {
                OCPPCallPayload::MeterValues(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::RemoteStartTransaction(ref __self_0),) => {
                OCPPCallPayload::RemoteStartTransaction(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::RemoteStopTransaction(ref __self_0),) => {
                OCPPCallPayload::RemoteStopTransaction(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::Reset(ref __self_0),) => {
                OCPPCallPayload::Reset(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::SendLocalList(ref __self_0),) => {
                OCPPCallPayload::SendLocalList(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::SetChargingProfile(ref __self_0),) => {
                OCPPCallPayload::SetChargingProfile(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::StartTransaction(ref __self_0),) => {
                OCPPCallPayload::StartTransaction(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::StatusNotification(ref __self_0),) => {
                OCPPCallPayload::StatusNotification(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::StopTransaction(ref __self_0),) => {
                OCPPCallPayload::StopTransaction(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::TriggerMessage(ref __self_0),) => {
                OCPPCallPayload::TriggerMessage(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::UnlockConnector(ref __self_0),) => {
                OCPPCallPayload::UnlockConnector(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallPayload::UpdateFirmware(ref __self_0),) => {
                OCPPCallPayload::UpdateFirmware(::core::clone::Clone::clone(&*__self_0))
            }
        }
    }
}
impl OCPPCallPayload {
    /// Get an OCPPResult from the type of its original call.
    pub fn get_result_from_call(
        &self,
        result: OCPPCallResultUnknown,
    ) -> Result<OCPPCallResultPayload, serde_json::error::Error> {
        use OCPPCallPayload::*;
        let output = match self {
            Authorize(_) => OCPPCallResult::from_unknown(&OCPPCallAction::Authorize, result)?,
            BootNotification(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::BootNotification, result)?
            }
            ChangeAvailability(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::ChangeAvailability, result)?
            }
            ChangeConfiguration(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::ChangeConfiguration, result)?
            }
            ClearCache(_) => OCPPCallResult::from_unknown(&OCPPCallAction::ClearCache, result)?,
            ClearChargingProfile(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::ClearChargingProfile, result)?
            }
            DataTransfer(_) => OCPPCallResult::from_unknown(&OCPPCallAction::DataTransfer, result)?,
            DiagnosticsStatusNotification(_) => OCPPCallResult::from_unknown(
                &OCPPCallAction::DiagnosticsStatusNotification,
                result,
            )?,
            FirmwareStatusNotification(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::FirmwareStatusNotification, result)?
            }
            GetCompositeSchedule(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::GetCompositeSchedule, result)?
            }
            GetConfiguration(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::GetConfiguration, result)?
            }
            GetDiagnostics(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::GetDiagnostics, result)?
            }
            GetLocalListVersion(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::GetLocalListVersion, result)?
            }
            Heartbeat(_) => OCPPCallResult::from_unknown(&OCPPCallAction::Heartbeat, result)?,
            MeterValues(_) => OCPPCallResult::from_unknown(&OCPPCallAction::MeterValues, result)?,
            RemoteStartTransaction(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::RemoteStartTransaction, result)?
            }
            RemoteStopTransaction(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::RemoteStopTransaction, result)?
            }
            Reset(_) => OCPPCallResult::from_unknown(&OCPPCallAction::Reset, result)?,
            SendLocalList(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::SendLocalList, result)?
            }
            SetChargingProfile(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::SetChargingProfile, result)?
            }
            StartTransaction(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::StartTransaction, result)?
            }
            StatusNotification(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::StatusNotification, result)?
            }
            StopTransaction(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::StopTransaction, result)?
            }
            TriggerMessage(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::TriggerMessage, result)?
            }
            UnlockConnector(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::UnlockConnector, result)?
            }
            UpdateFirmware(_) => {
                OCPPCallResult::from_unknown(&OCPPCallAction::UpdateFirmware, result)?
            }
        };
        return Ok(output.payload);
    }
}
impl validation_macros::JsonValidate for OCPPCallPayload {
    fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
        match self {
            OCPPCallPayload::Authorize(req) => req.schema_validate(),
            OCPPCallPayload::BootNotification(req) => req.schema_validate(),
            OCPPCallPayload::ChangeAvailability(req) => req.schema_validate(),
            OCPPCallPayload::ChangeConfiguration(req) => req.schema_validate(),
            OCPPCallPayload::ClearCache(req) => req.schema_validate(),
            OCPPCallPayload::ClearChargingProfile(req) => req.schema_validate(),
            OCPPCallPayload::DataTransfer(req) => req.schema_validate(),
            OCPPCallPayload::DiagnosticsStatusNotification(req) => req.schema_validate(),
            OCPPCallPayload::FirmwareStatusNotification(req) => req.schema_validate(),
            OCPPCallPayload::GetCompositeSchedule(req) => req.schema_validate(),
            OCPPCallPayload::GetConfiguration(req) => req.schema_validate(),
            OCPPCallPayload::GetDiagnostics(req) => req.schema_validate(),
            OCPPCallPayload::GetLocalListVersion(req) => req.schema_validate(),
            OCPPCallPayload::Heartbeat(req) => req.schema_validate(),
            OCPPCallPayload::MeterValues(req) => req.schema_validate(),
            OCPPCallPayload::RemoteStartTransaction(req) => req.schema_validate(),
            OCPPCallPayload::RemoteStopTransaction(req) => req.schema_validate(),
            OCPPCallPayload::Reset(req) => req.schema_validate(),
            OCPPCallPayload::SendLocalList(req) => req.schema_validate(),
            OCPPCallPayload::SetChargingProfile(req) => req.schema_validate(),
            OCPPCallPayload::StartTransaction(req) => req.schema_validate(),
            OCPPCallPayload::StatusNotification(req) => req.schema_validate(),
            OCPPCallPayload::StopTransaction(req) => req.schema_validate(),
            OCPPCallPayload::TriggerMessage(req) => req.schema_validate(),
            OCPPCallPayload::UnlockConnector(req) => req.schema_validate(),
            OCPPCallPayload::UpdateFirmware(req) => req.schema_validate(),
        }
    }
}
/// OCPP Call Result Types
#[non_exhaustive]
#[allow(missing_docs)]
#[serde(untagged)]
pub enum OCPPCallResultPayload {
    Authorize(AuthorizeResponse),
    BootNotification(BootNotificationResponse),
    ChangeAvailability(ChangeAvailabilityResponse),
    ChangeConfiguration(ChangeConfigurationResponse),
    ClearCache(ClearCacheResponse),
    ClearChargingProfile(ClearChargingProfileResponse),
    DataTransfer(DataTransferResponse),
    DiagnosticsStatusNotification(DiagnosticsStatusNotificationResponse),
    FirmwareStatusNotification(FirmwareStatusNotificationResponse),
    GetCompositeSchedule(GetCompositeScheduleResponse),
    GetConfiguration(GetConfigurationResponse),
    GetDiagnostics(GetDiagnosticsResponse),
    GetLocalListVersion(GetLocalListVersionResponse),
    Heartbeat(HeartbeatResponse),
    MeterValues(MeterValuesResponse),
    RemoteStartTransaction(RemoteStartTransactionResponse),
    RemoteStopTransaction(RemoteStopTransactionResponse),
    Reset(ResetResponse),
    SendLocalList(SendLocalListResponse),
    SetChargingProfile(SetChargingProfileResponse),
    StartTransaction(StartTransactionResponse),
    StatusNotification(StatusNotificationResponse),
    StopTransaction(StopTransactionResponse),
    TriggerMessage(TriggerMessageResponse),
    UnlockConnector(UnlockConnectorResponse),
    UpdateFirmware(UpdateFirmwareResponse),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for OCPPCallResultPayload {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                OCPPCallResultPayload::Authorize(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::BootNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::ChangeAvailability(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::ChangeConfiguration(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::ClearCache(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::ClearChargingProfile(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::DataTransfer(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::DiagnosticsStatusNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::FirmwareStatusNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::GetCompositeSchedule(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::GetConfiguration(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::GetDiagnostics(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::GetLocalListVersion(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::Heartbeat(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::MeterValues(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::RemoteStartTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::RemoteStopTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::Reset(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::SendLocalList(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::SetChargingProfile(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::StartTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::StatusNotification(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::StopTransaction(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::TriggerMessage(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::UnlockConnector(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
                OCPPCallResultPayload::UpdateFirmware(ref __field0) => {
                    _serde::Serialize::serialize(__field0, __serializer)
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for OCPPCallResultPayload {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            let __content =
                match <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                    __deserializer,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <AuthorizeResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::Authorize,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <BootNotificationResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::BootNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ChangeAvailabilityResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::ChangeAvailability,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ChangeConfigurationResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::ChangeConfiguration,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ClearCacheResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::ClearCache,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ClearChargingProfileResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::ClearChargingProfile,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <DataTransferResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::DataTransfer,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <DiagnosticsStatusNotificationResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::DiagnosticsStatusNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <FirmwareStatusNotificationResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::FirmwareStatusNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetCompositeScheduleResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::GetCompositeSchedule,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetConfigurationResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::GetConfiguration,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetDiagnosticsResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::GetDiagnostics,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <GetLocalListVersionResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::GetLocalListVersion,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <HeartbeatResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::Heartbeat,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <MeterValuesResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::MeterValues,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <RemoteStartTransactionResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::RemoteStartTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <RemoteStopTransactionResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::RemoteStopTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <ResetResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::Reset,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <SendLocalListResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::SendLocalList,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <SetChargingProfileResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::SetChargingProfile,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <StartTransactionResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::StartTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <StatusNotificationResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::StatusNotification,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <StopTransactionResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::StopTransaction,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <TriggerMessageResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::TriggerMessage,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <UnlockConnectorResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::UnlockConnector,
            ) {
                return _serde::__private::Ok(__ok);
            }
            if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                <UpdateFirmwareResponse as _serde::Deserialize>::deserialize(
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                ),
                OCPPCallResultPayload::UpdateFirmware,
            ) {
                return _serde::__private::Ok(__ok);
            }
            _serde::__private::Err(_serde::de::Error::custom(
                "data did not match any variant of untagged enum OCPPCallResultPayload",
            ))
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::fmt::Debug for OCPPCallResultPayload {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&OCPPCallResultPayload::Authorize(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Authorize", &&*__self_0)
            }
            (&OCPPCallResultPayload::BootNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "BootNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::ChangeAvailability(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ChangeAvailability",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::ChangeConfiguration(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ChangeConfiguration",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::ClearCache(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ClearCache", &&*__self_0)
            }
            (&OCPPCallResultPayload::ClearChargingProfile(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ClearChargingProfile",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::DataTransfer(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "DataTransfer", &&*__self_0)
            }
            (&OCPPCallResultPayload::DiagnosticsStatusNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DiagnosticsStatusNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::FirmwareStatusNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "FirmwareStatusNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::GetCompositeSchedule(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetCompositeSchedule",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::GetConfiguration(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetConfiguration",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::GetDiagnostics(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "GetDiagnostics", &&*__self_0)
            }
            (&OCPPCallResultPayload::GetLocalListVersion(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetLocalListVersion",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::Heartbeat(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Heartbeat", &&*__self_0)
            }
            (&OCPPCallResultPayload::MeterValues(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "MeterValues", &&*__self_0)
            }
            (&OCPPCallResultPayload::RemoteStartTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "RemoteStartTransaction",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::RemoteStopTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "RemoteStopTransaction",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::Reset(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Reset", &&*__self_0)
            }
            (&OCPPCallResultPayload::SendLocalList(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "SendLocalList", &&*__self_0)
            }
            (&OCPPCallResultPayload::SetChargingProfile(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "SetChargingProfile",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::StartTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "StartTransaction",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::StatusNotification(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "StatusNotification",
                    &&*__self_0,
                )
            }
            (&OCPPCallResultPayload::StopTransaction(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "StopTransaction", &&*__self_0)
            }
            (&OCPPCallResultPayload::TriggerMessage(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TriggerMessage", &&*__self_0)
            }
            (&OCPPCallResultPayload::UnlockConnector(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "UnlockConnector", &&*__self_0)
            }
            (&OCPPCallResultPayload::UpdateFirmware(ref __self_0),) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "UpdateFirmware", &&*__self_0)
            }
        }
    }
}
impl ::core::fmt::Display for OCPPCallResultPayload {
    fn fmt(
        &self,
        f: &mut ::core::fmt::Formatter,
    ) -> ::core::result::Result<(), ::core::fmt::Error> {
        match *self {
            OCPPCallResultPayload::Authorize(..) => f.pad("Authorize"),
            OCPPCallResultPayload::BootNotification(..) => f.pad("BootNotification"),
            OCPPCallResultPayload::ChangeAvailability(..) => f.pad("ChangeAvailability"),
            OCPPCallResultPayload::ChangeConfiguration(..) => f.pad("ChangeConfiguration"),
            OCPPCallResultPayload::ClearCache(..) => f.pad("ClearCache"),
            OCPPCallResultPayload::ClearChargingProfile(..) => f.pad("ClearChargingProfile"),
            OCPPCallResultPayload::DataTransfer(..) => f.pad("DataTransfer"),
            OCPPCallResultPayload::DiagnosticsStatusNotification(..) => {
                f.pad("DiagnosticsStatusNotification")
            }
            OCPPCallResultPayload::FirmwareStatusNotification(..) => {
                f.pad("FirmwareStatusNotification")
            }
            OCPPCallResultPayload::GetCompositeSchedule(..) => f.pad("GetCompositeSchedule"),
            OCPPCallResultPayload::GetConfiguration(..) => f.pad("GetConfiguration"),
            OCPPCallResultPayload::GetDiagnostics(..) => f.pad("GetDiagnostics"),
            OCPPCallResultPayload::GetLocalListVersion(..) => f.pad("GetLocalListVersion"),
            OCPPCallResultPayload::Heartbeat(..) => f.pad("Heartbeat"),
            OCPPCallResultPayload::MeterValues(..) => f.pad("MeterValues"),
            OCPPCallResultPayload::RemoteStartTransaction(..) => f.pad("RemoteStartTransaction"),
            OCPPCallResultPayload::RemoteStopTransaction(..) => f.pad("RemoteStopTransaction"),
            OCPPCallResultPayload::Reset(..) => f.pad("Reset"),
            OCPPCallResultPayload::SendLocalList(..) => f.pad("SendLocalList"),
            OCPPCallResultPayload::SetChargingProfile(..) => f.pad("SetChargingProfile"),
            OCPPCallResultPayload::StartTransaction(..) => f.pad("StartTransaction"),
            OCPPCallResultPayload::StatusNotification(..) => f.pad("StatusNotification"),
            OCPPCallResultPayload::StopTransaction(..) => f.pad("StopTransaction"),
            OCPPCallResultPayload::TriggerMessage(..) => f.pad("TriggerMessage"),
            OCPPCallResultPayload::UnlockConnector(..) => f.pad("UnlockConnector"),
            OCPPCallResultPayload::UpdateFirmware(..) => f.pad("UpdateFirmware"),
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::clone::Clone for OCPPCallResultPayload {
    #[inline]
    fn clone(&self) -> OCPPCallResultPayload {
        match (&*self,) {
            (&OCPPCallResultPayload::Authorize(ref __self_0),) => {
                OCPPCallResultPayload::Authorize(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::BootNotification(ref __self_0),) => {
                OCPPCallResultPayload::BootNotification(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::ChangeAvailability(ref __self_0),) => {
                OCPPCallResultPayload::ChangeAvailability(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::ChangeConfiguration(ref __self_0),) => {
                OCPPCallResultPayload::ChangeConfiguration(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::ClearCache(ref __self_0),) => {
                OCPPCallResultPayload::ClearCache(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::ClearChargingProfile(ref __self_0),) => {
                OCPPCallResultPayload::ClearChargingProfile(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::DataTransfer(ref __self_0),) => {
                OCPPCallResultPayload::DataTransfer(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::DiagnosticsStatusNotification(ref __self_0),) => {
                OCPPCallResultPayload::DiagnosticsStatusNotification(::core::clone::Clone::clone(
                    &*__self_0,
                ))
            }
            (&OCPPCallResultPayload::FirmwareStatusNotification(ref __self_0),) => {
                OCPPCallResultPayload::FirmwareStatusNotification(::core::clone::Clone::clone(
                    &*__self_0,
                ))
            }
            (&OCPPCallResultPayload::GetCompositeSchedule(ref __self_0),) => {
                OCPPCallResultPayload::GetCompositeSchedule(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::GetConfiguration(ref __self_0),) => {
                OCPPCallResultPayload::GetConfiguration(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::GetDiagnostics(ref __self_0),) => {
                OCPPCallResultPayload::GetDiagnostics(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::GetLocalListVersion(ref __self_0),) => {
                OCPPCallResultPayload::GetLocalListVersion(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::Heartbeat(ref __self_0),) => {
                OCPPCallResultPayload::Heartbeat(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::MeterValues(ref __self_0),) => {
                OCPPCallResultPayload::MeterValues(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::RemoteStartTransaction(ref __self_0),) => {
                OCPPCallResultPayload::RemoteStartTransaction(::core::clone::Clone::clone(
                    &*__self_0,
                ))
            }
            (&OCPPCallResultPayload::RemoteStopTransaction(ref __self_0),) => {
                OCPPCallResultPayload::RemoteStopTransaction(::core::clone::Clone::clone(
                    &*__self_0,
                ))
            }
            (&OCPPCallResultPayload::Reset(ref __self_0),) => {
                OCPPCallResultPayload::Reset(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::SendLocalList(ref __self_0),) => {
                OCPPCallResultPayload::SendLocalList(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::SetChargingProfile(ref __self_0),) => {
                OCPPCallResultPayload::SetChargingProfile(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::StartTransaction(ref __self_0),) => {
                OCPPCallResultPayload::StartTransaction(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::StatusNotification(ref __self_0),) => {
                OCPPCallResultPayload::StatusNotification(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::StopTransaction(ref __self_0),) => {
                OCPPCallResultPayload::StopTransaction(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::TriggerMessage(ref __self_0),) => {
                OCPPCallResultPayload::TriggerMessage(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::UnlockConnector(ref __self_0),) => {
                OCPPCallResultPayload::UnlockConnector(::core::clone::Clone::clone(&*__self_0))
            }
            (&OCPPCallResultPayload::UpdateFirmware(ref __self_0),) => {
                OCPPCallResultPayload::UpdateFirmware(::core::clone::Clone::clone(&*__self_0))
            }
        }
    }
}
impl validation_macros::JsonValidate for OCPPCallResultPayload {
    fn schema_validate(&self) -> Result<(), validation_macros::JsonValidateError> {
        match self {
            OCPPCallResultPayload::Authorize(r) => r.schema_validate(),
            OCPPCallResultPayload::BootNotification(r) => r.schema_validate(),
            OCPPCallResultPayload::ChangeAvailability(r) => r.schema_validate(),
            OCPPCallResultPayload::ChangeConfiguration(r) => r.schema_validate(),
            OCPPCallResultPayload::ClearCache(r) => r.schema_validate(),
            OCPPCallResultPayload::ClearChargingProfile(r) => r.schema_validate(),
            OCPPCallResultPayload::DataTransfer(r) => r.schema_validate(),
            OCPPCallResultPayload::DiagnosticsStatusNotification(r) => r.schema_validate(),
            OCPPCallResultPayload::FirmwareStatusNotification(r) => r.schema_validate(),
            OCPPCallResultPayload::GetCompositeSchedule(r) => r.schema_validate(),
            OCPPCallResultPayload::GetConfiguration(r) => r.schema_validate(),
            OCPPCallResultPayload::GetDiagnostics(r) => r.schema_validate(),
            OCPPCallResultPayload::GetLocalListVersion(r) => r.schema_validate(),
            OCPPCallResultPayload::Heartbeat(r) => r.schema_validate(),
            OCPPCallResultPayload::MeterValues(r) => r.schema_validate(),
            OCPPCallResultPayload::RemoteStartTransaction(r) => r.schema_validate(),
            OCPPCallResultPayload::RemoteStopTransaction(r) => r.schema_validate(),
            OCPPCallResultPayload::Reset(r) => r.schema_validate(),
            OCPPCallResultPayload::SendLocalList(r) => r.schema_validate(),
            OCPPCallResultPayload::SetChargingProfile(r) => r.schema_validate(),
            OCPPCallResultPayload::StartTransaction(r) => r.schema_validate(),
            OCPPCallResultPayload::StatusNotification(r) => r.schema_validate(),
            OCPPCallResultPayload::StopTransaction(r) => r.schema_validate(),
            OCPPCallResultPayload::TriggerMessage(r) => r.schema_validate(),
            OCPPCallResultPayload::UnlockConnector(r) => r.schema_validate(),
            OCPPCallResultPayload::UpdateFirmware(r) => r.schema_validate(),
        }
    }
}
/// OCPP Call Types
#[non_exhaustive]
#[allow(missing_docs)]
pub enum OCPPCallAction {
    Authorize,
    BootNotification,
    ChangeAvailability,
    ChangeConfiguration,
    ClearCache,
    ClearChargingProfile,
    DataTransfer,
    DiagnosticsStatusNotification,
    FirmwareStatusNotification,
    GetCompositeSchedule,
    GetConfiguration,
    GetDiagnostics,
    GetLocalListVersion,
    Heartbeat,
    MeterValues,
    RemoteStartTransaction,
    RemoteStopTransaction,
    Reset,
    SendLocalList,
    SetChargingProfile,
    StartTransaction,
    StatusNotification,
    StopTransaction,
    TriggerMessage,
    UnlockConnector,
    UpdateFirmware,
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::fmt::Debug for OCPPCallAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&OCPPCallAction::Authorize,) => ::core::fmt::Formatter::write_str(f, "Authorize"),
            (&OCPPCallAction::BootNotification,) => {
                ::core::fmt::Formatter::write_str(f, "BootNotification")
            }
            (&OCPPCallAction::ChangeAvailability,) => {
                ::core::fmt::Formatter::write_str(f, "ChangeAvailability")
            }
            (&OCPPCallAction::ChangeConfiguration,) => {
                ::core::fmt::Formatter::write_str(f, "ChangeConfiguration")
            }
            (&OCPPCallAction::ClearCache,) => ::core::fmt::Formatter::write_str(f, "ClearCache"),
            (&OCPPCallAction::ClearChargingProfile,) => {
                ::core::fmt::Formatter::write_str(f, "ClearChargingProfile")
            }
            (&OCPPCallAction::DataTransfer,) => {
                ::core::fmt::Formatter::write_str(f, "DataTransfer")
            }
            (&OCPPCallAction::DiagnosticsStatusNotification,) => {
                ::core::fmt::Formatter::write_str(f, "DiagnosticsStatusNotification")
            }
            (&OCPPCallAction::FirmwareStatusNotification,) => {
                ::core::fmt::Formatter::write_str(f, "FirmwareStatusNotification")
            }
            (&OCPPCallAction::GetCompositeSchedule,) => {
                ::core::fmt::Formatter::write_str(f, "GetCompositeSchedule")
            }
            (&OCPPCallAction::GetConfiguration,) => {
                ::core::fmt::Formatter::write_str(f, "GetConfiguration")
            }
            (&OCPPCallAction::GetDiagnostics,) => {
                ::core::fmt::Formatter::write_str(f, "GetDiagnostics")
            }
            (&OCPPCallAction::GetLocalListVersion,) => {
                ::core::fmt::Formatter::write_str(f, "GetLocalListVersion")
            }
            (&OCPPCallAction::Heartbeat,) => ::core::fmt::Formatter::write_str(f, "Heartbeat"),
            (&OCPPCallAction::MeterValues,) => ::core::fmt::Formatter::write_str(f, "MeterValues"),
            (&OCPPCallAction::RemoteStartTransaction,) => {
                ::core::fmt::Formatter::write_str(f, "RemoteStartTransaction")
            }
            (&OCPPCallAction::RemoteStopTransaction,) => {
                ::core::fmt::Formatter::write_str(f, "RemoteStopTransaction")
            }
            (&OCPPCallAction::Reset,) => ::core::fmt::Formatter::write_str(f, "Reset"),
            (&OCPPCallAction::SendLocalList,) => {
                ::core::fmt::Formatter::write_str(f, "SendLocalList")
            }
            (&OCPPCallAction::SetChargingProfile,) => {
                ::core::fmt::Formatter::write_str(f, "SetChargingProfile")
            }
            (&OCPPCallAction::StartTransaction,) => {
                ::core::fmt::Formatter::write_str(f, "StartTransaction")
            }
            (&OCPPCallAction::StatusNotification,) => {
                ::core::fmt::Formatter::write_str(f, "StatusNotification")
            }
            (&OCPPCallAction::StopTransaction,) => {
                ::core::fmt::Formatter::write_str(f, "StopTransaction")
            }
            (&OCPPCallAction::TriggerMessage,) => {
                ::core::fmt::Formatter::write_str(f, "TriggerMessage")
            }
            (&OCPPCallAction::UnlockConnector,) => {
                ::core::fmt::Formatter::write_str(f, "UnlockConnector")
            }
            (&OCPPCallAction::UpdateFirmware,) => {
                ::core::fmt::Formatter::write_str(f, "UpdateFirmware")
            }
        }
    }
}
impl ::core::fmt::Display for OCPPCallAction {
    fn fmt(
        &self,
        f: &mut ::core::fmt::Formatter,
    ) -> ::core::result::Result<(), ::core::fmt::Error> {
        match *self {
            OCPPCallAction::Authorize => f.pad("Authorize"),
            OCPPCallAction::BootNotification => f.pad("BootNotification"),
            OCPPCallAction::ChangeAvailability => f.pad("ChangeAvailability"),
            OCPPCallAction::ChangeConfiguration => f.pad("ChangeConfiguration"),
            OCPPCallAction::ClearCache => f.pad("ClearCache"),
            OCPPCallAction::ClearChargingProfile => f.pad("ClearChargingProfile"),
            OCPPCallAction::DataTransfer => f.pad("DataTransfer"),
            OCPPCallAction::DiagnosticsStatusNotification => f.pad("DiagnosticsStatusNotification"),
            OCPPCallAction::FirmwareStatusNotification => f.pad("FirmwareStatusNotification"),
            OCPPCallAction::GetCompositeSchedule => f.pad("GetCompositeSchedule"),
            OCPPCallAction::GetConfiguration => f.pad("GetConfiguration"),
            OCPPCallAction::GetDiagnostics => f.pad("GetDiagnostics"),
            OCPPCallAction::GetLocalListVersion => f.pad("GetLocalListVersion"),
            OCPPCallAction::Heartbeat => f.pad("Heartbeat"),
            OCPPCallAction::MeterValues => f.pad("MeterValues"),
            OCPPCallAction::RemoteStartTransaction => f.pad("RemoteStartTransaction"),
            OCPPCallAction::RemoteStopTransaction => f.pad("RemoteStopTransaction"),
            OCPPCallAction::Reset => f.pad("Reset"),
            OCPPCallAction::SendLocalList => f.pad("SendLocalList"),
            OCPPCallAction::SetChargingProfile => f.pad("SetChargingProfile"),
            OCPPCallAction::StartTransaction => f.pad("StartTransaction"),
            OCPPCallAction::StatusNotification => f.pad("StatusNotification"),
            OCPPCallAction::StopTransaction => f.pad("StopTransaction"),
            OCPPCallAction::TriggerMessage => f.pad("TriggerMessage"),
            OCPPCallAction::UnlockConnector => f.pad("UnlockConnector"),
            OCPPCallAction::UpdateFirmware => f.pad("UpdateFirmware"),
        }
    }
}
#[allow(missing_docs)]
impl ::core::marker::StructuralPartialEq for OCPPCallAction {}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::cmp::PartialEq for OCPPCallAction {
    #[inline]
    fn eq(&self, other: &OCPPCallAction) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    _ => true,
                }
            } else {
                false
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
#[allow(missing_docs)]
impl ::core::clone::Clone for OCPPCallAction {
    #[inline]
    fn clone(&self) -> OCPPCallAction {
        match (&*self,) {
            (&OCPPCallAction::Authorize,) => OCPPCallAction::Authorize,
            (&OCPPCallAction::BootNotification,) => OCPPCallAction::BootNotification,
            (&OCPPCallAction::ChangeAvailability,) => OCPPCallAction::ChangeAvailability,
            (&OCPPCallAction::ChangeConfiguration,) => OCPPCallAction::ChangeConfiguration,
            (&OCPPCallAction::ClearCache,) => OCPPCallAction::ClearCache,
            (&OCPPCallAction::ClearChargingProfile,) => OCPPCallAction::ClearChargingProfile,
            (&OCPPCallAction::DataTransfer,) => OCPPCallAction::DataTransfer,
            (&OCPPCallAction::DiagnosticsStatusNotification,) => {
                OCPPCallAction::DiagnosticsStatusNotification
            }
            (&OCPPCallAction::FirmwareStatusNotification,) => {
                OCPPCallAction::FirmwareStatusNotification
            }
            (&OCPPCallAction::GetCompositeSchedule,) => OCPPCallAction::GetCompositeSchedule,
            (&OCPPCallAction::GetConfiguration,) => OCPPCallAction::GetConfiguration,
            (&OCPPCallAction::GetDiagnostics,) => OCPPCallAction::GetDiagnostics,
            (&OCPPCallAction::GetLocalListVersion,) => OCPPCallAction::GetLocalListVersion,
            (&OCPPCallAction::Heartbeat,) => OCPPCallAction::Heartbeat,
            (&OCPPCallAction::MeterValues,) => OCPPCallAction::MeterValues,
            (&OCPPCallAction::RemoteStartTransaction,) => OCPPCallAction::RemoteStartTransaction,
            (&OCPPCallAction::RemoteStopTransaction,) => OCPPCallAction::RemoteStopTransaction,
            (&OCPPCallAction::Reset,) => OCPPCallAction::Reset,
            (&OCPPCallAction::SendLocalList,) => OCPPCallAction::SendLocalList,
            (&OCPPCallAction::SetChargingProfile,) => OCPPCallAction::SetChargingProfile,
            (&OCPPCallAction::StartTransaction,) => OCPPCallAction::StartTransaction,
            (&OCPPCallAction::StatusNotification,) => OCPPCallAction::StatusNotification,
            (&OCPPCallAction::StopTransaction,) => OCPPCallAction::StopTransaction,
            (&OCPPCallAction::TriggerMessage,) => OCPPCallAction::TriggerMessage,
            (&OCPPCallAction::UnlockConnector,) => OCPPCallAction::UnlockConnector,
            (&OCPPCallAction::UpdateFirmware,) => OCPPCallAction::UpdateFirmware,
        }
    }
}
/// Predefined methods to respond to an OCPP request. Each call type has its
/// own method, and is expected to either return a valid response or an error
/// code. OCPPCallResultBuilder may be passed an OCPPCall via the [build](OCPPCallResultBuilder::build)
/// method, and will return either a corresponding OCPPCallResult or an error
/// code as returned by the handling function.
///
/// To define a response for a call type a Boxed closure may be passed in to
/// the builder. By default any undefined method will return [OCPPCallErrorCode::NotImplemented].
/// Building the [OCPPCallResult] will consume the [OCPPCall], this is used
/// to move the `unique_id` field.
///
/// The builder may be used any number of times without being consumed.
///
/// # Example
/// ```
/// # fn ocpp_message_example() -> Result<(), serde_json::Error> {
/// use ocpp::*;
///
/// // Implement OCPPCallResultBuilder
/// struct MyResultBuilder {}
/// impl OCPPCallResultBuilder for MyResultBuilder {
///     fn heartbeat(&mut self, _req: HeartbeatRequest) -> Result<HeartbeatResponse, OCPPCallErrorCode> {
///         Ok(
///             HeartbeatResponse {
///                 current_time: chrono::Utc::now()
///             }
///         )
///     }
/// }
///
/// let mut call_result_builder = MyResultBuilder {};
///
/// // Many messages can be handled with the same result builder
/// let msgs = vec![
///     r#""["2", "123", "Authorize", {"idTag": "test"}]""#,
///     r#""["2", "124", "Heartbeat", {}]""#,
/// ];
///
/// // Decode each message
/// for msg in msgs.iter() {
///     let message: OCPPMessage = serde_json::from_str(msg)?;
///
///     match message {
///         OCPPMessage::Call(call) => {
///             // Invoke builder to get response
///             match call_result_builder.build_response(call) {
///                 Ok(res) => {
///                     // A result was returned, encode and print it
///                     println!("Response: {:#?}", serde_json::to_string(&res));
///                 },
///                 Err(e) => {
///                     // Some error occured during processing
///                     println!("Error processing request: {:#?}", e);
///                 }
///             }
///         },
///         _ => {}
///     }
/// }
///
/// # return Ok(());
/// # }
/// ```
pub trait OCPPCallResultBuilder {
    /// Handle AuthorizeRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn authorize(
        &mut self,
        _req: AuthorizeRequest,
    ) -> Result<AuthorizeResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle BootNotificationRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn boot_notification(
        &mut self,
        _req: BootNotificationRequest,
    ) -> Result<BootNotificationResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle ChangeAvailabilityRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn change_availability(
        &mut self,
        _req: ChangeAvailabilityRequest,
    ) -> Result<ChangeAvailabilityResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle ChangeConfigurationRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn change_configuration(
        &mut self,
        _req: ChangeConfigurationRequest,
    ) -> Result<ChangeConfigurationResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle ClearCacheRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn clear_cache(
        &mut self,
        _req: ClearCacheRequest,
    ) -> Result<ClearCacheResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle ClearChargingProfileRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn clear_charging_profile(
        &mut self,
        _req: ClearChargingProfileRequest,
    ) -> Result<ClearChargingProfileResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle DataTransferRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn data_transfer(
        &mut self,
        _req: DataTransferRequest,
    ) -> Result<DataTransferResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle DiagnosticsStatusNotificationRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn diagnostics_status_notification(
        &mut self,
        _req: DiagnosticsStatusNotificationRequest,
    ) -> Result<DiagnosticsStatusNotificationResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle FirmwareStatusNotificationRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn firmware_status_notification(
        &mut self,
        _req: FirmwareStatusNotificationRequest,
    ) -> Result<FirmwareStatusNotificationResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle GetCompositeScheduleRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn get_composite_schedule(
        &mut self,
        _req: GetCompositeScheduleRequest,
    ) -> Result<GetCompositeScheduleResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle GetConfigurationRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn get_configuration(
        &mut self,
        _req: GetConfigurationRequest,
    ) -> Result<GetConfigurationResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle GetDiagnosticsRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn get_diagnostics(
        &mut self,
        _req: GetDiagnosticsRequest,
    ) -> Result<GetDiagnosticsResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle GetLocalListVersionRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn get_local_list_version(
        &mut self,
        _req: GetLocalListVersionRequest,
    ) -> Result<GetLocalListVersionResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle HeartbeatRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn heartbeat(
        &mut self,
        _req: HeartbeatRequest,
    ) -> Result<HeartbeatResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle MeterValuesRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn meter_values(
        &mut self,
        _req: MeterValuesRequest,
    ) -> Result<MeterValuesResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle RemoteStartTransactionRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn remote_start_transaction(
        &mut self,
        _req: RemoteStartTransactionRequest,
    ) -> Result<RemoteStartTransactionResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle RemoteStopTransactionRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn remote_stop_transaction(
        &mut self,
        _req: RemoteStopTransactionRequest,
    ) -> Result<RemoteStopTransactionResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle ResetRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn reset(&mut self, _req: ResetRequest) -> Result<ResetResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle SendLocalListRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn send_local_list(
        &mut self,
        _req: SendLocalListRequest,
    ) -> Result<SendLocalListResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle SetChargingProfileRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn set_charging_profile(
        &mut self,
        _req: SetChargingProfileRequest,
    ) -> Result<SetChargingProfileResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle StartTransactionRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn start_transaction(
        &mut self,
        _req: StartTransactionRequest,
    ) -> Result<StartTransactionResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle StatusNotificationRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn status_notification(
        &mut self,
        _req: StatusNotificationRequest,
    ) -> Result<StatusNotificationResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle StopTransactionRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn stop_transaction(
        &mut self,
        _req: StopTransactionRequest,
    ) -> Result<StopTransactionResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle TriggerMessageRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn trigger_message(
        &mut self,
        _req: TriggerMessageRequest,
    ) -> Result<TriggerMessageResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle UnlockConnectorRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn unlock_connector(
        &mut self,
        _req: UnlockConnectorRequest,
    ) -> Result<UnlockConnectorResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Handle UpdateFirmwareRequest. Returns [OCPPCallErrorCode::NotImplemented] by default.
    fn update_firmware(
        &mut self,
        _req: UpdateFirmwareRequest,
    ) -> Result<UpdateFirmwareResponse, OCPPCallErrorCode> {
        Err(OCPPCallErrorCode::NotImplemented)
    }
    /// Build [OCPPCallResult] from [OCPPCall]
    fn build_response(&mut self, call: OCPPCall) -> Result<OCPPCallResult, OCPPCallError> {
        let OCPPCall {
            unique_id, payload, ..
        } = call;
        if let Err(e) = payload.schema_validate() {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src/lib.rs:776",
                            "ocpp",
                            ::tracing::Level::WARN,
                            Some("src/lib.rs"),
                            Some(776u32),
                            Some("ocpp"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = CALLSITE.metadata().fields().iter();
                        CALLSITE.metadata().fields().value_set(&[(
                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                            Some(&::core::fmt::Arguments::new_v1(
                                &["OCPP Request Invalid: "],
                                &[::core::fmt::ArgumentV1::new_debug(&e)],
                            ) as &Value),
                        )])
                    });
                } else {
                }
            };
            return Err(OCPPCallError::from_call(
                &unique_id,
                OCPPCallErrorCode::ProtocolError,
            ));
        }
        let payload = match payload {
            OCPPCallPayload::Authorize(req) => self
                .authorize(req)
                .map(OCPPCallResultPayload::Authorize)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::BootNotification(req) => self
                .boot_notification(req)
                .map(OCPPCallResultPayload::BootNotification)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::ChangeAvailability(req) => self
                .change_availability(req)
                .map(OCPPCallResultPayload::ChangeAvailability)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::ChangeConfiguration(req) => self
                .change_configuration(req)
                .map(OCPPCallResultPayload::ChangeConfiguration)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::ClearCache(req) => self
                .clear_cache(req)
                .map(OCPPCallResultPayload::ClearCache)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::ClearChargingProfile(req) => self
                .clear_charging_profile(req)
                .map(OCPPCallResultPayload::ClearChargingProfile)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::DataTransfer(req) => self
                .data_transfer(req)
                .map(OCPPCallResultPayload::DataTransfer)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::DiagnosticsStatusNotification(req) => self
                .diagnostics_status_notification(req)
                .map(OCPPCallResultPayload::DiagnosticsStatusNotification)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::FirmwareStatusNotification(req) => self
                .firmware_status_notification(req)
                .map(OCPPCallResultPayload::FirmwareStatusNotification)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::GetCompositeSchedule(req) => self
                .get_composite_schedule(req)
                .map(OCPPCallResultPayload::GetCompositeSchedule)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::GetConfiguration(req) => self
                .get_configuration(req)
                .map(OCPPCallResultPayload::GetConfiguration)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::GetDiagnostics(req) => self
                .get_diagnostics(req)
                .map(OCPPCallResultPayload::GetDiagnostics)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::GetLocalListVersion(req) => self
                .get_local_list_version(req)
                .map(OCPPCallResultPayload::GetLocalListVersion)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::Heartbeat(req) => self
                .heartbeat(req)
                .map(OCPPCallResultPayload::Heartbeat)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::MeterValues(req) => self
                .meter_values(req)
                .map(OCPPCallResultPayload::MeterValues)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::RemoteStartTransaction(req) => self
                .remote_start_transaction(req)
                .map(OCPPCallResultPayload::RemoteStartTransaction)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::RemoteStopTransaction(req) => self
                .remote_stop_transaction(req)
                .map(OCPPCallResultPayload::RemoteStopTransaction)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::Reset(req) => self
                .reset(req)
                .map(OCPPCallResultPayload::Reset)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::SendLocalList(req) => self
                .send_local_list(req)
                .map(OCPPCallResultPayload::SendLocalList)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::SetChargingProfile(req) => self
                .set_charging_profile(req)
                .map(OCPPCallResultPayload::SetChargingProfile)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::StartTransaction(req) => self
                .start_transaction(req)
                .map(OCPPCallResultPayload::StartTransaction)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::StatusNotification(req) => self
                .status_notification(req)
                .map(OCPPCallResultPayload::StatusNotification)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::StopTransaction(req) => self
                .stop_transaction(req)
                .map(OCPPCallResultPayload::StopTransaction)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::TriggerMessage(req) => self
                .trigger_message(req)
                .map(OCPPCallResultPayload::TriggerMessage)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::UnlockConnector(req) => self
                .unlock_connector(req)
                .map(OCPPCallResultPayload::UnlockConnector)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
            OCPPCallPayload::UpdateFirmware(req) => self
                .update_firmware(req)
                .map(OCPPCallResultPayload::UpdateFirmware)
                .map_err(|e| OCPPCallError::from_call(&unique_id, e))?,
        };
        if let Err(e) = payload.schema_validate() {
            {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src/lib.rs:811",
                            "ocpp",
                            ::tracing::Level::ERROR,
                            Some("src/lib.rs"),
                            Some(811u32),
                            Some("ocpp"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::ERROR <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::ERROR <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = CALLSITE.metadata().fields().iter();
                        CALLSITE.metadata().fields().value_set(&[(
                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                            Some(&::core::fmt::Arguments::new_v1(
                                &["OCPP Response Invalid: "],
                                &[::core::fmt::ArgumentV1::new_debug(&e)],
                            ) as &Value),
                        )])
                    });
                } else {
                }
            };
            return Err(OCPPCallError::from_call(
                &unique_id,
                OCPPCallErrorCode::InternalError,
            ));
        }
        Ok(OCPPCallResult { unique_id, payload })
    }
}
#[rustc_main]
pub fn main() -> () {
    extern crate test;
    test::test_main_static(&[
        &test_macro,
        &compare_request_builder_validation_with_schema_validation,
        &compare_response_builder_validation_with_schema_validation,
        &test_boot_notification_response_validates,
        &test_enum_display,
        &test_boot_notification_request_validates,
        &test_boot_notification_request_charge_point_model_string_length_limit,
        &test_deserialize_json_call,
        &test_deserialize_json_call_result,
        &test_serialize_get_configuration_call,
        &test_charge_point_builder,
    ])
}
